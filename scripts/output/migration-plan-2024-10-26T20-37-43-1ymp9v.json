[
  {
    "_id": "1f69494bb217ca805accc04b1b81eb060816399b373dd1bc75ceea9c46cd8f9a",
    "_type": "desktopSdkDoc",
    "title": "Creating Your Own AddOn Window",
    "pathName": "creating_your_own_addon_window",
    "parent": "addon_development_overview",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "## The NTWindow Class\n\nThe **NTWindow** class allows you to quickly build windows using the same style and skin as other windows in NinjaTrader. An **NTWindow** does not contain user-interface functionality, but rather serves as a container for instances of **NTTabPage**, which will contain controls and functionality for the window.\n\n```csharp\n/* This is where we define our AddOn window. The actual content is contained inside the tabs of the window defined in a custom class inheriting from NTTabPage.\n    We must create a new window class which inherits from NTWindow for styling and implements the IWorkspacePersistence interface for the ability to save/restore from workspaces.*/\npublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence\n{\n   public AddOnFrameworkWindow()\n   {\n       // set Caption property (not Title), since Title is managed internally to properly combine selected Tab Header and Caption for display in the windows taskbar\n       // This is the name displayed in the top-left of the window\n       Caption = \"AddOn Framework\";\n \n       // Set the initial dimensions of the window\n       Width   = 1085;\n       Height = 900;\n   }\n} \n```\n\n## Using TabControl for Tab Functionality\n\nAfter declaring an **NTWindow**, you can enable tab functionality on it (creating new tabs, copying tabs, etc.). The process for implementing tab functionality must be done within the constructor for your **NTWindow**, using the following process:\n\n1. Instantiate a new **TabControl** object\n2. Call helper methods of the **TabControlManager** class, passing in your **TabControl** object as an argument, to enable specific functionality\n3. Use the same approach as #2 to set an **NTTabFactory** for your **TabControl** (see below for more information)\n4. Set the Content property of your **NTWindow** to your **TabControl**\n\n```csharp\npublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence\n{\n   public AddOnFrameworkWindow()\n   {\n       ...\n \n       // TabControl should be created for window content if tab features are wanted\n       TabControl tc = new TabControl();\n \n       // Attached properties defined in **TabControlManager** class should be set to achieve tab moving, adding/removing tabs\n       TabControlManager.SetIsMovable(tc, true);\n       TabControlManager.SetCanAddTabs(tc, true);\n       TabControlManager.SetCanRemoveTabs(tc, true);\n \n       // if ability to add new tabs is desired, **TabControl** has to have attached property \"Factory\" set.\n       TabControlManager.SetFactory(tc, new AddOnFrameworkWindowFactory());\n         \n       Content = tc;\n   }\n} \n```\n\nNote the instantiation of a new **AddOnFrameworkWindowFactory** in the example above. In this example, **AddOnFrameworkWindowFactory** is a custom class implementing the **INTTabFactory** interface. Within this class, the **CreateParentWindow()** and **CreateTabPage()** methods contained in **INTTabFactory** are hidden, as seen below:\n\n```csharp\n/* Class which implements **Tools.INTTabFactory** must be created and set as an attached property for **TabControl**\nin order to use tab page add/remove/move/duplicate functionality */\npublic class AddOnFrameworkWindowFactory : INTTabFactory\n{\n   // **INTTabFactory** member. Required to create parent window\n   public NTWindow CreateParentWindow()\n   {\n       return new AddOnFrameworkWindow();\n   }\n \n   // **INTTabFactory** member. Required to create tabs\n   public NTTabPage CreateTabPage(string typeName, bool isTrue)\n   {\n       return new NinjaTraderAddOnProject.AddOnPage();\n   }\n} \n```\n\n{% callout type=\"note\" %}\nTake note of the instantiation of the **AddOnPage** class in the example above. In our example, **AddOnPage** is a XAML-defined class. Thus, when **CreateTabPage()** is called on an instance of **AddOnFrameworkWindowFactory**, it instantiates our XAML-defined user interface. See below for more information on defining user interfaces in XAML.\n{% /callout %}\n\n## Creating an NTTabPage within an NTWindow\n\nWith an **NTWindow** defined and a **TabControl** set up, the next step is to instantiate an **NTTabPage** and add it to your **TabControl**. The first step is to define a class inheriting **NTTabPage** and implementing the **IInstrumentProvider** and **IIntervalProvider** interfaces to set up window-linking functionality.\n\n```csharp\n/* This is where we define the actual content of the tabs for our AddOn window.\n    Note: Class derived from **Tools.NTTabPage** has to be created if instrument link or interval link functionality is desired.\n    **Tools.IInstrumentProvider** and/or **Tools.IIntervalProvider** interface(s) should be implemented.\n    Also **NTTabPage** provides additional functionality for properly naming tab headers using properties and variables such as @FUNCTION, @INSTRUMENT, etc. */\npublic class AddOnFrameworkTab : NTTabPage, NinjaTrader.Gui.Tools.IInstrumentProvider, NinjaTrader.Gui.Tools.IIntervalProvider\n{\n   public AddOnFrameworkTab()\n   {\n       AddOnFrameworkWindowFactory myAddOnFrameworkWindowFactory = new AddOnFrameworkWindowFactory();\n \n       Content = myAddOnFrameworkWindowFactory.CreateTabPage(\"AddOnPage\",true);\n   }\n} \n```\n\nWith this class defined, the next step is to add it to your **TabControl**. You can do this via the **AddNTTabPage()** helper method contained in your **TabControl** object:\n\n```csharp\npublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence\n{\n   public AddOnFrameworkWindow()\n   {\n       ...\n \n       /* In order to have link buttons functionality, tab control items must be derived from **Tools.NTTabPage**\n       They can be added using extension method **AddNTTabPage(NTTabPage page)** */\n       tc.AddNTTabPage(new **AddOnFrameworkTab**());\n   }\n} \n```\n\n## Setting Up Workspace Persistence\n\nThe last step in setting up the foundation for your custom window is to configure it to be saved and restored in NinjaTrader workspaces.\n\n1. Hide the **WorkspaceOptions** property of the implemented **IWorkspacePersistence** interface\n2. Use a delegate to set the **WorkspaceOptions** property to a new instance of the **WorkspaceOptions** class inside the **NTWindow**'s constructor\n3. Hide the **Restore()** method of **IWorkspacePersistence** to call the static **RestoreFromXElement()** method on the **MainTabControl** property\n4. Hide the **Save()** method of **IWorkspacePersistence** to call the static **SaveToXElement** method in the same way\n\n```csharp\npublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence\n{\n   public AddOnFrameworkWindow()\n   {\n       ...\n \n       // **WorkspaceOptions** property must be set\n       Loaded += (o, e) =>\n       {\n           if (WorkspaceOptions == null)\n               WorkspaceOptions = new WorkspaceOptions(\"AddOnFramework-\" + Guid.NewGuid().ToString(\"N\"), this);\n       };\n   }\n     \n   // **IWorkspacePersistence** member. Required for restoring window from workspace\n   public void Restore(XDocument document, XElement element)\n   {\n       if (MainTabControl != null)\n           MainTabControl.RestoreFromXElement(element);\n   }\n \n   // **IWorkspacePersistence** member. Required for saving window to workspace\n   public void Save(XDocument document, XElement element)\n   {\n       if (MainTabControl != null)\n           MainTabControl.SaveToXElement(element);\n   }\n \n   // **IWorkspacePersistence** member\n   public WorkspaceOptions WorkspaceOptions { get; set; }\n} \n```\n\n## Using XAML to Define Window Layout\n\nThere are two options available for laying out the user interface in your **NTTabPage**. The first is to use XAML, a markup language commonly used to define graphical interfaces in WPF applications. The process of pairing a XAML file with your C# classes is straightforward; simply create your XAML class in its own file within your project, and it can be packaged together with your C# code in a DLL.\n\n```xml\n<!-- Example of creating a two-column grid in XAML -->\n<grid background=\"Transparent\">\n    <!-- Define our layout with two columns. Rows can then be assigned to columns -->\n    <grid.columndefinitions>\n        <columndefinition width=\"55*\"></columndefinition>\n        <columndefinition width=\"45*\"></columndefinition>\n    </grid.columndefinitions>\n</grid> \n```\n\n## Using C# to Define Window Layout\n\nYou are not required to use XAML for window layout. You can code everything in C# if you choose. Defining user interface elements in C# is more verbose than XAML, but all of the same functionality is available. The example below shows the C# equivalent of the XAML code in the prior section.\n\n```csharp\n// Example of creating a two-column grid in C#\nGrid grid = new Grid();\ngrid.Background = new SolidColorBrush(Colors.Transparent);\n \nColumnDefinition col1 = new ColumnDefinition();\ncol1.Width = new GridLength(55);\n \nColumnDefinition col2 = new ColumnDefinition();\ncol2.Width = new GridLength(45);\n \ngrid.ColumnDefinitions.Add(col1);\ngrid.ColumnDefinitions.Add(col2); \n```\n\n## Launching Your Window From the Control Center\n\nOnce your window is set up and laid out, you will need a way to launch it from the Control Center. This can be done by adding a new item into one of the Control Center's menus (most commonly the New menu). This can be accomplished in four steps:\n\n1. Obtain a reference to the Control Center menu in question\n2. Instantiate an **NTMenuItem**\n3. Add your **NTMenuItem** into the menu\n4. Attach your **NTMenuItem**'s Click event to a custom event handler\n5. Use your custom event handler to launch your **NTWindow**\n\n```csharp\n// Will be called as a new NTWindow is created. It will be called in the thread of that window\nprotected override void OnWindowCreated(Window window)\n{\n     \n   // We want to place our AddOn in the Control Center's menus\n   ControlCenter cc = window as ControlCenter;\n   if (cc == null)\n       return;\n \n   /* Determine we want to place our AddOn in the Control Center's \"New\" menu\n    Other menus can be accessed via the control's \"Automation ID\". For example: toolsMenuItem, workspacesMenuItem, connectionsMenuItem, helpMenuItem. */\n   NTMenuItem existingMenuItemInControlCenter = cc.FindFirst(\"ControlCenterMenuItemNew\") as NTMenuItem;\n   if (existingMenuItemInControlCenter == null)\n       return;\n \n   // 'Header' sets the name of our AddOn seen in the menu structure\n   NTMenuItem addOnFrameworkMenuItem = new NTMenuItem { Header = \"AddOn Framework\", Style = Application.Current.TryFindResource(\"MainMenuItem\") as Style };\n \n   // Add our AddOn into the \"New\" menu\n   existingMenuItemInControlCenter.Items.Add(addOnFrameworkMenuItem);\n \n   // Subscribe to the event for when the user presses our AddOn's menu item\n   addOnFrameworkMenuItem.Click += OnMenuItemClick;\n}\n \n// Open our AddOn's window when the menu item is clicked on\nprivate void OnMenuItemClick(object sender, RoutedEventArgs e)\n{\n   Core.Globals.RandomDispatcher.BeginInvoke(new Action(() => new AddOnFrameworkWindow().Show()));\n} \n```\n\nAs always, it is important to unsubscribe from event handlers and dispose of unused resources when they are no longer needed. The **OnWindowDestroyed()** method can be used to clean up our work from the examples above:\n\n```csharp\n// Will be called as a new NTWindow is destroyed. It will be called in the thread of that window\nprotected override void OnWindowDestroyed(Window window)\n{\n   if (addOnFrameworkMenuItem != null && window is ControlCenter)\n   {\n       if (existingMenuItemInControlCenter != null && existingMenuItemInControlCenter.Items.Contains(addOnFrameworkMenuItem))\n           existingMenuItemInControlCenter.Items.Remove(addOnFrameworkMenuItem);\n \n       addOnFrameworkMenuItem.Click -= OnMenuItemClick;\n       addOnFrameworkMenuItem = null;\n   }\n} \n```\n\n## Adding NinjaTrader Custom Controls\n\nUser-interface controls, such as buttons, text fields, and dropdown menus can be defined via XAML (or C#), then behavior and functionality of those controls can be set via C# along with the core logic of your AddOn. In addition to the [standard WPF controls](standard_wpf_controls), the NinjaScript AddOn framework provides access to each of the custom NinjaTrader controls that can be found throughout the platform. Below is a list of the most commonly used NinjaTrader controls, along with examples of defining these controls in XAML and adding functionality to them in C#:\n\n### 1. The Instrument Selector\n\n![AddOns_InstrumentSelector](addons_instrumentselector.png)\n\n```xaml\n<!-- Instrument Selector Definition -->\n<t:instrumentselector grid.column=\"0\" grid.row=\"6\" instrumentchanged=\"OnInstrumentChanged\" lastusedgroup=\"AddOnFramework\" x:name=\"instrumentSelector\">\n    <t:instrumentselector.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginBase}\" top=\"{StaticResource PaddingColumn}\"></thickness>\n    </t:instrumentselector.margin>\n</t:instrumentselector> \n```\n\n```csharp\n// Using the Instrument Selector\nprivate InstrumentSelector instrumentSelector;\n \n...\n \n// Find instrument selector and attach event handler\ninstrumentSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"instrumentSelector\") as InstrumentSelector;\nif (instrumentSelector != null)\n   instrumentSelector.InstrumentChanged += OnInstrumentChanged; \n```\n\n### 2. The Interval Selector\n\n![AddOns_IntervalSelector](addons_intervalselector.png)\n\n```xaml\n<!-- Interval Selector Definition -->\n<t:intervalselector grid.column=\"0\" horizontalalignment=\"Left\" intervalchanged=\"OnIntervalChanged\" x:name=\"intervalSelector\">\n    <t:intervalselector.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginBase}\" top=\"{StaticResource PaddingColumn}\"></thickness>\n    </t:intervalselector.margin>\n</t:intervalselector> \n```\n\n```csharp\n// Using the Interval Selector\nprivate IntervalSelector intervalSelector;\n \n...\n \n// Find interval selector and attach event handler\nintervalSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"intervalSelector\") as IntervalSelector;\nif (intervalSelector != null)\n   intervalSelector.IntervalChanged += OnIntervalChanged; \n```\n\n### 3. The Quantity Up/Down Selector\n\n![AddOns_QuantitySelector](addons_quantityselector.png)\n\n```xaml\n<!-- Quantity Up/Down Selector Definition -->\n<t:quantityupdown grid.column=\"0\" grid.row=\"12\" value=\"1\" x:name=\"qudSelector\">\n    <t:quantityupdown.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginBase}\" top=\"{StaticResource MarginControl}\"></thickness>\n    </t:quantityupdown.margin>\n</t:quantityupdown> \n```\n\n```csharp\n// Using the Quantity Up/Down Selector\nprivate QuantityUpDown qudSelector;\n \n...\n \n// Find Quantity selector\nqudSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"qudSelector\") as QuantityUpDown; \n```\n\n### 4. The Time-in-Force Selector\n\n![AddOns_TifSelector](addons_tifselector.png)\n\n```xaml\n<!-- Time-in-Force Selector Definition -->\n<t:tifselector grid.column=\"1\" grid.row=\"12\" x:name=\"tifSelector\">\n    <t:tifselector.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginButtonLeft}\" right=\"0\" top=\"{StaticResource MarginControl}\"></thickness>\n    </t:tifselector.margin>\n</t:tifselector> \n```\n\n```csharp\n// Using the Time-in-Force Selector\nprivate TifSelector tifSelector;\n \n...\n \n// Find TIF selector\ntifSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"tifSelector\") as TifSelector;\n \n// Be sure to bind our account selector to our TIF selector to ensure proper functionality\ntifSelector.SetBinding(TifSelector.AccountProperty, new Binding { Source = accountSelector, Path = new PropertyPath(\"SelectedAccount\") });\n \n// When our TIF selector's selection changes\ntifSelector.SelectionChanged += (o, args) =>\n{\n   // Change the selected TIF in the ATM strategy too\n   if (atmStrategySelector.SelectedAtmStrategy != null)\n   {\n       atmStrategySelector.SelectedAtmStrategy.TimeInForce = tifSelector.SelectedTif;\n   }\n}; \n```\n\n### 5. The ATM Strategy Selector\n\n![AddOns_AtmSelector](addons_atmselector.png)\n\n```xaml\n<!-- ATM Strategy Selector Definition -->\n<atmstrategy:atmstrategyselector grid.column=\"2\" grid.row=\"12\" linkedquantity=\"{Binding ElementName=qudSelector, Path=Value, Mode=OneWay}\" x:name=\"atmStrategySelector\">\n    <atmstrategy:atmstrategyselector.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginButtonLeft}\" right=\"{StaticResource MarginBase}\" top=\"{StaticResource MarginControl}\"></thickness>\n    </atmstrategy:atmstrategyselector.margin>\n</atmstrategy:atmstrategyselector> \n```\n\n#### Using the ATM Strategy Selector\n\n```csharp\nprivate AtmStrategy.AtmStrategySelector atmStrategySelector;\n\n \n...\n \n// Find ATM Strategy selector and attach event handler\natmStrategySelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"atmStrategySelector\") as AtmStrategy.AtmStrategySelector;\natmStrategySelector.Id = Guid.NewGuid().ToString(\"N\");\nif (atmStrategySelector != null)\n   atmStrategySelector.CustomPropertiesChanged += OnAtmCustomPropertiesChanged;\n \n// Be sure to bind our account selector to our ATM strategy selector to ensure proper functionality\natmStrategySelector.SetBinding(AtmStrategy.AtmStrategySelector.AccountProperty, new Binding { Source = accountSelector, Path = new PropertyPath(\"SelectedAccount\") });\n \n// When our ATM selector's selection changes\natmStrategySelector.SelectionChanged += (o, args) =>\n{\n   if (atmStrategySelector.SelectedItem == null)\n       return;\n   if (args.AddedItems.Count > 0)\n   {\n       // Change the selected TIF in our TIF selector too\n       NinjaTrader.NinjaScript.AtmStrategy selectedAtmStrategy = args.AddedItems[0] as NinjaTrader.NinjaScript.AtmStrategy;\n       if (selectedAtmStrategy != null)\n       {\n           tifSelector.SelectedTif = selectedAtmStrategy.TimeInForce;\n       }\n   }\n}; \n```\n\n## Linking with Other Windows\n\nIf you utilize NinjaTrader controls to allow selection of instruments or intervals, you can add instrument or interval linking functionality to your window. The **PropagateInstrumentChange()** and **PropagateIntervalChange()** methods can be used to accomplish this. To call **PropagateIntervalChange()**, use the process below:\n\n1. Hide the **Instrument** property of the **IInstrumentProvider** interface, which your **NTTabPage** inheriting class should be implementing\n2. Call **PropagateInstrumentChange()** within the setter for the hidden **Instrument** property\n\n```csharp\n// **IInstrumentProvider** member. Required if you want to use the instrument link mechanism on this window.\npublic **Cbi.Instrument** Instrument\n{\n   get { return instrument; }\n   set\n   {\n       // Send instrument to other windows linked to the same color\n       PropagateInstrumentChange(value);\n   }\n} \n```\n\nIn a real-world scenario, you would most likely use an instrument selector to call the setter for the **Instrument** property. Thus, when a user toggled the instrument selector, **PropagateInstrumentChange()** would be called in addition to any other logic you put in place. In the same way, you can use an interval selector to push changes to the Interval Linking feature. In this case, you can attach a custom event handler to an interval selector's **IntervalChanged** event, then call **PropagateIntervalChange()** within that event handler:\n\n```csharp\n...\n \n// Find an interval selector that we've added to our UI, and attach a custom event handler\nintervalSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"intervalSelector\") as IntervalSelector;\nif (intervalSelector != null)\n   intervalSelector.IntervalChanged += OnIntervalChanged;\n     \n...\n \n// This method is fired when our interval selector changes intervals\nprivate void OnIntervalChanged(object sender, BarsPeriodEventArgs args)\n{\n   if (args.BarsPeriod == null)\n       return;\n \n   PropagateIntervalChange(args.BarsPeriod); \n} \n```"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "advanced_custom_drawing",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "## Entering Calculation Logic\n\nThe **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method called for indicator calculation, and we will calculate the CCI value and set the conditions used to draw the CCI plot within this method.\n\nThe **OnStateChange()** method is called once before any bar data is loaded, and is used to configure the indicator (among other things).\n\n## Initializing the Indicator  \n\nThe code below is automatically generated by the wizard and added to the **OnStateChange()** method, within **State.SetDefaults**. It configures the indicator for one plot and five lines, and sets the parameters entered in the wizard:\n\n```csharp\nAddPlot(Brushes.Orange, \"MyPlot\");\nAddLine(Brushes.DimGray, 200, \"Level 2\");\nAddLine(Brushes.DimGray, 100, \"Level 1\");\nAddLine(Brushes.DimGray, 0, \"Zero Line\");\nAddLine(Brushes.DimGray, -100, \"Level -1\");\nAddLine(Brushes.DimGray, -200, \"Level -2\");\n````\n\nTo change the visual properties of the Zero Line, replace the fourth line in the code above with the line below. This will change the color to black and the line style to \"dash:\"\n\n```csharp\n\n* AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n```\n\nThe code above uses an alternative method overload (an alternative set of arguments passed in to the **AddLine()** method), in order to pass in a **Stroke** object rather than a **Brush**. With a Stroke, not only can we still specify a Brush, but we have additional options to change the dash style (via **DashStyleHelper**) and the line width. After this change, your configured lines and plots should look like this:\n\n```csharp\nAddPlot(Brushes.Orange, \"MyCCI_Plot\");\nAddLine(Brushes.DimGray, 200, \"Level 2\");\nAddLine(Brushes.DimGray, 100, \"Level 1\");\nAddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\nAddLine(Brushes.DimGray, -100, \"Level -1\");\nAddLine(Brushes.DimGray, -200, \"Level -2\");\n```\n\n## Adding Core Indicator Logic\n\nSince this tutorial is meant to cover custom drawing and manually changing properties within an indicator, we will not go too in-depth into the core calculation logic for this custom CCI. Instead, we will copy and paste the core calculation logic from the **@CCI** indicator already built-in to NinjaTrader.\n\nThe **@CCI** indicator uses an **SMA** object in its calculations. To add this, copy the line below from **@CCI** into your custom CCI, directly below the class declaration:\n\n```csharp\nprivate SMA sma;\n```\n\nNext, copy the following initialization for the **SMA** object into the **OnStateChange()** method, within **State.DataLoaded**:\n\n```csharp\n\nsma = SMA(Typical, Period);\n```\n\nNext, copy the core calculation logic from **@CCI** into the **OnBarUpdate()** method of your custom indicator:\n\n```csharp\nif (CurrentBar == 0)\n   Value[0] = 0;\nelse\n{\n   double mean = 0;\n   double sma0 = sma[0];\n\n   for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n       mean += Math.Abs(Typical[idx] - sma0);\n\n   Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n}\n```\n\nThe code for your **MyCCI** class should now look as follows (in addition to the using statements and class declaration):\n\n```csharp\n\npublic class MyCCI : Indicator\n{\n   private SMA sma;\n\n   protected override void OnStateChange()\n   {\n       if (State == State.SetDefaults)\n       {\n           Description = @\"NinjaScript Custom Drawing Indicator Tutorial\";\n           Name = \"MyCCI\";\n           Calculate = Calculate.OnBarClose;\n           IsOverlay = false;\n           DisplayInDataBox = true;\n           DrawOnPricePanel = true;\n           DrawHorizontalGridLines = true;\n           DrawVerticalGridLines = true;\n           PaintPriceMarkers = true;\n           ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;\n           IsSuspendedWhileInactive = true;\n           Period = 14;\n           AddPlot(Brushes.Orange, \"MyPlot\");\n           AddLine(Brushes.DimGray, 200, \"Level 2\");\n           AddLine(Brushes.DimGray, 100, \"Level 1\");\n           AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n           AddLine(Brushes.DimGray, -100, \"Level -1\");\n           AddLine(Brushes.DimGray, -200, \"Level -2\");\n       }\n       else if (State == State.DataLoaded)\n       {\n           sma = SMA(Typical, Period);\n       }\n   }\n\n   protected override void OnBarUpdate()\n   {\n       if (CurrentBar == 0)\n           Value[0] = 0;\n       else\n       {\n           double mean = 0;\n           double sma0 = sma[0];\n\n           for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n               mean += Math.Abs(Typical[idx] - sma0);\n\n           Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n       }\n   }\n}\n```\n\n## Custom Drawing  \n\nAdd the following code into the **OnBarUpdate()** method, directly beneath the core calculation logic:\n\n```csharp\n\n// if the plot value is greater than 100, paint the plot green at that bar index\nif (Value[0] > 100)\n   PlotBrushes[0][0] = Brushes.Green;\n\n// if the plot value is less than -100, paint the plot red at that bar index\nif (Value[0] < -100)\n   PlotBrushes[0][0] = Brushes.Red;\n\n// if the plot value is between 100 and -100, paint the plot orange at that bar index\nif (Value[0] >= -100 && Value[0] <= 100)\n   PlotBrushes[0][0] = Brushes.Orange;\n```\n\nThis will conditionally change the color of the CCI plot (referenced by **Values[0]**) based on its value. By using **PlotBrushes[0][0]**, we are specifying that we wish to change the color of the first plot in the collection at a specific bar index (the current bar index each time the condition is triggered), and we wish for the plot to remain that color at that index, even if the plot value changes in the future. If instead we wished to change the entire plot color, we could use **Plots[0].Brush**.\n\n**PlotBrushes** holds a collection of brushes used for the various plots in the indicator. In addition to this, there are several other collections that serve similar purposes, which can be used in the same way. Some examples of these collections are below:\n\n{% table %}\n\n* Collection | Description\n\n---\n\n* [BackBrushes](backbrushes.htm) | A collection of Brushes used for chart background color at specific bar indexes\n* [BarBrushes](barbrushes.htm) | A collection of Brushes used to paint bars at specific indexes\n* [CandleOutlineBrushes](candleoutlinebrushes.htm) | A collection of Brushes used to paint candle outlines at specific indexes\n{% /table %}\n\nNow that everything is in place, your class code should look as below. You are now ready to [compile the indicator](compiling6.htm) and configure it on a chart.\n\n```csharp\n\npublic class MyCCI : Indicator\n{\n   private SMA sma;\n\n   protected override void OnStateChange()\n   {\n       if (State == State.SetDefaults)\n       {\n           Description = @\"NinjaScript Custom Drawing Indicator Tutorial\";\n           Name = \"MyCCI\";\n           Calculate = Calculate.OnBarClose;\n           IsOverlay = false;\n           DisplayInDataBox = true;\n           DrawOnPricePanel = true;\n           DrawHorizontalGridLines = true;\n           DrawVerticalGridLines = true;\n           PaintPriceMarkers = true;\n           ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;\n           IsSuspendedWhileInactive = true;\n           Period = 14;\n           AddPlot(Brushes.Orange, \"MyPlot\");\n           AddLine(Brushes.DimGray, 200, \"Level 2\");\n           AddLine(Brushes.DimGray, 100, \"Level 1\");\n           AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n           AddLine(Brushes.DimGray, -100, \"Level -1\");\n           AddLine(Brushes.DimGray, -200, \"Level -2\");\n       }\n       else if (State == State.DataLoaded)\n       {\n           sma = SMA(Typical, Period);\n       }\n   }\n\n   protected override void OnBarUpdate()\n   {\n       if (CurrentBar == 0)\n           Value[0] = 0;\n       else\n       {\n           double mean = 0;\n           double sma0 = sma[0];\n\n           for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n               mean += Math.Abs(Typical[idx] - sma0);\n\n           Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n       }\n\n       if (Value[0] > 100)\n           PlotBrushes[0][0] = Brushes.Green;\n\n       if (Value[0] < -100)\n           PlotBrushes[0][0] = Brushes.Red;\n\n       if (Value[0] >= -100 && Value[0] <= 100)\n           PlotBrushes[0][0] = Brushes.Orange;\n   }\n\n   #region Properties\n   [NinjaScriptProperty]\n   [Range(1, int.MaxValue)]\n   [Display(Name=\"Period\", Description=\"The CCI Period\", Order=1, GroupName=\"Parameters\")]\n   public int Period\n   { get; set; }\n\n   [Browsable(false)]\n   [XmlIgnore]\n   public Series<double> MyPlot\n   {\n       get { return Values[0]; }\n   }\n   #endregion\n}\n```"
  },
  {
    "_id": "aba73bf1f1c07b2d35c9b2f14b7ae04b571db42bb9659de08e4b3f5efddc43fe",
    "_type": "desktopSdkDoc",
    "title": "Advanced - Custom Drawing",
    "pathName": "advanced_custom_drawing",
    "parent": "developing_indicators",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "## Custom Drawing Overview\n\nIn this advanced tutorial, we are going to build a custom indicator which is a variation on the CCI, to show different drawing options for bar color, line color, and background color.\n\n* [Set Up](set_up9)\n* [Entering Calculation Logic](entering_calculation_logic6)\n* [Compiling](compiling6)\n* [Using](using6)\n\n{% callout type=\"note\" %}\n\nPlease note that the JavaScript code and HTML artifacts have been removed as per the instructions.\n{% /callout %}"
  },
  {
    "_id": "08ff2f1125f8035054bbb835909111bf9060904444bed8309ec59a88c617bf77",
    "_type": "desktopSdkDoc",
    "title": "Beginner - Indicator on Indicator",
    "pathName": "beginner_indicator_on_indicator",
    "parent": "developing_indicators",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "## Indicator on Indicator Overview\r\n\r\nIn this beginner level tutorial we are going to build a custom indicator that calculates a moving average of volume. This indicator will show you how to use the built in indicators of [Moving Average (SMA)](moving_average_-_simple_sma) and [Volume](volume.md).\r\n\r\n* [Set Up](set_up5)\r\n* [Entering Calculation Logic](entering_calculation_logic2)\r\n* [Compiling](compiling2)\r\n* [Using](using2)"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "developing_indicators",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "The **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (testing to see if a Close price on a specified bar was greater than the previous Close price) within this method.\r\n\r\n## Adding the Condition and Assigning the Plot Value\r\n\r\nEnter the following code in the **OnBarUpdate()** method in the NinjaScript Editor:\r\n\r\n```csharp\r\nValues[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize))\r\n```\r\n\r\nAlthough the code above fits on a single line, it is doing several things. Firstly, it is important to understand the structure that we are using in this statement. We are using a **Ternary Operator**, which provides a way to assign one of two values to a variable based on a condition. We begin by stating that we wish to assign a value to the indicator plot at a bar index corresponding to **BarsAgo**. We do this by using **Values**, which is a collection holding values for all plots configured in the indicator:\r\n\r\n```csharp\r\n Values[0][BarsAgo] =\r\n```\r\n\r\nNext, we add a condition to test. In this case, we are testing to see whether **Close** at a bar index corresponding to the value of **BarsAgo** was greater than **Close** at a value of **BarsAgo + 1**. If **BarsAgo** was set to 5, for example, this would compare **Close[5]** to **Close[6]**:\r\n\r\n```csharp\r\nValues[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ?\r\n```\r\n\r\nIf the condition evaluates to true, then the first expression will be run (the expression on the left side of the colon \":\"), which will assign the value of the indicator plot to the **High** price of the specified bar, plus five ticks. We obtain the tick size value for the configured instrument via the **TickSize** property:\r\n\r\n```csharp\r\nValues[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 * TickSize)) :\r\n```\r\n\r\nIf the condition evaluates to false, then the second expression will be run (the expression on the right side of the colon \":\", which will assign the value of the indicator plot to the **Low** price of the specified bar, less five ticks:\r\n\r\n```csharp\r\nValues[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize))\r\n```\r\n\r\nThe core indicator logic is now in place, but running this code as it is can result in an \"Index out of range\" exception. Since we are looking a certain number of bars back in time, we need to make sure that there are always enough bars on the chart for us to look back. For example, if **BarsAgo** were set to 5, then we would be comparing the value of five bars ago to the value of six bars ago, but on Bars # 1, 2, 3, 4, or 5, at which point we do not have five or six bars to look back, the indicator will cause an error. To resolve this, we will add a condition which will prevent the core calculations from running unless we know there are enough bars on the chart. Add the following line just above the line you have been working on throughout this page:\r\n\r\n```csharp\r\nif(CurrentBar < BarsAgo + 1)\r\n   return;\r\n```\r\n\r\nThis line says, \"if there is not a number of bars equal to one number greater than the value of **BarsAgo**, then exit **OnBarUpdate()**.\"\r\n\r\nNow that everything is in place, your class code should look as below. You are now ready to **compile the indicator** and configure it on a chart:\r\n\r\n```csharp\r\npublic class PriceVariableTutorial : Indicator\r\n{\r\n   protected override void OnStateChange()\r\n   {\r\n       if (State == State.SetDefaults)\r\n       {\r\n           Description                     = @\"NinjaScript Price Variables Tutorial\";\r\n           Name                           = \"PriceVariableTutorial\";\r\n           Calculate                       = Calculate.OnBarClose;\r\n           IsOverlay                       = false;\r\n           DisplayInDataBox               = true;\r\n           DrawOnPricePanel               = true;\r\n           DrawHorizontalGridLines         = true;\r\n           DrawVerticalGridLines           = true;\r\n           PaintPriceMarkers               = true;\r\n           ScaleJustification               = NinjaTrader.Gui.Chart.ScaleJustification.Right;\r\n           //Disable this property if your indicator requires custom values that cumulate with each new market data event.\r\n           //See Help Guide for additional information.\r\n           IsSuspendedWhileInactive       = true;\r\n           BarsAgo                         = 0;\r\n           AddPlot(Brushes.Orange, \"MyPlot\");\r\n       }\r\n       else if (State == State.Configure)\r\n       {\r\n       }\r\n   }\r\n\r\n   protected override void OnBarUpdate()\r\n   {\r\n       if(CurrentBar < BarsAgo + 1)\r\n           return;\r\n\r\n       Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 * TickSize)) : (Low[BarsAgo] - (5 * TickSize));\r\n   }\r\n\r\n   #region Properties\r\n   [Range(0, int.MaxValue)]\r\n   [NinjaScriptProperty]\r\n   [Display(Name=\"BarsAgo\", Description=\"How many bars ago to use for the plot value\", Order=1)]\r\n   public int BarsAgo\r\n   { get; set; }\r\n\r\n   [Browsable(false)]\r\n   [XmlIgnore]\r\n   public Series<double> MyPlot\r\n   {\r\n       get { return Values[0]; }\r\n   }\r\n   #endregion\r\n}\r\n```"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "developing_indicators",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "The **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (calculating an average of volume) within this method.\n\n## Calculating the Average\n\nNinjaTrader has built in indicators that you can reference in your calculations. Since we are calculating a simple moving average of volume it would make sense for us to use the built in SMA indicator and Volume indicators.\n\nEnter the following code into the **OnBarUpdate()** method in the NinjaScript Editor:\n\n```csharp\n// Calculate the volume average\ndouble average = SMA(VOL(), Periods)[0];\n```\n\nHere we declared the variable \"average\" which is of type double. This serves as the temporary storage for the current value of the simple moving average of volume. We then use the simple moving average indicator and pass in the volume indicator as its input, pass in our indicator \"Periods\" property (a parameter we defined in the wizard) and access the current value \"[0]\" that we will assign to our variable \"average\". If we wanted to assign the value one bar ago, we could have used \"[1]\".\n\n## Final Assignment\n\nEnter the following code into the **OnBarUpdate()** method and below the code snippet you entered above:\n\n```csharp\n// Set the calculated value to the plot\nMyPlot[0] = average;\n```\n\nHere we assign the \"average\" value to the property that represents the plot data using the '=' assignment operator. We have just finished coding our simple moving average of volume. Your class code should look identical to the code below. You are now ready to [compile the indicator](compiling2) and configure it on a chart.\n\n```csharp\npublic class VolSMA : Indicator\n{\n   protected override void OnStateChange()\n   {\n     if (State == State.SetDefaults)\n     {\n         Description                     = @\"Moving average of volume\";\n         Name                             = \"VolSMA\";\n         Calculate                         = Calculate.OnBarClose;\n         IsOverlay                         = false;\n         DisplayInDataBox                 = true;\n         DrawOnPricePanel                 = true;\n         DrawHorizontalGridLines           = true;\n         DrawVerticalGridLines             = true;\n         PaintPriceMarkers                 = true;\n         ScaleJustification               = NinjaTrader.Gui.Chart.ScaleJustification.Right;\n         //Disable this property if your indicator requires custom values that cumulate with each new market data event. \n         //See Help Guide for additional information.\n         IsSuspendedWhileInactive         = true;\n         Periods                           = 10;\n         AddPlot(Brushes.Orange, \"MyPlot\");\n     }\n     else if (State == State.Configure)\n     {\n     }\n   }\n   protected override void OnBarUpdate()\n   {\n     // Calculate the volume average\n     double average = SMA(VOL(), Periods)[0];\n     // Set the calculated value to the plot\n     MyPlot[0] = average;\n   }\n   #region Properties\n   [NinjaScriptProperty]\n   [Range(1, int.MaxValue)]\n   [Display(Name=\"Periods\", Description=\"Number of periods\", Order=1, GroupName=\"Parameters\")]\n   public int Periods\n   { get; set; }\n   [Browsable(false)]\n   [XmlIgnore]\n    public Series<double> MyPlot\n   {\n     get { return Values[0]; }\n   }\n   #endregion\n```"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "developing_indicators",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "## Entering Calculation Logic\r\n\r\nThe **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate a simple moving average.\r\n\r\n## Are there enough bars?\r\n\r\nEnter the following code into the **OnBarUpdate()** method in the NinjaScript Editor:\r\n\r\n```csharp\r\n// Do not calculate if we don't have enough bars \r\nif (CurrentBar < Period) return;\r\n```\r\n\r\nTo calculate a 20 period moving average you will need a minimum of 20 bars of data. The first statement in our **OnBarUpdate()** method checks to see if there are enough bars of data to perform the moving average calculation. **CurrentBar** returns the index number of the current bar and this is checked against the user-defined parameter **Period**. If the current bar number is less than the user-defined period we \"return\" which skips calculating the moving average.\r\n\r\n## Getting a sum of closing prices\r\n\r\nEnter the following code into the **OnBarUpdate()** method and below the code snippet you entered above:\r\n\r\n```csharp\r\n// Get a sum of prices over the specified period\r\ndouble sum = 0; \r\nfor (int barsAgo = 0; barsAgo < Period; barsAgo++) \r\n{ \r\n   sum = sum + Input[barsAgo]; \r\n}\r\n```\r\n\r\nFirst we must declare a variable that will store our sum total.\r\n\r\n```csharp\r\ndouble sum = 0;\r\n```\r\n\r\nThe variable **sum** whose value is of type **double** will serve as temporary storage.\r\n\r\n```csharp\r\nfor (int barsAgo = 0; barsAgo < Period; barsAgo++) \r\n{ \r\n   sum = sum + Input[barsAgo]; \r\n}\r\n```\r\n\r\nNext we must calculate the sum. We use a standard \"for\" loop to skip through prices and add them to the **sum** variable. Although the command that represents the loop may look intimidating, it's really quite simple. Let's look at it in English....\r\n\r\nWhat the loop is saying is:\r\n\r\n1. the number of bars ago is now zero\r\n2. as long as the number of bars ago is less than the moving average period, then go to line 3 otherwise this loop is finished\r\n3. get the price **Input[number of bars ago]** and add it to the running sum total\r\n4. add one to the number of bars ago (if number of bars ago was zero it will now be one)\r\n5. go to line 2\r\n\r\nYou can find more information on [how loops work here](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements). Once the loop has finished, it will have calculated the total sum of closing prices for the period of our moving average.\r\n\r\n* We use the value of **Input[barsAgo]** to get a price to use for our calculation. We could have substituted **Close[barsAgo]** to use closing prices or **High[barsAgo]** to use high prices. The reason we use **Input[barsAgo]** is since this allows flexibility for what the indicator is calculated based off of. Remember users have the option to select a price type (High, Open, Close etc...) from the Indicator Dialog window.\r\n\r\n## The final calculation\r\n\r\nEnter the following code into the **OnBarUpdate()** method and below the code snippet you entered above:\r\n\r\n```csharp\r\n// Calculate and set the average value to the 'MyPlot' property\r\nMyPlot[0] = sum / Period;\r\n```\r\n\r\nWe can now calculate the final moving average value and assign its value to the property that represents the plot data. We have just finished coding our simple moving average. The class code in your editor should look identical to the image below. You are now ready to [compile the indicator](compiling3).\r\n\r\n```csharp\r\npublic class MySMA : Indicator\r\n{\r\n   protected override void OnStateChange()\r\n   {\r\n     if (State == State.SetDefaults)\r\n     {\r\n         Description                     = @\"Simple Moving Average\";\r\n         Name                             = \"MySMA\";\r\n         Calculate                         = Calculate.OnBarClose;\r\n         IsOverlay                         = true;\r\n         DisplayInDataBox                 = true;\r\n         DrawOnPricePanel                 = true;\r\n         DrawHorizontalGridLines           = true;\r\n         DrawVerticalGridLines             = true;\r\n         PaintPriceMarkers                 = true;\r\n         ScaleJustification               = NinjaTrader.Gui.Chart.ScaleJustification.Right;\r\n         //Disable this property if your indicator requires custom values that cumulate with each new market data event. \r\n         //See Help Guide for additional information.\r\n         IsSuspendedWhileInactive         = true;\r\n         Period                           = 20;\r\n         AddPlot(Brushes.Orange, \"MyPlot\");\r\n     }\r\n     else if (State == State.Configure)\r\n     {\r\n     }\r\n   }\r\n\r\n   protected override void OnBarUpdate()\r\n   {\r\n     // Do not calculate if we don't have enough bars \r\n     if (CurrentBar < Period) return;\r\n       \r\n     // Get a sum of prices over the specified period\r\n     double sum = 0; \r\n     for (int barsAgo = 0; barsAgo < Period; barsAgo++) \r\n     { \r\n         sum = sum + Input[barsAgo]; \r\n     }\r\n       \r\n     // Calculate and set the average value to the 'MyPlot' property\r\n     MyPlot[0] = sum / Period;\r\n   }\r\n\r\n   #region Properties\r\n   [NinjaScriptProperty]\r\n   [Range(1, int.MaxValue)]\r\n   [Display(Name=\"Period\", Description=\"Number of Periods\", Order=1, GroupName=\"Parameters\")]\r\n   public int Period\r\n   { get; set; }\r\n\r\n   [Browsable(false)]\r\n   [XmlIgnore]\r\n   public Series<double> MyPlot\r\n   {\r\n     get { return Values[0]; }\r\n   }\r\n   #endregion\r\n}\r\n```\r\n\r\n## Alternate Implementation\r\n\r\nIn this tutorial we are using a \"for\" loop to iterate through a collection of prices and accumulate a sum value. We chose this approach to demonstrate the use of a loop. A simple moving average can actually be expressed in a more efficient manner using the built-in **SUM** indicator as shown below.\r\n\r\n```csharp\r\n// Do not calculate if we don't have enough bars\r\nif (CurrentBar < Period) return;\r\n\r\n// Calculate and set the 'average' value to the 'MyPlot' property\r\nMyPlot[0] = SUM(Input, Period)[0] / Period;\r\n```"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "developing_indicators",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "The OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations and is called on each bar of a data series when re-calculating the indicator. For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed. Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate the ROC value.\r\n\r\n## Setting Plot Thresholds  \r\n\r\nThe OnStateChange() method is called once before any bar data is loaded and is used to configure the indicator. The code below is automatically generated by the wizard and added to the OnStateChange() method. It configures the indicator for two plots and one line and sets the parameters.\r\n\r\n```csharp\r\nAddLine(Brushes.Black, 0, \"ZeroLine\");\r\nAddPlot(Brushes.Green, \"AboveZero\");\r\nAddPlot(Brushes.OrangeRed, \"BelowZero\");\r\n```\r\n\r\nEnter the following code in the OnStateChange() method and below the wizard generated code:\r\n\r\n```csharp\r\n// Set the threshold values for each plot\r\nPlots[0].Min = 0;\r\nPlots[1].Max = 0;\r\n```\r\n\r\nThe concept of setting threshold values is to set when and when not to paint a plot on the chart. In this indicator, we have an \"AboveZero\" plot with a default color of green which we only want to see when the value of ROC is above zero and a \"BelowZero\" plot with a default color of OrangeRed which we only want to see when the value of ROC is below zero. In order to make that happen we have to set the threshold values of each plot.\r\n\r\n**Plots[0].Min = 0;**\r\n\r\nThis statement says, in the collection of Plot objects, take the first one (**Plots[0]**) and set its minimum value to zero. This means any value below zero will not display.\r\n\r\n**Plots[1].Max = 0;**\r\n\r\nThis statement says, in the collection of Plot objects, take the second one (**Plots[1]**) and set its maximum value to zero. This means any value above zero will not display.\r\n\r\nWe now have a simple plot switching mechanism that displays the correct colored line depending on if the value of ROC is above or below zero. In fact, you can take this concept a little bit farther. You can even set different plots style (bar, dot etc..) depending on threshold values.\r\n\r\nA quick word about collections. Collections are objects that store a collection of objects, kind of like a container. In this case we are working with a collection of plots. In the above wizard generated code you will notice that we are adding new plots to the \"Plots\" collection. \"AboveZero\" was added first and then \"BelowZero\". This means that we can reference the \"AboveZero\" plot object through **Plots[0]**. The reason we don't pass in a value of 1 is because collections are zero based indexes. This means the first item has an index of 0, the second time an index of 1 and so forth.\r\n\r\n## Completing the Indicator\r\n\r\nThis indicator is actually quite simple in its implementation. The last thing we need to do is add the calculation code and set the value of ROC to both our plot lines.\r\n\r\nReplace the wizard generated code with the following code into the OnBarUpdate() method in the NinjaScript Editor:\r\n\r\n```csharp\r\n\r\n// Are there enough bars\r\nif (CurrentBar < Period) return;\r\n\r\n// Set the plot values\r\nAboveZero[0] = SMA(ROC(Period), Smooth)[0];\r\nBelowZero[0] = SMA(ROC(Period), Smooth)[0];\r\n```\r\n\r\nThe calculation first checks to ensure there are enough bars to complete the calculation and then sets both plot lines to the ROC value.\r\n\r\nThe class code in your editor should look identical to the image below. You are now ready to [compile the indicator](compiling) and configure it on a chart.\r\n\r\n```csharp\r\n\r\npublic class CustomROC : Indicator\r\n{\r\n    protected override void OnStateChange()\r\n    {\r\n        if (State == State.SetDefaults)\r\n        {\r\n            Description = @\"ROC with custom line color options\";\r\n            Name = \"CustomROC\";\r\n            Calculate = Calculate.OnBarClose;\r\n            IsOverlay = false;\r\n            DisplayInDataBox = true;\r\n            DrawOnPricePanel = true;\r\n            DrawHorizontalGridLines = true;\r\n            DrawVerticalGridLines = true;\r\n            PaintPriceMarkers = true;\r\n            ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;\r\n            //Disable this property if your indicator requires custom values that cumulate with each new market data event.\r\n            //See Help Guide for additional information.\r\n            IsSuspendedWhileInactive = true;\r\n            Period = 14;\r\n            Smooth = 3;\r\n            AddLine(Brushes.Black, 0, \"ZeroLine\");\r\n            AddPlot(Brushes.Green, \"AboveZero\");\r\n            AddPlot(Brushes.OrangeRed, \"BelowZero\");\r\n            Plots[0].Min = 0;\r\n            Plots[1].Max = 0;\r\n        }\r\n        else if (State == State.Configure)\r\n        {\r\n        }\r\n    }\r\n\r\n    protected override void OnBarUpdate()\r\n    {\r\n        // Are there enough bars\r\n        if (CurrentBar < Period) return;\r\n\r\n        // Set the plot values\r\n        AboveZero[0] = SMA(ROC(Period), Smooth)[0];\r\n        BelowZero[0] = SMA(ROC(Period), Smooth)[0];\r\n    }\r\n\r\n    #region Properties\r\n    [NinjaScriptProperty]\r\n    [Range(1, int.MaxValue)]\r\n    [Display(Name=\"Period\", Description=\"Number of periods\", Order=1, GroupName=\"Parameters\")]\r\n    public int Period\r\n    { get; set; }\r\n\r\n    [NinjaScriptProperty]\r\n    [Range(1, int.MaxValue)]\r\n    [Display(Name=\"Smooth\", Description=\"Smoothing rate\", Order=2, GroupName=\"Parameters\")]\r\n    public int Smooth\r\n    { get; set; }\r\n\r\n    [Browsable(false)]\r\n    [XmlIgnore]\r\n    public Series<double> AboveZero\r\n    {\r\n        get { return Values[0]; }\r\n    }\r\n\r\n    [Browsable(false)]\r\n    [XmlIgnore]\r\n    public Series<double> BelowZero\r\n    {\r\n        get { return Values[1]; }\r\n    }\r\n    #endregion\r\n}\r\n\r\n```"
  },
  {
    "_id": "fef3e6c716dd0c8b595877b84cfca557a1c9229c52baf72d6b12639a4080edef",
    "_type": "desktopSdkDoc",
    "title": "Developing Indicators",
    "pathName": "developing_indicators",
    "parent": "educational_resources",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "Indicators are the building blocks of any automated trading system. NinjaScript allows you to develop custom indicators quickly. A few key points are:\n\n* Custom indicators are compiled and run natively within the NinjaTrader application, providing the highest performance possible\n* Indicator values are calculated at the current bar, which ensures that you do not accidentally include future data in your calculations\n* You can retain calculations between bar updates\n* You can retain and share calculation values between bar updates and across indicators\n\nCustom indicator development follows a logical progression.\n\n## Wizard\n\nThe wizard allows you to define your overall indicator parameters which include name, properties, inputs, plots and oscillator lines. The wizard will then generate the necessary NinjaScript code and open up the NinjaScript [Editor](ninjascript_editor_overview.md).\n\n## OnStateChange() Method\n\nThe [OnStateChange()](onstatechange) method is called once before any initial calculation triggered by an update bar event. This method is used to configure the indicators plots, lines and properties. The wizard will generate the required NinjaScript code for this method for most cases.\n\n## OnBarUpdate() Method\n\nThe [OnBarUpdate()](onbarupdate) method is called with either with each incoming tick or on the close of each bar, depending on how you deploy the indicator at run time. Your core indicator calculation logic is contained within this method.\n\n## Debug\n\nThe NinjaScript Editor will perform both syntax and semantic checks and list any errors at the bottom of the window. If there are logic problems with your indicator, they will be listed in the [Log tab](log_tab2) of the NinjaScript [Control Center](control_center) during run time. You can use the **Print()** method within your script to help debug your code. Output will be sent to the NinjaScript Output window.\n\n## Compilation\n\nOnce the coding effort is completed, you must then compile the indicator (several second process) directly from the NinjaScript Editor.\n\n## Usage\n\nThe completed indicator is now available through any window that can use an indicator, such as a [Chart](charts).\n\n## Tutorial Descriptions\n\nAll internal NinjaTrader indicators come with full source code and can be viewed within the NinjaScript Editor. Please review the tutorials within this section for detailed walk throughs of custom indicator development.\n\n{% table %}\n\n* Level\n* Description\n\n---\n\n* [Level 1](beginner_-_using_price_variabl) - Demonstrating the use of price variables\n* [Level 2](beginner_-_indicator_on_indica) - Demonstrating the use of indicator on indicator\n* [Level 3](intermediate_-_your_own_sma) - Demonstrating the use of a \"for\" loop to build a simple moving average indicator\n* [Level 4](intermediate_-_historical_cust) - Demonstrating the use of Indicator Series objects to retain historical custom calculations data series\n* [Level 5](advanced_-_custom_plot_colors_) - Demonstrating the use of custom plot coloring based on threshold values\n* [Level 6](docs/guides/Educational%20Resources/Developing%20Indicators/advanced_custom_drawing.md) - Demonstrating the use of custom of drawing using bar color, back color and line colors\n{% /table %}"
  },
  {
    "_id": "92eeda832f6e89d11ad2cb8e685f69c4d111b9dc4c64a2f8a3a0c09134dc173b",
    "_type": "desktopSdkDoc",
    "title": "Formatting numbers",
    "pathName": "formatting_numbers",
    "parent": "tips",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "## Formatting numbers\r\n\r\nString formatting on numbers is very useful for creating readable output. This can be done through the use of the number object's **ToString()** method.\r\n\r\nA common practice is printing out mathematical operations with the use of the **ToString()** method on the **double** object. What usually happens is the printing of a long string containing all the decimal places existing in the **double**. This sometimes makes output cluttered and hard to read. Luckily, C# has a robust set of string formatting options available to make the string more comprehendible.\r\n\r\nHere is a list of common formatting options available in the **ToString()** method:\r\n\r\n```csharp\r\ndouble c = 10.25693;\r\nPrint(\"No formatting: \" + c.ToString());\r\nPrint(\"Currency formatting: \" + c.ToString(\"C\"));\r\nPrint(\"Exponential formatting: \" + c.ToString(\"E\"));\r\nPrint(\"Fixed-point formatting: \" + c.ToString(\"F2\"));\r\nPrint(\"General formatting: \" + c.ToString(\"G\"));\r\nPrint(\"Percent formatting: \" + c.ToString(\"P0\"));\r\nPrint(\"Formatted to 2 decimal places: \" + c.ToString(\"N2\"));\r\nPrint(\"Formatted to 3 decimal places: \" + c.ToString(\"N3\"));\r\nPrint(\"Formatted to 4 decimal places: \" + c.ToString(\"N4\"));\r\n```\r\n\r\nThe corresponding output is as follows:\r\n\r\n{% table %}\r\n\r\n* Output\r\n\r\n---\r\n\r\n* No formatting: 10.25693\r\n* Currency formatting: $10.26\r\n* Exponential formatting: 1.025693E+001\r\n* Fixed-point formatting: 10.26\r\n* General formatting: 10.25693\r\n* Percent formatting: 1,026 %\r\n* Formatted to 2 decimal places: 10.26\r\n* Formatted to 3 decimal places: 10.257\r\n* Formatted to 4 decimal places: 10.2569\r\n{% /table %}\r\n\r\nFor custom formatting you can use the following:\r\n\r\n```csharp\r\n\r\ndouble phoneNumber = 9165551022;\r\nPrint(\"Phone number: \" + phoneNumber.ToString(\"(###) ### - ####\"));\r\n```\r\n\r\nCorresponding output:\r\n\r\n{% table %}\r\n\r\n* Phone number\r\n\r\n---\r\n\r\n* Phone number: (916) 555 - 1022\r\n{% /table %}\r\n\r\nFor more information on general string formatting the Microsoft documentation may be of use. Many other resources can be found online through a Google search as well."
  },
  {
    "_id": "786426b27007b3bb326871a6e1c05f1523d51bd6beff8fd2bb907ab798f0a4f3",
    "_type": "desktopSdkDoc",
    "title": "Make sure you have enough bars in the data series you are accessing",
    "pathName": "make_sure_you_have_enough_bars",
    "parent": "tips",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "A common programming error is not checking to ensure there are enough bars contained in the data series you are accessing. This will explain some of the concepts to check for this situation.\r\n\r\nFor example:\r\n\r\n```csharp\r\n\r\nprotected override void OnBarUpdate()\r\n{\r\n    if (Close[0] > Close[1])\r\n        // Do something\r\n}\r\n\r\nIn the code snippet above, the **OnBarUpdate()** method is called for each bar contained in your data series.\r\n\r\nOn the very first bar (think of the 1st bar on the chart from left to right) the value of \"close of 1 bar ago\" (**Close**[1]) does not yet exist and your indicator/strategy will not work and throw an exception to the Control Center Log tab \"Index was out of range...\".\r\n\r\nFollowing are two ways to resolve this:\r\n\r\n```csharp\r\n\r\nprotected override void OnBarUpdate()\r\n{\r\n  if (CurrentBar < 1)\r\n    return;\r\n  if (Close[0] > Close[1])\r\n        // Do something\r\n}\r\n\r\nThe resolution above is to check how many bars we have seen (**CurrentBar**) and to exit the **OnBarUpdate()** method if an insufficient number of bars has been seen.\r\n\r\n```csharp\r\n\r\nprotected override void OnBarUpdate()\r\n{\r\n    if (Close[0] > Close[Math.Min(CurrentBar, 1)])\r\n        // Do something\r\n}\r\n\r\n\r\nThe resolution above substitutes the minimum value between the current bar being processed and the desired number of bars ago value, in this case 1.\r\n\r\n```csharp\r\n\r\n---\r\n\r\nprotected override void OnStateChange()\r\n{\r\n  if (State == State.SetDefaults)\r\n    {\r\n        Name = \"Multi-Time Frame & Instruments Example\";\r\n    }\r\n    else if (State == State.Configure)\r\n    {\r\n        // Adds a secondary bar object to the script.\r\n        AddDataSeries(BarsPeriodType.Minute, 5);\r\n\r\n        // Adds an additional bar object to the script.\r\n        AddDataSeries(BarsPeriodType.Minute, 5);\r\n    }\r\n}\r\n\r\nprotected override void OnBarUpdate()\r\n{\r\n    // Checks to ensure all Bars objects contain enough bars before beginning\r\n    // If this is a strategy, use **BarsRequiredToTrade** instead of **BarsRequiredToPlot**\r\n    if (CurrentBars[0] <= BarsRequiredToPlot || CurrentBars[1] <= BarsRequiredToPlot || CurrentBars[2] <= BarsRequiredToPlot)\r\n        return;\r\n}\r\n```\r\n\r\nThe resolution above would be used in a [Multi Time Frame](multi-time_frame__instruments) script. Since **OnBarUpdate()** processes multiple data series, we need to make sure each Data Series we reference has processed enough bars."
  },
  {
    "_id": "3e2944174f2b8a99ae1c756c654a8900457cf9448bb62f4969b6e46950731b06",
    "_type": "desktopSdkDoc",
    "title": "Referencing the correct bar",
    "pathName": "referencing_the_correct_bar",
    "parent": "tips",
    "order": 0,
    "status": "updated",
    "section": "guides",
    "markdown": "When coding an indicator or strategy it is important to be able to access the intended bars for correct calculations. In **NinjaScript** we are able to access the bars we want through proper use of the bar's indexing.\r\n\r\nThe bar's indexing is setup in a reverse chronological order. This means \"0\" refers to the most recent bar, \"1\" refers to the previous bar, \"2\" refers to the bar before that one, etc.\r\n\r\nFor example, if we wanted to subtract the high and low of 10 bars ago from each other we would do this:\r\n\r\n```csharp\r\ndouble value = High[10] - Low[10];\r\n```\r\n\r\nNow that we know how the indexing works there are several properties and methods at our disposal that can help us access important keystone bars. The more important ones are [CurrentBar](currentbar) and [BarsSinceNewTradingDay](barssincenewtradingday).\r\n\r\n## CurrentBar\r\n\r\nCurrentBar returns an int representing the number of bars existing on the chart. This property is most useful when you want to run calculations from the very beginning of the chart.\r\n\r\nFor example, if you wanted to find the average high value of the first 10 bars on the chart you could do this:\r\n\r\n```csharp\r\ndouble highValue = 0;\r\nint x = CurrentBar;\r\nwhile (x > CurrentBar - 10)\r\n{\r\n    highValue += High[x];\r\n    x--;\r\n}\r\nPrint(\"The average high value: \" + highValue/10)\r\n```\r\n\r\n{% callout type=\"note\" %}\r\nA common mistake in using CurrentBar is using it in the index to access the most recent bar. In this situation, instead of doing something like Close[CurrentBar] you will want to do Close[0].\r\n{% /callout %}\r\n\r\n## BarsSinceNewTradingDay\r\n\r\nBarsSinceNewTradingDay is another property that can help you find the first bar of the current trading day. The difference between BarsSinceNewTradingDay and CurrentBar is that BarsSinceNewTradingDay resets its count whenever a new session begins. This means if you use it in an index it will only get you to the beginning of the current session and not any previous sessions.\r\n\r\nFor example, if you wanted to find the open of the current session you could do this:\r\n\r\n```csharp\r\ndouble openValue = Open[Bars.BarsSinceNewTradingDay];\r\n```\r\n\r\nThe example used in the discussion about CurrentBar can also be done with Bars.BarsSinceNewTradingDay if you wanted to calculate values based on the current session instead of the start of the chart too.\r\n\r\n{% callout type=\"note\" %}\r\nIf you wish to access values older than 256 bars ago you will need to ensure the [MaximumBarsLookBack](maximumbarslookback) is set to .Infinite.\r\n{% callout type=\"note\" %}\r\n\r\n## Other Properties and Methods\r\n\r\nThere are also a number of other properties and methods that can be useful in helping you locate the correct bars index to reference. Please take a look at these in the help guide:\r\n\r\n* [BarsSinceEntryExecution()](barssinceentryexecution)\r\n* [BarsSinceExitExecution()](barssinceexitexecution)\r\n* [GetBar()](getbar)\r\n* [GetDayBar()](getdaybar)\r\n* [HighestBar()](highestbar)\r\n* [LowestBar()](lowestbar)\r\n* [LRO()](least_recent_occurence_lro)\r\n* [MRO()](most_recent_occurence_mro)"
  },
  {
    "_id": "887b76d904b47e98a49fe7f42449dfc0b26b4cc6ab959f67ac9fd5ec86b58c48",
    "_type": "desktopSdkDoc",
    "title": "NinjaScript Best Practices",
    "pathName": "ninjascript_best_practices",
    "parent": "ninjascript",
    "order": 2,
    "status": "updated",
    "section": "guides",
    "markdown": "There are some best practices to be aware of when developing **NinjaScript** classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.\n\n{% callout type=\"note\" %}\n\n* NinjaTrader is multi-threaded and event driven. Always assume that any of the methods you implement in NinjaScript could be called from another thread.\n{% /callout %}\n\n## State management practices\n\n{% table %}\n\n* Managing Resources\n* Setting Default UI Property Grid values\n\n---\n\n* The **OnStateChange()** method is called anytime there has been a change of **State** and can be used to help you setup, manage, and destroy several types of resources. Where these values are setup is highly dependent on the kind of resource you are using. The section below will cover how to manage various resources throughout different states.\n* Reserve **State.SetDefaults** for defaulting any public properties you wish to have exposed on the UI property grid. You should also use this **State** for setting default desired **NinjaScript** property behavior which can be overridden from the property grid (e.g. **Calculate**, **IsOverlay**, etc.). For Plots and Lines you wish to configure, **AddPlot()**, **AddLine()** should also have their default values set during this **State**.\n{% /table %}\n\n{% table %}\n\n* Why\n\n---\n\n* Public values of the **NinjaScript** object in **SetDefaults** are pushed to the UI property grid for an opportunity to change settings of your object.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   // these are the values that show up as default on the UI\n   if (State == State.SetDefaults)\n   {\n     Calculate = Calculate.OnPriceChange;\n     IsOverlay = false;\n\n     Period = 50;\n\n     AddPlot(Brushes.Blue, \"Plot Value\");\n     AddLine(Brushes.Gray, 100, \"Threshold\");\n   }\n\n```\n\nFor public properties you do NOT wish exposed to the UI property grid, set the **Browsable** attribute to false:\n\n```csharp Best practice\n[Browsable(false)] // prevents from showing up on the UI property grid\npublic int Communicator { get; set; \n```\n\nOn indicators, properties you wish to set from other objects, set the **NinjaScriptPropertyAttribute**:\n\n```csharp Best practice\n[NinjaScriptProperty] // can now call **MyIndicator**(20) from another object\npublic int Period { get; set; }\n```\n\nThe default behavior is to serialize any public properties and fields to a Workspace or Template file when saving. However, not all objects can be serialized - or you may wish to exclude a property from being saved and restored. For these scenarios, set the **XmlIgnore** attribute to the property:\n\n```csharp Best practice\n[XmlIgnore] // removes from serialization\npublic Brush DownBrush\n{ get; set; }\n```\n\nAs a best practice as well, your **NinjaScript** should not have any public fields, since those would get serialized as well - which means their state would be persisted, which in turn could lead to unexpected outcomes.\n\n{% callout type=\"note\" %}\n\n* See the [Working with Brushes](working_with_brushes) section of the Help Guide for information on properly serializing brushes.\n\n{% /callout %}\n\nCalculating run-time object values\n\nDo not attempt to do advanced calculations or try to access object references in **State.SetDefaults**. This **State** should be kept as lean as possible, and any calculation logic should be delayed until at least **State.Configure**.\n\n{% table %}\n\n* Why\n\n---\n\n* Your object will be called in situations you may not be expecting. You can read more about this subject on [Understanding the life cycle of your NinjaScript objects](understanding_the_lifecycle_of).\n{% /table %}\n\n```csharp Practice to avoid\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n       // logic could take longer than desired as the list of indicator names is populated\n       for (int i = 0; i <= array.length; i++)\n           DoWork(i);\n\n       // possible null reference exception since **TickSize** is not set yet\n       Period = 5 * TickSize;\n   }\n```\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   // Complex operations should be delayed to >= State.Configure\n   if (State == State.Configure)\n   {\n       for (int i = 0; i <= array.length; i++)\n           DoWork(i);\n   }\n\n   // information related to market data is not available until at least State.DataLoaded\n   else if (State == State.DataLoaded)\n   {\n       Period = 5 * TickSize;\n   }\n}\n```\n\nSetting class level variables\n\nDo not set variables at the class level unless they are constant. You should delay setting or resetting variables until the **State** has reached **State.Configure**. You can use **const** keyword to differentiate values which do not change from variables which do change.\n\n{% table %}\n\n* Why\n\n---\n\n* Waiting to set up and define resources until the object has been configured ensures that values not set up and declared prematurely.\n{% /table %}\n\n```csharp Best practice\n// value is always 5, it can be made constant and declared at the class level\nprivate const int multiplier = 5;\n\n// these values can change, may be better to delay setting until State.Configure\nprivate int counter;\nprivate List<int> myList;\n\nprotected override void OnStateChange()\n{\n   if (State == State.Configure)\n   {\n       counter = 0;\n       myList = new List<int>();\n   }  \n```\n\nResetting class level variables for Strategy Analyzer Optimization\n\nTo take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.\n\n{% table %}\n\n* Why\n\n---\n\n* When optimizing a strategy, instances may or may not be recycled depending on the strategy **IsInstantiatedOnEachOptimizationIteration** setting.\n{% /table %}\n\n```csharp Best practice\n// examples of fields which need to be reset\nprivate double myDouble;\nprivate bool myBool;\nprivate DateTime myDateTime;\nprivate Order myOrderObject;\nprivate Brush myBrushObject;\nprivate Array myIntArray;\nprivate List<object> myList;\nprivate SMA mySMAIndicator;\nprivate Series<double> mySeries;\n\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n       // disabled to take advantage of performance gains\n       // However any strategy state that would be mutable after State.SetDefaults needed to be reset for the next run.\n       IsInstantiatedOnEachOptimizationIteration = false;\n   }\n   else if (State == State.Configure)\n   {\n       // Since these values are not dependent on bars, they can be reset as early as State.Configure\n       myDouble = double.MinValue;\n       myBool = false;\n       myDateTime = DateTime.MinValue;\n       myOrderObject = null;\n       myBrushObject = null;\n\n       if (myIntArray != null)\n           Array.Clear(myIntArray, 0, myIntArray.Length);\n       else\n           myIntArray = new int[20];\n\n       if (myList != null)\n           myList.Clear();\n       else\n           myList = new List<object>();\n   }\n\n   else if (State == State.DataLoaded)\n   {\n       // Since these values do are dependent on bars, they should only reset during State.DataLoaded\n       mySMAIndicator = SMA(14);\n       mySeries = new Series<double>(this);\n   }\n\n```\n\nAccessing properties related to market data\n\nDo not attempt to access objects related to instrument market data until the **State** has reached **State.DataLoaded**.\n\n{% table %}\n\n* Why\n\n---\n\n* Waiting to access objects that depend on market data until **DataLoaded** prevents access errors in all scenarios.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   if (State == State.DataLoaded)\n   {\n       // these objects and their related members are not available until State.DataLoaded\n       Print(Bars.Count);\n       Print(Instrument.FullName);\n       Print(BarsPeriod.BarsPeriodType);\n       Print(TradingHours.TimeZon;\n       Print(Input);\n   }\n}\n```\n\n{% table %}\n\n* Note\n\n---\n\n* All additional data series must be added in **State.Configure** (this includes series that any hosted script potentially needs as well - [more info](http://ninjatrader.com/support/helpGuides/nt8/en-us/adddataseries.htm)). Since objects such as **Instrument**, **BarsPeriod**, **TradingHours**, etc. are NOT guaranteed to be available until **State.DataLoaded**, you cannot reliably use the primary instrument properties as arguments in **AddDataSeries()**. Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided. In some cases, you may be able to use a **BarsRequest()** to obtain market data for other instruments and intervals.\n{% /table %}\n\nSetting up resources that rely on market data\n\nFor objects which depend on market data, delay their construction until the **State** has reached **State.DataLoaded**.\n\n{% table %}\n\n* Why\n\n---\n\n* Waiting to construct objects that depend on market data until **DataLoaded** ensures that their underlying input contains significant values in all scenarios.\n{% /table %}\n\n```csharp Best practice\n// these resources depend on bars, wait until State.DataLoaded to instantiated\nprivate EMA myEMA;\nprivate Series<double> mySeries;\nprivate SessionIterator mySessionIterator;\n\nprotected override void OnStateChange()\n{  \n   if (State == State.DataLoaded)\n   {\n       myEMA = EMA(20);\n       mySeries = new Series<double>(this);\n       mySessionIterator = new SessionIterator(Bars);\n   }\n\n```\n\nAccessing element on the UI\n\nFor objects which exist on the UI (e.g., **ChartControl**, **ChartPanel**, **ChartBars**, **NTWindow**, etc.) wait until the **State** has reached **State.Historical**. This practice is correct for both reading properties or should you wish to add custom elements to the existing UI.\n\n{% table %}\n\n* Why\n\n---\n\n* **NinjaTrader** UI related objects are not guaranteed to be available until historical data processing has started.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   // wait until at least State.Historical\n   if (State == State.Historical)\n   {\n       // and double check UI object is not null before accessing\n       if (ChartControl != null)\n       {\n           Print(ChartControl.Properties.ChartBackground);\n       }\n   }\n}\n```\n\nTransitioning order references from historical to real-time\n\nWhen dealing with strategy based orders which have transitioned from historical to real-time, you will need to ensure that locally stored order references are also updated.\n\n{% table %}\n\n* Why\n\n---\n\n* As the core order object updates, **NinjaTrader** has no specific way to update your locally stored order references. You can read more about this subject on the Advanced Order Handling topic: [Transitioning order references from historical to live](advanced_order_handling).\n{% /table %}\n\n```csharp Best practice\nprivate Order entryOrder = null;\n\nprotected override void OnBarUpdate()\n{\n   if (entryOrder == null && Close[0] > Open[0])\n       entryOrder = EnterLongLimit(\"myEntryOrder\", Low[0]);\n}\n\nprotected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string nativeError)\n{\n   // One time only, as we transition from historical\n   // Convert any old historical order object references to the live order submitted to the real-time account\n   if (entryOrder != null && entryOrder.IsBacktestOrder && State == State.Realtime)\n       entryOrder = GetRealtimeOrder(entryOrder);\n\n   // Null entryOrder if filled or cancelled. We do not use the Order objects after the order is filled, so we can null it here\n   if (entryOrder != null && entryOrder == order)\n   {\n       if (order.OrderState == OrderState.Cancelled && order.Filled == 0)\n           entryOrder = null;\n       if (order.OrderState == OrderState.Filled)\n           entryOrder = null;\n   }\n\n```\n\nTerminating custom resources\n\nUse a flag to track when resources have been set up properly before attempting to destroy them.\n\n{% table %}\n\n* Why\n\n---\n\n* Checking that an object has been configured ensures that values not destroyed prematurely. You can read more about this subject on [Understanding the life cycle of your NinjaScript objects](understanding_the_lifecycle_of).\n{% /table %}\n\n```csharp Best practice\n\n---\n\nprotected override void OnStateChange()\n{\n   if (State == State.Configure)\n   {\n       myObject = new object();\n       // set a flag to indicator object has been configured\n       configured = true;\n   }\n\n   else if (State == State.Terminated)\n   {\n       // only dispose of object if it has been configured\n       if (configured)\n       {\n           myObject.Dispose();\n       }\n   }\n}\n```\n\n## Error handling practices\n\n{% table %}\n\n* Safely accessing reference objects\n\n---\n\n* Although there are documented States where objects are available, the implementation could change. If you are accessing a reference object, please do so by first checking that the object is not null.\n{% /table %}\n\n```csharp Best practice\n\n// checking to ensure chart control is available in all situations\n// will help to ensure this logic below does not generate errors at a later time\nif(ChartControl != null)\n{\n   myBackgroundBrush = ChartControl.Properties.ChartBackground;\n}\n```\n\nAccessing objects which terminate\n\nTo protect against race conditions and access errors, you should temporarily check for reference errors any time you attempt to do something with an object.\n\n{% table %}\n\n* Why\n\n---\n\n* **OnStateChange()** runs asynchronous to other **NinjaScript** events. You can run into scenarios where you **State.Terminated** logic is called in the middle of **OnBarUpdate()**, **OnRender()** etc.\n{% /table %}\n\n```csharp Best practice\n\nprotected override void OnStateChange()\n{\n   // this logic runs asynchronously to other events\n   if (State == State.Terminated)\n   {\n       myObject = null;\n   }\n}\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (myObject == null)\n       return;\n\n   // for safety, always check for null references before attempting to access an object\n   // even if you have once checked for null references earlier run-time\n   if (myObject != null)\n       myObject.DoSomething();\n}\n```\n\nProving instructions for non-ninjascript properties\n\nDo not attempt to modify existing UI \"Properties\" to meet your specific needs. These features are exposed to allow you to read the environment state and make decisions to alter how your code executes, but should not be relied on to modify settings on behalf of the user. While these objects from these classes have setters for technical reasons, you should not attempt to amend the values through code. Instead, you should issue warnings or log errors instructing users to modify settings when required:\n\n{% table %}\n\n* Why\n\n---\n\n* **NinjaTrader** makes no guarantee that the requested changes will take effect, and user settings always take precedences. This includes the user defined **ChartControl.Properties**, **ChartBars.Properties**, and **ChartPanel.Properties**. Furthermore, two different user scripts could be installed which also attempt to modify properties you are relying which could introduce conflicts.\n{% /table %}\n\n```csharp Best practice\nif (State == State.Historical)\n{\n   if (ChartControl.Properties.EquidistantBarSpacing == true)\n   {\n       Draw.TextFixed(this, \"error\", \"This indicator works best with Equidistant BarSpacing set to false.\", TextPosition.BottomRight);\n   }\n}\n```\n\nModifying UI elements and multi-threading\n\nWhen interacting with UI objects, such as obtaining UI information, or modifying the existing layout, always use the **NinjaScript**'s **Dispatcher** asynchronously.\n\n{% table %}\n\n* Critical\n\n---\n\n* Improper thread handling from a **NinjaScript** object is a common cause of application deadlocks. Please be sure to read more information on [Multi-Threading Consideration for NinjaScript](multi-threading).\n{% /table %}\n\n```csharp Best practice\n// using a Dispatcher will ensure that the corresponding action executes on the associated thread\nthis.Dispatcher.InvokeAsync(() =>\n{\n   UserControlCollection.Add(new System.Windows.Controls.TextBlock\n   {\n       Text = \"\\nAdded by the ChartControl Dispatcher.\"\n   });\n});\n```\n\nProperly implementing try/catch blocks\n\nUnless you are specifically debugging a method, the use of a try-catch block should be scoped to a particular area of logic. Do NOT try to handle all of your execution logic under one giant try-catch block.\n\n{% table %}\n\n* Why\n\n---\n\n* Larger try-catch blocks can not only be harder to debug, but can introduce performance issues at run-time.\n{% /table %}\n\n```csharp Practice to avoid\nprotected override void OnBarUpdate()\n{\n   try\n   {\n       // encapsulates entire OnBarUpdate logic\n   }\n   catch (Exception ex)\n   {\n       // attempt to handle all errors in one catch\n   }\n}\n```\n\nUsing WPF brushes\n\nTry to use a static predefined **Brush** if possible. If you need to customize a new brush object, make sure to **.Freeze()** the brush before using it.\n\n{% table %}\n\n* Why\n\n---\n\n* The pre-defined brushes are thread safe and do not require any special handling. Custom defined brushes, on the other hand, are NOT thread-safe and must be frozen otherwise cross-thread exceptions can occur.\n{% /table %}\n\n```csharp Best practice\n// predefined brush\nBackBrush = Brushes.Blue;\n\n// if you are using a custom brush to e.g., modify the opacity\nSolidColorBrush opaqueBlue = new SolidColorBrush(Colors.Blue) {Opacity = .25f};\n\n// or just using at custom color not available in pre-defined brushes class\nSolidColorBrush coolGreen = new SolidColorBrush(Color.FromRgb(30, 255, 128));\n\n// you must freeze these brushes after they are constructed!\nopaqueBlue.Freeze();\ncoolGreen.Freeze();\n```\n\nbarsAgo indexer vs. absolute bar Index\nAs you probably know, you can quickly look up the bar value on the chart by calling a PriceSeries<`t`> barsAgo indexer, e.g., Close[0].\nHowever, the internal indexer and pointers about the barsAgo value are only guaranteed to be correctly synced and updated during a market data event. As a result, you should favor using the absolute GetValueAt() methods during events which are not driven by price.\n\n{% table %}\n\n* Why\n\n---\n\n* Attempting to call the barsAgo indexer in an event method that is not driven by market data can yield unexpected results.\n{% /table %}\n\n```csharp Best practice\n// OnRender is not a market data event; barsAgo pointers are not guaranteed to be in sync\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   Print(mySMA.GetValueAt(CurrentBar));\n}\n\n// same is true for you custom events\nprivate void myCustomClickHandler(object sender, MouseButtonEventArgs e)\n{\n   Print(Close.GetValueAt(CurrentBar));\n}\n```\n\n{% table %}\n\n* Tip\n\n---\n\n* If you have programming requirements which rely on a **PriceSeries** indexer, you can use the **TriggerCustomEvent()** delegate which will update the internal pointers and indexes before executing the logic you specify.\n{% /table %}\n\nCasting safely\n\nAvoid type casting and type conversion as much as possible. Casting from a mixed collection of types is also prone to exceptions especially in situations that may not occur when you originally test your code.\n\n{% table %}\n\n* Why\n\n---\n\n* The practice to avoid code below could work in some scenarios but would generate errors if other types were added to that collection that you were not anticipating.\n{% /table %}\n\n```csharp Practice to avoid\n// This would run without errors if there were ONLY type HorizontalLine on the chart\n// But you risk a likely 'System.InvalidCastException' when other draw types are in that collection\nforeach (HorizontalLine hLine in DrawObjects)\n{\n\n```\n\nIf you must cast, do so safely and avoid implicit casts to types which may not be guaranteed to succeeded.\n\n```csharp Best practice\n\n---\n\n// Use the base IDrawingTool type and then cast to the desired type within the for loop\nforeach (IDrawingTool hLine in DrawObjects)\n{\n   // Note: to prevent further errors, your type casting should be done using the \"as\" keyword\n   // Opposed to a direct cast:\n   // HorizontalLine myLine = (HorizontalLine) hLine;\n\n   HorizontalLine myLine = hLine as HorizontalLine;\n\n   // This will allow you to ensure the cast actually occurred\n   if (myLine != null)\n   {\n       Print(myLine.StartAnchor.Price);\n   }\n\n```\n\n## Performance practices\n\n{% table %}\n\n* Referencing indicator methods\n\n---\n\n* In general, when calling an Indicator return method, there is some internal caching which occurs by design to help reduce memory consumption.\n{% /table %}\n\n{% table %}\n\n* Why\n\n---\n\n* While the designed indicator caching improves general memory performance, there is an implied cost of actually looking up the cached indicator.\n{% /table %}\n\n```csharp Practice to avoid\n// each time you call the SMA() return method there is a small performance cost\n// implied from the time it takes to look up the cached instance\nif (Close[0] > SMA[20](0))\n{\n   Print(SMA[20](0));\n   EnterLongLimit(SMA[20](0));\n   Draw.Dot(this, Time[0].ToString(), false, 0, SMA[20](0), Brushes.DarkGreen);\n```\n\n{% table %}\n\n* Note\n\n---\n\n* Indicator caching ONLY occurs when an indicator is recalled with the same EXACT parameters and input from the SAME calling script. (i.e. when a previously called indicator is called a second time with new parameters in the same script, a second instance will be created / cached).\n{% /table %}\n\nIf you are reusing an indicator several times through your code (especially indicators with many parameters), you can take further steps to refine performance by storing a reference to the indicator instance yourself (although it is by no means a requirement, and this suggestion does not need to be followed strictly).\n\n```csharp Best practice\n\nprivate SMA mySma;\n\nprotected override void OnStateChange()\n{\n   // when the indicator begins processing\n   // save an instance of the SMA indicator with the desired input\n   if (State == State.Historical)\n   {\n       mySma = SMA(20);\n   }\n}\n\nprotected override void OnBarUpdate()\n{\n   // use the referenced mySMA throughout the lifetime of the script\n   if (Close[0] > mySma[0])\n   {\n       Print(mySma[0]);\n       EnterLongLimit(mySma[0]);\n       Draw.Dot(this, Time[0].ToString(), false, 0, mySma[0], Brushes.DarkGreen);\n   }\n\n```\n\nMarking object references for garbage collection\n\nWhile it is not always necessary to set objects to null, doing so will mark them for garbage collection sooner and help prevent unnecessary memory resources from being utilized.\n\n{% table %}\n\n* Why\n\n---\n\n* In general you should be diligent to set stored memory objects to null when you are done using them, especially in situations where a **NinjaScript** object may be running for an extended period.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnBarUpdate()\n{\n   // saving \"myDot\" creates an additional reference in memory\n   Dot myDot = Draw.Dot(this, \"myDot\" + CurrentBar, false, Time[0], Close[0], Brushes.Blue);\n\n   if (conditionToRemove)\n   {\n       // remove draw object will remove the object from the chart\n       RemoveDrawObject(\"myDot\");\n\n       // but your local object \"myDot\" is still stored in memory.\n       // Explicitly setting to null will ensure object is marked for garbage collection\n       myDot = null;\n   }\n}\n```\n\n{% table %}\n\n* Note\n\n---\n\n* The example above demonstrates using a draw object, but the practice can be extended to any object you store in memory (e.g., orders, brushes, custom objects, etc).\n{% /table %}\n\nDisposing of custom resources\n\nDispose of objects that inherit from **IDisposable** or put into a Using statement.\n\n{% table %}\n\n* Why\n\n---\n\n* **NinjaTrader** is not guaranteed to dispose of objects for you. To avoid unnecessary memory consumption, always manage your resources by creating a variable and dispose of the object.\n{% /table %}\n\n```csharp Best practice\n// example of object instantiated which need to be disposed\nStreamWriter writer = new StreamWriter(\"some_file.txt\");\n\n// use the object\nwriter.WriteLine(\"Some text\");\n\n// implements IDisposbile, make sure to call .Dispose() when finished\nwriter.Dispose();\n\n// or put in \"using\" statement which implicitly calls .Dispose() when finished\nusing (StreamWriter writer2 = new StreamWriter(\"some_file.txt\"))\n{\n   writer2.WriteLine(\"Some text\");\n}\n```\n\n{% table %}\n\n* Tip\n\n---\n\n* This is most commonly applicable when using **SharpDX** resources for custom rendering. Please be sure to review the information on [Best Practices for SharpDX Resources](using_sharpdx_for_custom_chart_rendering#bestpracticesforsharpdxresources).\n{% /table %}\n\nAvoiding duplicate calculations\n\nBe mindful where and when your potentially complex calculations would be recalculated and thus run the risk of being calculated redundantly. For example, you may have logic which only needs to calculate, e.g., once per instance, once per session, once per bar, etc.\n\n```csharp Best practice\n\n// get GetPreviousTradingDayEnd() is expensive to look up\n// but value only needs to be looked up once a day -> only calculate on first bar of session\nif (Bar.IsFirstBarOfSession)\n{\n   TradingHours.GetPreviousTradingDayEnd(Time[0]);\n}\n```\n\nThe same considerations would apply to variables or function calls that would not change their output value for the currently processed bar on **Calculate.OnEachTick** or **.OnPriceChange**, thus there would be no need handling them outside of **IsFirstTickOfBar**.\n\n```csharp Best practice\n// dedicated logic to cache the prior sum on each tick of bar\n// While it is a good practice, this can cause problems for bar types which may remove last bar (see below)\nif (IsFirstTickOfBar)\n   priorSum = sum;\n\nsum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);\nValue[0] = sum / (CurrentBar < Period ? CurrentBar + 1 : Period);\n```\n\nCaching values on bars which remove last bar\n\nBuilding on the previous example, be careful when caching values on the first tick of bar if using bars types which are **IsRemoveLastBarSupported**. To see how to handle these situations best, take a look at the default **SMA** indicator which has an additional logic branch which disables caching on those bar types:\n\n```csharp Best practice\n // logic below disables first tick of bar caching only on bar types which remove last bar\nif (BarsArray[0].BarsType.IsRemoveLastBarSupported)\n{\n   if (CurrentBar == 0)\n       Value[0] = Input[0];\n   else\n   {\n       double last = Value[1] * Math.Min(CurrentBar, Period);\n\n       if (CurrentBar >= Period)\n           Value[0] = (last + Input[0] - Input[Period]) / Math.Min(CurrentBar, Period);\n       else\n           Value[0] = ((last + Input[0]) / (Math.Min(CurrentBar, Period) + 1));\n   }\n\n```\n\nPrecomputing values instead of calculating in **OnRender()**\n\nTo preserve good performance, always err on the side of caution if you are using **OnRender** for any calculation logic.\n\n{% table %}\n\n* Why\n\n---\n\n* **OnRender()** is called frequently as you interact with the Chart, which can cause calculations to occur much more often than the related market data events and can cause unnecessary spikes in CPU consumption.\n{% /table %}\n\n```csharp Practice to avoid\n\n---\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // continually recalling the same value methods is unnecessary in this situation\n   double myValue = Bars.GetClose(CurrentBar) + Bars.GetOpen(CurrentBar);\n\n   // render myValue\n}\n```\n\n```csharp Best practice\n\n---\n\nprivate double myValue;\n\nprotected override void OnBarUpdate()\n{\n   // myValue only needs to update when OnBarUpdate() is called\n   // and then can be passed to OnRender() for chart rendering purposes\n   myValue = Close[0] + Open[0];\n}\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // if needed, you can always check that myValue has actually been set\n   if (myValue > double.MinValue)\n   {\n       // render myValue\n   }\n\n```\n\nRestricting **OnRender()** calculations to visible **ChartBars**\n\nUse the **ChartBars.FromIndex** and **ChartBars.ToIndex** to limit calculations to only what is visible on the chart.\n\n{% table %}\n\n* Why\n\n---\n\n* Rendering should be reserved for rendering on what is visible on the Chart. Performing calculations on bar index which are not visible can cause random spikes in CPU consumption.\n{% /table %}\n\n```csharp Best practice\n\n---\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // restricting this loop to only the ChartBars.From/ToIndex limits the loop to only what is visible on the chart\n   for (int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n   {\n       Print(ChartControl.GetSlotIndexByX(barIndex));\n   }\n}\n```\n\nUsing **DrawObjects** vs custom graphics in **OnRender()**\n\nWhen using **Draw methods**, a new instance of the **Draw** object is created including its custom rendering and calculation logic. These methods are convenient in many situations, but can quickly introduce performance issues if used too liberally. In some situations, you may see better performance for rendering via **SharpDX** in **OnRender()**.\n\n{% table %}\n\n* Why\n\n---\n\n* Each draw object instance will see its own **OnRender()** called to render values. If you instead implement custom rendering in the your object, you would only see a single **OnRender()** call for your custom created graphics.\n{% /table %}\n\n```csharp Practice to avoid\nprotected override void OnBarUpdate()\n{\n   // this would draw a dot on every bar on the chart\n   // each instance would need to call its own OnRender() method\n   // not a very efficient use a draw method\n   Draw.Dot(this, \"everyDot\" + CurrentBar, false, 0, Close[0], Brushes.Blue);\n}   \n\n```\n\nWith just a little extra code (much less than what is in the **Draw methods**) custom **SharpDX** rendering greatly reduces CPU and Memory consumption. Please ensure a **Direct2D1** factory would only be instantiated from **OnRender()** or **OnRenderTargetChanged()** (which run in the UI thread), as access from other threads outside those methods could cause a degradation in performance.\n\n```csharp Best practice\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // achieves the same effect of drawing a dot on every bar\n   // but only needs to call your object's OnRender()\n   for (int index = ChartBars.FromIndex; index <= ChartBars.ToIndex; index++)\n   {\n       float price = chartScale.GetYByValue(Close.GetValueAt(index));\n       float bar = chartControl.GetXByBarIndex(ChartBars, index);\n       float radius = (float) chartControl.BarWidth;\n\n       SharpDX.Direct2D1.Ellipse dot = new SharpDX.Direct2D1.Ellipse(new SharpDX.Vector2(bar, price), radius, radius);\n\n       using (SharpDX.Direct2D1.SolidColorBrush brush = new SharpDX.Direct2D1.SolidColorBrush(RenderTarget, SharpDX.Color.Blue))\n       {\n           RenderTarget.FillEllipse(dot, brush);\n       }\n   }\n}\n```\n\n{% table %}\n\n* Tip\n\n---\n\n* One of the advantages of using a **Draw.Method** is the returned **Draw** Objects contains metadata which could be used later (such as for obtain the bar index or price value of the dot later on). If you would use this metadata later on, using a **Draw method** would be in your best interests. However, if you are solely looking to render figures on a chart, favoring your custom **SharpDX** methods can drastically improve performance.\n{% /table %}\n\nResponding to user events\n\nDo NOT use **OnRender()** for purposes other than rendering. If you need events to hook into user interactions, consider adding your own event handler. The example below shows registering the **ChartPanel** **MouseDown** event and registering a custom WPF control.\n\n{% table %}\n\n* Why\n\n---\n\n* **OnRender()** may call more or less frequently than you anticipated. Using your own custom event handlers allows you control and isolate user event logic you are looking to capture.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   if (State == State.Historical)\n   {\n       // subscribe to chart panel mouse down event\n       if (ChartPanel != null) ChartPanel.MouseDown += DoUserClickedChartPanelEvent;\n\n       // subscribe to a custom UI element mouse down event\n       if (myWPFControl != null) myWPFControl.MouseDown += DoCustomWPFControlClickEvent;\n   }\n\n   else if (State == State.Terminated)\n   {\n       // remember to unsubscribe when finished\n       if (ChartPanel != null) ChartPanel.MouseDown -= DoUserClickedChartPanelEvent;\n       if (myWPFControl != null) myWPFControl.MouseDown -= DoCustomWPFControlClickEvent;\n   }\n}\n\nprivate void DoUserClickedChartPanelEvent(object sender, MouseButtonEventArgs e)\n{  \n   Print(\"User clicked on the ChartPanel, executing custom mouse down logic...\");\n}\n\nprivate void DoCustomWPFControlClickEvent(object sender, MouseButtonEventArgs e)\n{\n   Print(\"User clicked on my button, executing button logic...\");\n}\n```\n\nDelaying logic for a particular time interval\n\nDo NOT call **Thread.Sleep()** as it will lock the Instrument thread executing your **NinjaScript** object.\n\n{% table %}\n\n* Why\n\n---\n\n* Market data events exposed to **NinjaScript** run on the underlying Instrument thread pool shared by all Instruments. Sleeping the underlying thread of your object will cause the entire Instrument thread to sleep, adversely affecting other features using that same Instrument.\n{% /table %}\n\n```csharp Practice to avoid\n\n---\n\nprotected override void OnBarUpdate()\n{\n   if (IsFirstTickOfBar && State == State.Realtime)\n   {\n       Print(\"Run some logic before:: \" + DateTime.Now);\n       Thread.Sleep(5000); // sleeping the Instrument thread will have adverse effects on elements outside of your script!\n       Print(\"Run some logic after: \" + DateTime.Now);\n   }\n}\n```\n\nInstead, try using a **Timer** object if you need to delay logic execution.\n\n```csharp Best practice\nprotected override void OnBarUpdate()\n{\n   if (IsFirstTickOfBar && State == State.Realtime)\n   {\n       // Instead of Thread.Sleep for, create a timer that runs at the desired interval\n       System.Windows.Forms.Timer timer = new System.Windows.Forms.Timer {Interval = 5000};\n\n       // queue the \"after\" logic to run when the timer elapses\n       timer.Tick += delegate\n       {\n           timer.Stop(); // make sure to stop the timer to only fire ones (if desired)\n           Print(\"Run some logic after: \" + DateTime.Now);\n           timer.Dispose(); // make sure to dispose of the timer\n       };\n\n       Print(\"Run some logic before: \" + DateTime.Now);\n\n       timer.Start(); // start the timer immediately following the \"before\" logic\n   }\n\n```\n\n## Miscellaneous practices\n\n{% table %}\n\n* Floating-point comparison\n\n---\n\n* Be aware of floating-point precision problems. It can sometimes be more reliable to check within a certain degree of tolerance, such as the **TickSize**.\n{% /table %}\n\n{% table %}\n\n* Why\n\n---\n\n* You can read more about [Floating-Point Arithmetic](http://ninjatrader.com/support/forum/showthread.php?t=3929) as it applies to **NinjaTrader** on our support forum.\n{% /table %}\n\n```csharp Practice to avoid\n\n---\n\n// depending on how Value[0] was calculated, it could be off by a degree of floating points\n// where this logic below would never be true\n// e.g., 2050.2499999 vs 2050.50\nif (Value[0] == Close[0])\n{\n   // do something\n}\n```\n\n```csharp Best practice\n// you can avoid these precision issues by rewriting the comparison to evaluate within a certain tolerance.\nif (Math.Abs(Value[0] - Close[0]) < TickSize)\n{\n   // do something\n}\n\n// You will also see NinjaTrader developed objects use a custom Extension Method\n// double.ApproxCompare() which Returns an int based on a Epsilon value:\nif (Close[0].ApproxCompare(Value[0]) == 0)\n{\n   // do something\n}\n```\n\nCreating user defined parameter types / enums\n\nWhen creating enums for your **NinjaScript** objects, it is strongly suggested to define those outside the class and in a custom namespace. A reference sample providing all details could be [found here](creating_a_user_defined_parame).\n\nEfficiently debugging\n\nExtremely liberal use of **Log()** and **Print()** methods can represent a performance hit on your PC as it takes memory and time to process each one of those method calls. When running custom **NinjaScript**, especially when using **Calculate = Calculate.OnEachTick**, please be mindful of how often **Log()** and **Print()** methods are processed as it can quickly consume PC resources.\n\n* **Log()** method should not be used except for critical messages as each log entry makes it to the Control Center log which stays active till the end of the day. Excessive logging can result in huge amounts of memory being allocated just to display all the log messages which would mean less memory for **NinjaTrader** to do other tasks.\n* **Print()** method can be used more liberally than the **Log()** method, but can still represent a performance hit if used with extremely high frequency. Consider decreasing the printing from your script if you experience slowdowns when running the script.\n\nDebug Mode\n\nThe debug mode should only be used if you are actively debugging a script and [attached to a debugger](visual_studio_debugging).\n\n{% table %}\n\n* Why\n\n---\n\n* Debug Mode will compile all of the files in the custom project as a \"Debug\" build, which omits certain optimizations which occur in the C# compilation process. It is more efficient to use your custom objects in the default \"Release\" build if you are using your scripts during production.\n{% /table %}\n\nTo disable Debug Mode:\n\n* Right mouse click in any **NinjaScript Editor**\n* Ensure the \"Debug Mode\" menu item is unchecked\n* Press F5 to recompile your scripts\n* Your scripts will be re-built using \"Release\" mode\n\nKnown **NinjaScript** Wrappers limitations\n\n* The **NinjaScript** editor detects code changes in external editors, and will compile on code changes, however code will only be automatically generated by the **NinjaScript** editor if it's edited within the **NinjaScript** editor itself (or **Visual Studio**).\n* Wrappers cannot be generated automatically for partial and abstract classes.\n* Code in the Properties region of the **NinjaScript** object cannot be commented out with the /**/ style commenting, as it will cause issues with the wrapper generation. Code must be commented out with the // style.\n* Subclassing would not allow for wrappers to be generated."
  },
  {
    "_id": "93c5b08df439bd719c489cdebe98ecc0b4266679d927ebd3d41506886e947e62",
    "_type": "desktopSdkDoc",
    "title": "OnCalculatePerformanceValue()",
    "pathName": "oncalculateperformancevalue",
    "parent": "optimization_fitness",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThis method calculates the value for the Optimization Fitness.\n\n## Syntax\n\n**protected override void OnCalculatePerformanceValue(StrategyBase strategy)**\n\n## Examples\n\n```csharp\nprotected override void OnCalculatePerformanceValue(StrategyBase strategy)\n{\n\n     Value = strategy.SystemPerformance.AllTrades.TradesPerformance.Percent.Drawdown;\n\n}"
  },
  {
    "_id": "04fd71c9d76bea810219891b2322dade1bf4943536487339cf4b4381189d9237",
    "_type": "desktopSdkDoc",
    "title": "OptimizationParameters",
    "pathName": "optimizationparameters",
    "parent": "optimizer",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)\n\n## Property Value\n\nA bool value.\n\n## Syntax\n\n**Strategies[0].OptimizationParameters**\n\n## Examples\n\n```csharp\nprotected override void OnOptimize()\n{\n     // If there are no optimization parameters to optimize, return\n     if (Strategies[0].OptimizationParameters.Count == 0)\n         return;\n\n     // Do something with the optimization parameter\n     Parameter parameter = Strategies[0].OptimizationParameters[0];\n}\n```"
  },
  {
    "_id": "c1acf7c2d0ca1975b5c37281c3f66dea95aaf670b9e3caa49e4e9bc34ac6a5f3",
    "_type": "desktopSdkDoc",
    "title": "GetAtmStrategyPositionQuantity()",
    "pathName": "getatmstrategypositionquantity",
    "parent": "atm_strategy_methods",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGets the current position quantity of the specified ATM Strategy.\n\n{% callout type=\"note\" %}\n\nChanges to positions will not be reflected till at least the next **OnBarUpdate()** event after an order fill.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing the quantity.\n\n## Syntax\n\n**GetAtmStrategyPositionQuantity(string atmStrategyId)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **atmStrategyId**\n* The unique identifier for the ATM strategy\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Check if flat\n     if (GetAtmStrategyMarketPosition(\"idValue\") != MarketPosition.Flat)\n         Print(\"Position size is \" + GetAtmStrategyPositionQuantity(\"idValue\").ToString());\n}\n```"
  },
  {
    "_id": "f9e48b0b8d66263618447acc80a6c66f1ebacdd66f830441ee208ff68ba574ea",
    "_type": "desktopSdkDoc",
    "title": "GetAtmStrategyUniqueId()",
    "pathName": "getatmstrategyuniqueid",
    "parent": "atm_strategy_methods",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a unique ATM Strategy ID value.\n\n## Method Return Value\n\nA **string** value representing a unique id value.\n\n## Syntax\n\n**GetAtmStrategyUniqueId()**\n\n## Parameters\n\nThis method does not take any parameters.\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    string orderId = GetAtmStrategyUniqueId();\n}\n```"
  },
  {
    "_id": "6334b16fda74bde3f63bbf1b7ef1de3156e627bae8693d447c379189f1861218",
    "_type": "desktopSdkDoc",
    "title": "GetRealtimeOrder()",
    "pathName": "getrealtimeorder",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a matching real-time order object based on a specified historical order object reference.\n\n{% callout type=\"note\" %}\n\nThis method is only needed if you have historical order references which you wish to transition and manage in real-time (i.e., you had a working order which was submitted historically and re-submitted in real-time as the strategy is enabled). This method only needs to be called once per order object, and should be done in OnOrderUpdate to handle all scenarios. Please see the [Advanced Order Handling](advanced_order_handling) section on transition orders for more details.\n\n{% /callout %}\n\n## Method Return Value\n\nReturns a real-time [order](order) reference associated with the historical order object. If no associated order exists (i.e. OrderState is Filled, Canceled, Rejected, Unknown), a null value returns.\n\n## Syntax  \n\n**GetRealtimeOrder(Order historicalOrder)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* historicalOrder\n* The historical [order](order) object to update to real-time\n{% /table %}\n\n## Examples\n\n```csharp\nprivate Order myOrder;\n\nprotected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string nativeError)\n{\n    // One time only, as we transition from historical\n    // Convert any old historical order object references to the live order submitted to the real-time account\n    if (myOrder != null && myOrder.IsBacktestOrder && State == State.Realtime)\n        myOrder = GetRealtimeOrder(myOrder);\n\n    // Assign Order objects here\n    // This is more reliable than assigning Order objects in OnBarUpdate, as the assignment is not guaranteed to be complete if it is referenced immediately after submitting\n    if (order.Name == \"myOrder Signal Name\")\n        myOrder = order;\n\n    // Null Entry order if filled or cancelled. We do not use the Order objects after the order is filled, so we can null it here\n    if (myOrder != null && myOrder == order)\n    {\n        if (order.OrderState == OrderState.Cancelled && order.Filled == 0)\n            myOrder = null;\n        if (order.OrderState == OrderState.Filled)\n            myOrder = null;\n    }\n}\n```"
  },
  {
    "_id": "9c701261b149c7acc3125aa9f615a0f3c29e7f032402cca7798f8baf9e883afe",
    "_type": "desktopSdkDoc",
    "title": "SubmitOrderUnmanaged()",
    "pathName": "submitorderunmanaged",
    "parent": "unmanaged_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates an **Unmanaged** order.\n\n## Method Return Value\n\nAn **Order** read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the **Unmanaged Approach** section.\n\n## Syntax\n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity)  \n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity, double limitPrice)  \n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity, double limitPrice, double stopPrice)  \n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity, double limitPrice, double stopPrice, string oco)  \n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity, double limitPrice, double stopPrice, string oco, string signalName)\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* selectedBarsInProgress\n* The index of the Bars object the order is to be submitted against. This determines what instrument the order is submitted for.  \nNote: See the **BarsInProgress** property.\n\n---\n\n* orderAction\n* Determines if the order is a buy or sell order  \nPossible values:  \n**OrderAction.Buy**  \n**OrderAction.BuyToCover**  \n**OrderAction.Sell**  \n**OrderAction.SellShort**\n\n---\n\n* orderType\n* Determines the type of order submitted  \nPossible values:  \n**OrderType.Limit**  \n**OrderType.Market**  \n**OrderType.MIT**  \n**OrderType.StopMarket**  \n**OrderType.StopLimit**\n\n---\n\n* quantity\n* Sets the number of contracts to submit with the order\n\n---\n\n* limitPrice\n* Order limit price. Use \"0\" should this parameter be irrelevant for the OrderType being submitted.\n\n---\n\n* stopPrice\n* Order stop price. Use \"0\" should this parameter be irrelevant for the OrderType being submitted.\n\n---\n\n* oco\n* A string representing the OCO ID used to link OCO orders together  \nNote: OCO strings should not be reused. Use unique strings for each OCO group, and reset after orders in that group are filled/canceled\n\n---\n\n* signalName\n* A string representing the name of the order. Max 50 characters.\n{% /table %}\n\n## Examples\n\n```csharp\nprivate Order entryOrder = null;  \nprotected override void OnBarUpdate()  \n{  \n    // Entry condition  \n    if (Close[0] > SMA[20](0) && entryOrder == null)  \n        SubmitOrderUnmanaged(0, OrderAction.Buy, OrderType.Market, 1, 0, 0, \"\", \"Enter Long\");  \n}  \nprotected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string nativeError)  \n{  \n    // Assign entryOrder in OnOrderUpdate() to ensure the assignment occurs when expected.  \n    // This is more reliable than assigning Order objects in OnBarUpdate, as the assignment is not guaranteed to be complete if it is referenced immediately after submitting  \n    if (order.Name == \"Enter Long\" && orderState == OrderState.Filled)  \n        entryOrder = order;  \n}\n\n```"
  },
  {
    "_id": "fc3532b8a6e42c0ee02e53787fd147d09f5cda0703eb60132b0856ae5a8af045",
    "_type": "desktopSdkDoc",
    "title": "OrderFillResolution",
    "pathName": "orderfillresolution",
    "parent": "strategy",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines how strategy orders are filled during historical states.\n\nPlease see [Understanding Historical Fill Processing](understanding_historical_fill_) for general information on historical fill processing.\n\n## Property Value\n\nAn enum value that determines how the strategy orders are filled. Default value is set to **OrderFillResolution.Standard**. Possible values are:\n\n* **OrderFillResolution.Standard**  | Faster - Uses the existing bar type and interval that you are running the backtest on to fill your orders.\n* **OrderFillResolution.High** | More granular - Allows you to set a secondary bar series to be used as the price data to fill your orders. (See also [OrderFillResolutionType](orderfillresolutiontype) and [OrderFillResolutionValue](orderfillresolutionvalue))\n{% /table %}\n\n## Syntax\n\n**OrderFillResolution**\n\n{% callout type=\"warning\" %}\n\n* Warning: This property should ONLY be set from the [OnStateChange()](onstatechange) method during State.SetDefaults\n{% /callout %}\n\n## Examples\n\n```csharp\n\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"ExampleStrategy\";\n     OrderFillResolution = OrderFillResolution.Standard;\n   }\n}\n```"
  },
  {
    "_id": "6839fb341fad4c54fe90a3500a6b385bc0f8111b9ca282d8349cad4e1a9d1706",
    "_type": "desktopSdkDoc",
    "title": "AveragePrice",
    "pathName": "averageprice",
    "parent": "position",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGets the average price of a strategy position.\n\n## Property Value\n\nA **double** value representing the position's average price per unit.\n\n## Syntax\n\n**Position.AveragePrice**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Raise stop loss to breakeven when there is at least 10 ticks in profit\n     if (Close[0] >= Position.AveragePrice + 10 * TickSize)\n         ExitLongStopMarket(Position.Quantity, Position.AveragePrice);\n}\n```"
  },
  {
    "_id": "8954420e242cd3fe39689337270964fc8e955395ea0c1557e10cc62d90bf9e35",
    "_type": "desktopSdkDoc",
    "title": "StrategyBaseConverter Class",
    "pathName": "strategybaseconverter",
    "parent": "strategy",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA custom **TypeConverter** class handling the designed behavior of a strategy's property descriptor collection. Use this as a base class for any custom TypeConverter you are applying to a strategy class.\n\n{% callout type=\"note\" %}\nNotes:\n\n* A working NinjaScript demo can be found through the reference sample on \"[Using a TypeConverter to Customize Property Grid Behavior](http://ninjatrader.com/support/forum/showthread.php?t=97919)\"\n* When applying the custom converter, you must fully qualify the name (e.g., \"NinjaTrader.NinjaScript.Strategies.MyCustomConveter\")\n* Additional TypeConverter information can be found from the [MSDN documentation](https://msdn.microsoft.com/en-us/library/system.componentmodel.typeconverter%28v=vs.110%29.aspx)\n* See also [TypeConverterAttribute](typeconverterattribute.htm)\n* For Indicators, see the [IndicatorBaseConverter](indicatorbaseconverter.htm) class\n{% /callout %}\n\n## Relevant base methods\n\n{% table %}\n\n* Method\n* Description\n\n---\n\n* [TypeConverter.GetProperties()](https://msdn.microsoft.com/en-us/library/system.componentmodel.typeconverter.getproperties(v=vs.110).aspx)\n* When overriding GetProperties(), calling base.GetProperties() ensures that all default property grid behavior works as designed\n\n---\n\n* [TypeConverter.GetPropertiesSupported()](https://msdn.microsoft.com/en-us/library/system.componentmodel.typeconverter.getpropertiessupported(v=vs.110).aspx)\n* In your custom converter class, you must override GetPropertiesSupported() and return a value of true in order for your custom type converter to work\n{% /table %}\n\n## Syntax\n\n**public class StrategyBaseConverter : TypeConverter**\n\n{% callout type=\"warning\" %}\nWarning: Failure to apply a type of **StrategyBaseConverter** on a strategy class can result in unpredictable behavior of the standard NinjaTrader WPF property grid.\n{% /callout %}\n\n{% callout type=\"note\" %}\nTip: Common strategy functions like **Print()** are not available to a type converter instance. To debug a type converter class, you can use the AddOn [Debug Concepts](alert_and_debug_concepts.htm) or [attach to a debugger](visual_studio_debugging.htm) (recommended)\n{% /callout %}\n\n## Examples\n\n```csharp\n// This namespace holds Strategies in this folder and is required. Do not change it.\nnamespace NinjaTrader.NinjaScript.Strategies\n{\n  // When applying the type converter, you must fully qualify the name\n  [TypeConverter(\"NinjaTrader.NinjaScript.Strategies.MyCustomConveter\")]\n  public class MyCustomStrategy : Strategy\n  {\n   protected override void OnStateChange()\n   {\n     if (State == State.SetDefaults)\n     {\n      Name               = \"MyCustomStrategy\";\n     }\n   }\n\n   protected override void OnBarUpdate()\n   {\n     //Add your custom strategy logic here.\n   }\n  }\n\n  // custom converter class for strategies\n  public class MyCustomConveter : StrategyBaseConverter\n  {\n   // A general TypeConveter method used for converting types\n   public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attrs)\n   {\n     // sometimes you may need the strategy instance which actually exists on the grid\n     MyCustomStrategy strategy = component as MyCustomStrategy;\n\n     // base.GetProperties ensures we have all the properties (and associated property grid editors)\n     // NinjaTrader internal logic handles for a given strategy\n     PropertyDescriptorCollection propertyDescriptorCollection = base.GetPropertiesSupported(context)\n         ? base.GetProperties(context, component, attrs) : TypeDescriptor.GetProperties(component, attrs);\n\n     if (strategy == null || propertyDescriptorCollection == null)\n      return propertyDescriptorCollection;\n\n     // example of why you may need the instance that exists on the grid....\n     if (strategy.EntryHandling == EntryHandling.UniqueEntries)\n     {\n      // do something in the event a property contains some value...\n     }\n\n     // Loop all of the properties of the strategy\n     foreach (PropertyDescriptor property in propertyDescriptorCollection)\n     {\n      // do something with a specific property\n\n      // cannot call **Print()** here\n      // but you can call the static Output window \"Process()\"\n      NinjaTrader.Code.Output.Process(property.Name, PrintTo.OutputTab1);\n     }\n\n     // must return the collection after making changes\n     return propertyDescriptorCollection;\n   }\n\n   // Important: This must return true otherwise the type converter will not be called\n   public override bool GetPropertiesSupported(ITypeDescriptorContext context)\n   { return true; }\n  }\n}\n```"
  },
  {
    "_id": "6f03ed5c0d98e6ef4ad6ad69c19332bf75394162f3694340d0ee87f3ae605ddb",
    "_type": "desktopSdkDoc",
    "title": "TradesPerformance",
    "pathName": "tradesperformance",
    "parent": "strategy",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nPerformance profile of a **collection** of **Trade** objects.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* AverageBarsInTrade\n* A double value representing the average number of bars per trade\n\n---\n\n* AverageEntryEfficiency\n* A double value representing the average entry efficiency\n\n---\n\n* AverageExitEfficiency\n* A double value representing the average exit efficiency\n\n---\n\n* AverageTimeInMarket\n* A TimeSpan value representing quantity-weighted average duration of a trade\n\n---\n\n* AverageTotalEfficiency\n* A double value representing the average total efficiency\n\n---\n\n* TotalCommission\n* A double value representing the total commission\n\n---\n\n* Currency\n* Gets a TradesPerformanceValues object in currency\n\n---\n\n* GrossLoss\n* A double value representing the gross loss\n\n---\n\n* GrossProfit\n* A double value representing the gross profit\n\n---\n\n* LongestFlatPeriod\n* A TimeSpan value representing longest duration of being flat\n\n---\n\n* MaxConsecutiveLoser\n* An int value representing the maximum number of consecutive losses seen\n\n---\n\n* MaxConsecutiveWinner\n* An int value representing the maximum number of consecutive winners seen\n\n---\n\n* MaxTime2Recover\n* A TimeSpan value representing maximum time to recover from a draw down\n\n---\n\n* MonthlyStdDev\n* A double value representing the monthly standard deviation\n\n---\n\n* MonthlyUlcer\n* A double value representing the monthly Ulcer index\n\n---\n\n* NetProfit\n* A double value representing the net profit\n\n---\n\n* Percent\n* Gets a TradesPerformanceValues object in percent\n\n---\n\n* PerformanceMetrics\n* An array of custom NinjaScript performance metrics\n\n---\n\n* Pips\n* Gets a TradesPerformanceValues object in pips\n\n---\n\n* Points\n* Gets a TradesPerformanceValues object in points\n\n---\n\n* ProfitFactor\n* A double value representing the profit factor\n\n---\n\n* R2\n* A double value representing the R-squared value\n\n---\n\n* RiskFreeReturn\n* A double value representing the risk free return rate\n\n---\n\n* SharpeRatio\n* A double value representing the Sharpe Ratio\n\n---\n\n* SortinoRatio\n* A double value representing the Sortino Ratio\n\n---\n\n* Ticks\n* Gets a TradesPerformanceValues object in ticks\n\n---\n\n* TotalQuantity\n* An int value representing the total quantity\n\n---\n\n* TotalSlippage\n* A double value representing the total slippage. This is presented in points, I.E. 0.25 for 1 execution on E-mini S&P 500 Futures.\n\n---\n\n* TradesCount\n* An int value representing the trades count\n\n---\n\n* TradesPerDay\n* An int value representing the avg trades per day\n\n---\n{% /table %}\n\n## Examples\n\n```csharp\nprotectedoverridevoidOnBarUpdate()\n{\n // Only trade if you have less than 5 consecutive losers in a row\n if(SystemPerformance.RealTimeTrades.TradesPerformance.MaxConsecutiveLoser < 5)\n {\n   // Trade logic here\n }\n}\n```"
  },
  {
    "_id": "989d407698796cf007a0aa447a6aae166eca109ec3002f774876e6b4efbfc965",
    "_type": "desktopSdkDoc",
    "title": "AverageMae",
    "pathName": "averagemae",
    "parent": "tradesperformancevalues",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the average MAE (max adverse excursion) of the collection.\n\n## Property Value\n\nA **double** value that represents the average MAE of the collection.\n\n## Syntax\n\ntradecollection.TradesPerformance.tradesperformancevalues.**AverageMae**\n\n## Examples\n\n{% callout type=\"note\" %}\n\nThe following example shows how to print out the average MAE of all trades in currency.\n\n{% /callout %}\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Print out the average MAE of all trades in currency\n     Print(\"Average MAE of all trades is: \" + SystemPerformance.AllTrades.TradesPerformance.Currency.AverageMae);\n}\n```"
  },
  {
    "_id": "0014f61bd3b346437cb834c7cc2cdd1c88dd63ee0a9fec6f7b743e1e591dfc18",
    "_type": "desktopSdkDoc",
    "title": "ApproxCompare()",
    "pathName": "approxcompare",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nCompares two double or float values for equality or being greater than / less than the compared to value.\n\n{% callout type=\"note\" %}\n\nComparing for being greater than / less is done using an epsilon value of 1E19\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing the outcome of the comparison. Returns 0 if values are equal, 1 if value1 is greater than value2. -1 if value1 is less than value2.\n\n## Syntax\n\n**this.ApproxCompare(this double double1, double double2)**\n**this.ApproxCompare(this float float1, double float2)**\n\n## Parameters\n\n{% table %}\n* Parameter\n* Description\n---\n* double1 / float1\n* First value to compare against (not actually passed in)\n---\n* double2 / float2\n* Second passed in value to compare against\n---\n\n{% callout type=\"note\" %}\n\nMain use would be using it for equality comparisons to circumvent running into floating point considerations, value compares for < or > could be usually done more straightforward directly.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Build the High / Low difference and if 0 sets the indicator main Value series to 0\nif ((High[0] - Low[0]).ApproxCompare(0) == 0)\n  Value[0] = 0;\n```"
  },
  {
    "_id": "be6df13306a21c86f3098150dbcc366b06834c88cb66ae0b599dd68e4cdb1027",
    "_type": "desktopSdkDoc",
    "title": "GetMedian()",
    "pathName": "getmedian",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the statistical median value of the specified series over the specified look-back period. This method sorts the values of the specified look back period in ascending order and returns the middle value.\n\n{% callout type=\"note\" %}\n\n1. This method should NOT be confused with **Median** prices defined as (**High** + **Low**) / 2. This method returns the statistical median of a series.\n2. If an even number is passed as the look-back period, the average of the two middle values in the sorted values will be returned.\n{% /callout %}\n\n## Method Return Value\n\nA **double** value representing the median value of the series.\n\n## Syntax\n\n**GetMedian**(**ISeries`<double>`** series, **int** lookBackPeriod)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **lookBackPeriod**\n* Number of bars back to include in the calculation\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, **Close**, **High**, **Low**, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{  \n  // Print the median price of the last 10 open prices \n  //(current open price + look back period's 9 open prices before that)\n  double openMedian = GetMedian(Open, 9);     \n  Print(\"The median of the last 10 open prices is: \" + openMedian);   \n}\n```"
  },
  {
    "_id": "f62717a9bd9c19d6495285bc52b022cb734d3b41566c005d2573a86fd79e970f",
    "_type": "desktopSdkDoc",
    "title": "HighestBar()",
    "pathName": "highestbar",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the number of bars ago the highest price value occurred within the specified look-back period.\n\n## Method Return Value\n\nAn **int** value representing a value of bars ago.\n\n## Syntax\n\n**HighestBar**(**ISeries`<double>`** series, **int** period)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **period**\n* The number of bars to include in the calculation\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, Close, High, Low, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n  // store the highest bars ago value\n  int highestBarsAgo = HighestBar(**High, Bars.BarsSinceNewTradingDay);\n\n  //evaluate high price from highest bars ago value\n  double highestPrice = High[highestBarsAgo];\n\n  //Printed result: Highest price of the session: 2095.5 - occurred 24 bars ago\n  Print(string.Format(\"Highest price of the session: {0} - occurred {1} bars ago\", highestPrice, highestBarsAgo));\n}\n```"
  },
  {
    "_id": "514b308c0e0274639ac488aa7c7f3f57531f05d39b11ca0772ed1f37c721154d",
    "_type": "desktopSdkDoc",
    "title": "LowestBar()",
    "pathName": "lowestbar",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the number of bars ago the lowest price value occurred within the specified look-back period.\n\n## Method Return Value\n\nAn **int** value representing a value of bars ago.\n\n## Syntax\n\n**LowestBar**(**ISeries`<double>`** series, **int** period)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **period**\n* The number of bars to check for the test condition\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, **Close**, **High**, **Low**, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n  // store the lowest bar ago value\n  int lowestBar = LowestBar(Low, Bars.BarsSinceNewTradingDay);\n\n  //evaluate low price from lowest bar ago value\n  double lowestPrice = Low[lowestBar];\n\n  //Printed result: Lowest price of the session: 2087.25 - occurred 362 bars ago\n  Print(string.Format(\"Lowest price of the session: {0} - occurred {1} bars ago\", lowestPrice, lowestBar));\n}\n```"
  },
  {
    "_id": "2cd7abdb476ef7d4cb186427fd34e14342d07d0b49fa2214239d8a7a8f67edbe",
    "_type": "desktopSdkDoc",
    "title": "GetOpen()",
    "pathName": "getopen",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the open price at the selected bar index value.\n\n## Method Return Value\n\nA **double** value that represents the open price at the desired bar index.\n\n## Syntax\n\n**Bars.GetOpen(int index)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **index**\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n  base.OnRender(chartControl, chartScale);\n  // loop through only the rendered bars on the chart\n  for(int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n  {\n   // get the open price at the selected bar index value\n   double openPrice = Bars.GetOpen(barIndex);\n   Print(\"Bar #\" + barIndex + \" open price is \" + openPrice);\n  }\n}\n```"
  },
  {
    "_id": "62a450a3ae6652a43f41f8094326c58e1577d44b69371951dcdc467e85967cb6",
    "_type": "desktopSdkDoc",
    "title": "ScaleJustification",
    "pathName": "scalejustification",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the location of the chart scale relative to the chart control.\n\n## Property Value\n\nA **ScaleJustification** enum. Possible values are:\n\n* **Right**\n* **Left**\n* **Overlay**\n\n## Syntax\n\n**ScaleJustification**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (chartScale.ScaleJustification == ScaleJustification.Right)\n   {\n     // do something\n   }\n\n}\n```"
  },
  {
    "_id": "c30b8ee5b1a3ac4ccb2add0e8cb485b1fe2ae98f06f4493a6ed4ba18e35c67dd",
    "_type": "desktopSdkDoc",
    "title": "DirectWriteFactory",
    "pathName": "directwritefactory",
    "parent": "rendering",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nProvides a default **DirectWrite** factory used for creating [**SharpDX.DirectWrite**](sharpdx_directwrite) components.\n\n## Property Value\n\nA read-only **SharpDX.DirectWrite.Factory** used to create DirectWrite objects compatible with **NinjaTrader** rendering.\n\n## Syntax\n\n**NinjaTrader.Core.Globals.DirectWriteFactory**\n\n## Examples\n\n```csharp\n// create a text format object with default NinjaTrader DirectWrite factory\n\nSharpDX.DirectWrite.TextFormat textFormat = new SharpDX.DirectWrite.TextFormat(NinjaTrader.Core.Globals.DirectWriteFactory,\n   \"Arial\", 12f);\n\n// create a text layout object with default NinjaTrader DirectWrite factory\n\nSharpDX.DirectWrite.TextLayout textLayout = new SharpDX.DirectWrite.TextLayout(NinjaTrader.Core.Globals.DirectWriteFactory,\n\n   \"text to render\", textFormat, ChartPanel.W, ChartPanel.H);\n```"
  },
  {
    "_id": "638ff34ed784588796f0e7a2ca4d3f6d2e19eef0b2fd57e4ca7a0afcbf98a501",
    "_type": "desktopSdkDoc",
    "title": "Draw.ArrowLine()",
    "pathName": "draw_arrowline",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws an arrow line.\n\n## Method Return Value\n\nAn **ArrowLine** object that represents the draw object.\n\n## Syntax\n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n  * **DashStyleHelper.Dash**  \n  * **DashStyleHelper.DashDot**  \n  * **DashStyleHelper.DashDotDot**  \n  * **DashStyleHelper.Dot**  \n  * **DashStyleHelper.Solid**  \n  Note: Drawing objects with y values very far off the visible canvas can lead to performance hits. Fancier DashStyles like **DashDotDot** will also require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a dotted lime green arrow line\nDraw.ArrowLine(this, \"tag1\", 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);\n```"
  },
  {
    "_id": "8bba89fef0945fef581be912547cbc265cbd47ca853e5a71d7dd986170f99e04",
    "_type": "desktopSdkDoc",
    "title": "Draw.Polygon()",
    "pathName": "draw_polygon",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a polygon which can have a user defined set of anchors.\n\n## Method Return Value\n\nA **Polygon** object that represents the draw object.\n\n## Syntax\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, bool isGlobal, string templateName)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, Brush brush, DashStyleHelper dashStyle, Brush areaBrush, int areaOpacity)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y, int anchor5BarsAgo, double anchor5Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y, DateTime Anchor5Time, double anchor5Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y, int anchor5BarsAgo, double anchor5Y, int anchor6BarsAgo, double anchor6Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y, DateTime Anchor5Time, double anchor5Y, DateTime Anchor6Time, double anchor6Y)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* chartAnchors\n* A list of the chart anchors.\n\n---\n\n* anchor1BarsAgo\n* The bar the first anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor2BarsAgo\n* The bar the second anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor3BarsAgo\n* The bar the third anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor4BarsAgo\n* The bar the forth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor5BarsAgo\n* The bar the fifth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor6BarsAgo\n* The bar the sixth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor1Y\n* The first anchor y value.\n\n---\n\n* anchor2Y\n* The second anchor y value.\n\n---\n\n* anchor3Y\n* The third anchor y value.\n\n---\n\n* anchor4Y\n* The forth anchor y value.\n\n---\n\n* anchor5Y\n* The fifth anchor y value.\n\n---\n\n* anchor6Y\n* The sixth anchor y value.\n\n---\n\n* Anchor1Time\n* The time the first anchor of the object will be drawn at.\n\n---\n\n* Anchor2Time\n* The time the second anchor of the object will be drawn at.\n\n---\n\n* Anchor3Time\n* The time the third anchor of the object will be drawn at.\n\n---\n\n* Anchor4Time\n* The time the forth anchor of the object will be drawn at.\n\n---\n\n* Anchor5Time\n* The time the fifth anchor of the object will be drawn at.\n\n---\n\n* Anchor6Time\n* The time the sixth anchor of the object will be drawn at.\n\n---\n\n* areaBrush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Draws a Polygon object based on bars ago and y anchors\nDraw.Polygon(this, \"tag1\", false, 20, 194, 10, 184, 13, 176, 25, 182);\n\n// Draws a Polygon object based on a list of anchors with specified times\nList<chartanchor> anchors = new List<chartanchor>();\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 25), 194, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 12), 184, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 7), 176, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 21), 182, ChartControl));\nDraw.Polygon(this, \"tag1\", false, anchors, Brushes.CornflowerBlue, DashStyleHelper.Solid, Brushes.CornflowerBlue, 40);\n\n```"
  },
  {
    "_id": "093deb93fa32838dc12316097db78596c505c04bc55504564df7be7769815aa2",
    "_type": "desktopSdkDoc",
    "title": "Draw.Rectangle()",
    "pathName": "draw_rectangle",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a rectangle.\n\n## Method Return Value\n\nA **Rectangle** object that represents the draw object.\n\n## Syntax\n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* areaBrush\n* The brush used to color the fill area of the draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Draws a blue rectangle from the low 10 bars back to the high of 5 bars back\nDraw.Rectangle(this, \"tag1\", 10, Low[10] - TickSize, 5, High[5] + TickSize, Brushes.Blue);\n\n// Draws a blue rectangle from the low 10 bars back to the high of 5 bars back with a fill color or pale green with a transparency level of 2\nDraw.Rectangle(this, \"tag1\", false, 10, Low[10] - TickSize, 5, High[5] + TickSize, Brushes.PaleGreen, Brushes.PaleGreen, 2);\n\n```"
  },
  {
    "_id": "be0256bc43cd28db9b0298aa3666c312c12bbd7890a823541f1672d9c7bcccf1",
    "_type": "desktopSdkDoc",
    "title": "Draw.RegionHighlightY()",
    "pathName": "draw_regionhighlighty",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a region highlight y on a chart.\n\n## Method Return Value\n\nA **RegionHighlightY** object that represents the draw object.\n\n## Syntax\n\n**Draw.RegionHighlightY(NinjaScriptBase owner, string tag, double startY, double endY, Brush brush)**  \n\n**Draw.RegionHighlightY(NinjaScriptBase owner, string tag, bool isAutoScale, double startY, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.RegionHighlightY(NinjaScriptBase owner, string tag, double startY, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endY\n* The ending y value co-ordinate where the draw object will be drawn.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](brushes)).\n\n---\n\n* areaBrush\n* The brush used to color the fill area of the draw object ([reference](brushes)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Fills in the region between the startY and endY\nDraw.RegionHighlightY(this, \"tag1\", true, High[0], Low[0], Brushes.Blue, Brushes.Green, 20);\n```"
  },
  {
    "_id": "68bee3a3bb454b2c36f6ad63241d04638a2680fd096b50bdc928ea3917ef3dc4",
    "_type": "desktopSdkDoc",
    "title": "InstrumentType",
    "pathName": "instrumenttype",
    "parent": "instruments",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the type of instrument.\n\n## Property Value\n\nAn **InstrumentType** representing the type of an instrument.\n\nPossible values are:\n\n* **InstrumentType.Future**\n* **InstrumentType.Stock**\n* **InstrumentType.Index**\n* **InstrumentType.Forex**\n* **InstrumentType.Cfd**\n* **InstrumentType.Cryptocurrency**\n\n## Syntax\n\n**Instrument.MasterInstrument.InstrumentType**\n\n## Examples\n\n```csharp\nif (Instrument.MasterInstrument.InstrumentType == InstrumentType.Future)\n{\n// Do something\n}\nelse\n{\n// Do something else\n}\n```\n\n## Additional Access Information\n\nThis property can be accessed without a null reference check in the **OnBarUpdate()** event handler. When the **OnBarUpdate()** event is triggered, there will always be an **Instrument** object. Should you wish to access this property elsewhere, check for null reference first. e.g. if (**Instrument** != null)"
  },
  {
    "_id": "17c30eabf6e74886e708e67489df6281d46a2c9244205b973ee91267c659725f",
    "_type": "desktopSdkDoc",
    "title": "AtmStrategy",
    "pathName": "atmstrategy",
    "parent": "add_on",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "AtmStrategy contains properties and methods used to manage [ATM Strategies](advanced_trade_management_atm). When working with an [AtmStrategySelector](atmstrategyselector), selected objects can be case to AtmStrategy to obtain or change their properties.\n\n{% callout type=\"note\" %}\n\n1. For a complete, working example of this class in use, download framework example located on our [Developing AddOns Overview](developing_add_ons)\n2. For more information on working with the ATM strategies programmatically in general, please see the [Using ATM Strategies](using_atm_strategies) section.\n{% /callout %}\n\n## Example\n\n```csharp\n// Using AtmStrategy to handle user selections in an ATM Strategy Selector\nmyAtmStrategySelector.SelectionChanged += (o, args) =>\n{\n   if (myAtmStrategySelector.SelectedItem == null)\n       return;\n   if (args.AddedItems.Count > 0)\n   {\n       // Change the selected TIF in a TIF selector based on what is selected in the ATM Strategy Selector\n       NinjaTrader.NinjaScript.AtmStrategy selectedAtmStrategy = args.AddedItems[0] as NinjaTrader.NinjaScript.AtmStrategy;\n       if (selectedAtmStrategy != null)\n       {\n           myTifSelector.SelectedTif = selectedAtmStrategy.TimeInForce;\n       }\n   }\n};\n```"
  },
  {
    "_id": "68075ee59bb3f05f3fabd56bf69082e061a0ca6dd295da8d4595f86e48ecd4ae",
    "_type": "desktopSdkDoc",
    "title": "CreateAnchor()",
    "pathName": "createanchor",
    "parent": "language_reference",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nUsed to create a new chart anchor at a specified mouse point.\n\n## Method Return Value\n\nA new **ChartAnchor** at a specified point in device pixels.\n\n## Syntax\n\n**CreateAnchor(Point point, ChartControl chartControl, ChartScale chartScale)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **point**\n* A Point in device pixels representing the current mouse cursor position\n\n---\n\n* **chartControl**\n* A ChartControl representing the x-axis\n\n---\n\n* **chartScale**\n* A ChartScale representing the y-axis\n{% /table %}\n\n## Examples\n\n```csharp\npublic override void OnMouseDown(ChartControl chartControl, ChartPanel chartPanel, ChartScale chartScale, ChartAnchor dataPoint)**\n{\n  // get the point where the mouse was clicked\n  Point myPoint = dataPoint.GetPoint(chartControl, chartPanel, chartScale);\n\n  // create an anchor at that point\n  ChartAnchor MyAnchor = CreateAnchor(myPoint, chartControl, chartScale);\n\n  Print(MyAnchor.Time); // 3/16/2015 8:18:48 AM\n}\n```"
  }
]