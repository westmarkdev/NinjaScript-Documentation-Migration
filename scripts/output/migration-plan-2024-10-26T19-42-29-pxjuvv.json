[
  {
    "_id": "1f69494bb217ca805accc04b1b81eb060816399b373dd1bc75ceea9c46cd8f9a",
    "_type": "desktopSdkDoc",
    "title": "Creating Your Own AddOn Window",
    "pathName": "creating_your_own_addon_window",
    "parent": "addon_development_overview",
    "order": 0,
    "section": "guides",
    "markdown": "## The NTWindow Class\n\nThe **NTWindow** class allows you to quickly build windows using the same style and skin as other windows in NinjaTrader. An **NTWindow** does not contain user-interface functionality, but rather serves as a container for instances of **NTTabPage**, which will contain controls and functionality for the window.\n\n```csharp\n/* This is where we define our AddOn window. The actual content is contained inside the tabs of the window defined in a custom class inheriting from NTTabPage.\n    We must create a new window class which inherits from NTWindow for styling and implements the IWorkspacePersistence interface for the ability to save/restore from workspaces.*/\npublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence\n{\n   public AddOnFrameworkWindow()\n   {\n       // set Caption property (not Title), since Title is managed internally to properly combine selected Tab Header and Caption for display in the windows taskbar\n       // This is the name displayed in the top-left of the window\n       Caption = \"AddOn Framework\";\n \n       // Set the initial dimensions of the window\n       Width   = 1085;\n       Height = 900;\n   }\n} \n```\n\n## Using TabControl for Tab Functionality\n\nAfter declaring an **NTWindow**, you can enable tab functionality on it (creating new tabs, copying tabs, etc.). The process for implementing tab functionality must be done within the constructor for your **NTWindow**, using the following process:\n\n1. Instantiate a new **TabControl** object\n2. Call helper methods of the **TabControlManager** class, passing in your **TabControl** object as an argument, to enable specific functionality\n3. Use the same approach as #2 to set an **NTTabFactory** for your **TabControl** (see below for more information)\n4. Set the Content property of your **NTWindow** to your **TabControl**\n\n```csharp\npublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence\n{\n   public AddOnFrameworkWindow()\n   {\n       ...\n \n       // TabControl should be created for window content if tab features are wanted\n       TabControl tc = new TabControl();\n \n       // Attached properties defined in **TabControlManager** class should be set to achieve tab moving, adding/removing tabs\n       TabControlManager.SetIsMovable(tc, true);\n       TabControlManager.SetCanAddTabs(tc, true);\n       TabControlManager.SetCanRemoveTabs(tc, true);\n \n       // if ability to add new tabs is desired, **TabControl** has to have attached property \"Factory\" set.\n       TabControlManager.SetFactory(tc, new AddOnFrameworkWindowFactory());\n         \n       Content = tc;\n   }\n} \n```\n\nNote the instantiation of a new **AddOnFrameworkWindowFactory** in the example above. In this example, **AddOnFrameworkWindowFactory** is a custom class implementing the **INTTabFactory** interface. Within this class, the **CreateParentWindow()** and **CreateTabPage()** methods contained in **INTTabFactory** are hidden, as seen below:\n\n```csharp\n/* Class which implements **Tools.INTTabFactory** must be created and set as an attached property for **TabControl**\nin order to use tab page add/remove/move/duplicate functionality */\npublic class AddOnFrameworkWindowFactory : INTTabFactory\n{\n   // **INTTabFactory** member. Required to create parent window\n   public NTWindow CreateParentWindow()\n   {\n       return new AddOnFrameworkWindow();\n   }\n \n   // **INTTabFactory** member. Required to create tabs\n   public NTTabPage CreateTabPage(string typeName, bool isTrue)\n   {\n       return new NinjaTraderAddOnProject.AddOnPage();\n   }\n} \n```\n\n{% callout type=\"note\" %}\nTake note of the instantiation of the **AddOnPage** class in the example above. In our example, **AddOnPage** is a XAML-defined class. Thus, when **CreateTabPage()** is called on an instance of **AddOnFrameworkWindowFactory**, it instantiates our XAML-defined user interface. See below for more information on defining user interfaces in XAML.\n{% /callout %}\n\n## Creating an NTTabPage within an NTWindow\n\nWith an **NTWindow** defined and a **TabControl** set up, the next step is to instantiate an **NTTabPage** and add it to your **TabControl**. The first step is to define a class inheriting **NTTabPage** and implementing the **IInstrumentProvider** and **IIntervalProvider** interfaces to set up window-linking functionality.\n\n```csharp\n/* This is where we define the actual content of the tabs for our AddOn window.\n    Note: Class derived from **Tools.NTTabPage** has to be created if instrument link or interval link functionality is desired.\n    **Tools.IInstrumentProvider** and/or **Tools.IIntervalProvider** interface(s) should be implemented.\n    Also **NTTabPage** provides additional functionality for properly naming tab headers using properties and variables such as @FUNCTION, @INSTRUMENT, etc. */\npublic class AddOnFrameworkTab : NTTabPage, NinjaTrader.Gui.Tools.IInstrumentProvider, NinjaTrader.Gui.Tools.IIntervalProvider\n{\n   public AddOnFrameworkTab()\n   {\n       AddOnFrameworkWindowFactory myAddOnFrameworkWindowFactory = new AddOnFrameworkWindowFactory();\n \n       Content = myAddOnFrameworkWindowFactory.CreateTabPage(\"AddOnPage\",true);\n   }\n} \n```\n\nWith this class defined, the next step is to add it to your **TabControl**. You can do this via the **AddNTTabPage()** helper method contained in your **TabControl** object:\n\n```csharp\npublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence\n{\n   public AddOnFrameworkWindow()\n   {\n       ...\n \n       /* In order to have link buttons functionality, tab control items must be derived from **Tools.NTTabPage**\n       They can be added using extension method **AddNTTabPage(NTTabPage page)** */\n       tc.AddNTTabPage(new **AddOnFrameworkTab**());\n   }\n} \n```\n\n## Setting Up Workspace Persistence\n\nThe last step in setting up the foundation for your custom window is to configure it to be saved and restored in NinjaTrader workspaces.\n\n1. Hide the **WorkspaceOptions** property of the implemented **IWorkspacePersistence** interface\n2. Use a delegate to set the **WorkspaceOptions** property to a new instance of the **WorkspaceOptions** class inside the **NTWindow**'s constructor\n3. Hide the **Restore()** method of **IWorkspacePersistence** to call the static **RestoreFromXElement()** method on the **MainTabControl** property\n4. Hide the **Save()** method of **IWorkspacePersistence** to call the static **SaveToXElement** method in the same way\n\n```csharp\npublic class AddOnFrameworkWindow : NTWindow, IWorkspacePersistence\n{\n   public AddOnFrameworkWindow()\n   {\n       ...\n \n       // **WorkspaceOptions** property must be set\n       Loaded += (o, e) =>\n       {\n           if (WorkspaceOptions == null)\n               WorkspaceOptions = new WorkspaceOptions(\"AddOnFramework-\" + Guid.NewGuid().ToString(\"N\"), this);\n       };\n   }\n     \n   // **IWorkspacePersistence** member. Required for restoring window from workspace\n   public void Restore(XDocument document, XElement element)\n   {\n       if (MainTabControl != null)\n           MainTabControl.RestoreFromXElement(element);\n   }\n \n   // **IWorkspacePersistence** member. Required for saving window to workspace\n   public void Save(XDocument document, XElement element)\n   {\n       if (MainTabControl != null)\n           MainTabControl.SaveToXElement(element);\n   }\n \n   // **IWorkspacePersistence** member\n   public WorkspaceOptions WorkspaceOptions { get; set; }\n} \n```\n\n## Using XAML to Define Window Layout\n\nThere are two options available for laying out the user interface in your **NTTabPage**. The first is to use XAML, a markup language commonly used to define graphical interfaces in WPF applications. The process of pairing a XAML file with your C# classes is straightforward; simply create your XAML class in its own file within your project, and it can be packaged together with your C# code in a DLL.\n\n```xml\n<!-- Example of creating a two-column grid in XAML -->\n<grid background=\"Transparent\">\n    <!-- Define our layout with two columns. Rows can then be assigned to columns -->\n    <grid.columndefinitions>\n        <columndefinition width=\"55*\"></columndefinition>\n        <columndefinition width=\"45*\"></columndefinition>\n    </grid.columndefinitions>\n</grid> \n```\n\n## Using C# to Define Window Layout\n\nYou are not required to use XAML for window layout. You can code everything in C# if you choose. Defining user interface elements in C# is more verbose than XAML, but all of the same functionality is available. The example below shows the C# equivalent of the XAML code in the prior section.\n\n```csharp\n// Example of creating a two-column grid in C#\nGrid grid = new Grid();\ngrid.Background = new SolidColorBrush(Colors.Transparent);\n \nColumnDefinition col1 = new ColumnDefinition();\ncol1.Width = new GridLength(55);\n \nColumnDefinition col2 = new ColumnDefinition();\ncol2.Width = new GridLength(45);\n \ngrid.ColumnDefinitions.Add(col1);\ngrid.ColumnDefinitions.Add(col2); \n```\n\n## Launching Your Window From the Control Center\n\nOnce your window is set up and laid out, you will need a way to launch it from the Control Center. This can be done by adding a new item into one of the Control Center's menus (most commonly the New menu). This can be accomplished in four steps:\n\n1. Obtain a reference to the Control Center menu in question\n2. Instantiate an **NTMenuItem**\n3. Add your **NTMenuItem** into the menu\n4. Attach your **NTMenuItem**'s Click event to a custom event handler\n5. Use your custom event handler to launch your **NTWindow**\n\n```csharp\n// Will be called as a new NTWindow is created. It will be called in the thread of that window\nprotected override void OnWindowCreated(Window window)\n{\n     \n   // We want to place our AddOn in the Control Center's menus\n   ControlCenter cc = window as ControlCenter;\n   if (cc == null)\n       return;\n \n   /* Determine we want to place our AddOn in the Control Center's \"New\" menu\n    Other menus can be accessed via the control's \"Automation ID\". For example: toolsMenuItem, workspacesMenuItem, connectionsMenuItem, helpMenuItem. */\n   NTMenuItem existingMenuItemInControlCenter = cc.FindFirst(\"ControlCenterMenuItemNew\") as NTMenuItem;\n   if (existingMenuItemInControlCenter == null)\n       return;\n \n   // 'Header' sets the name of our AddOn seen in the menu structure\n   NTMenuItem addOnFrameworkMenuItem = new NTMenuItem { Header = \"AddOn Framework\", Style = Application.Current.TryFindResource(\"MainMenuItem\") as Style };\n \n   // Add our AddOn into the \"New\" menu\n   existingMenuItemInControlCenter.Items.Add(addOnFrameworkMenuItem);\n \n   // Subscribe to the event for when the user presses our AddOn's menu item\n   addOnFrameworkMenuItem.Click += OnMenuItemClick;\n}\n \n// Open our AddOn's window when the menu item is clicked on\nprivate void OnMenuItemClick(object sender, RoutedEventArgs e)\n{\n   Core.Globals.RandomDispatcher.BeginInvoke(new Action(() => new AddOnFrameworkWindow().Show()));\n} \n```\n\nAs always, it is important to unsubscribe from event handlers and dispose of unused resources when they are no longer needed. The **OnWindowDestroyed()** method can be used to clean up our work from the examples above:\n\n```csharp\n// Will be called as a new NTWindow is destroyed. It will be called in the thread of that window\nprotected override void OnWindowDestroyed(Window window)\n{\n   if (addOnFrameworkMenuItem != null && window is ControlCenter)\n   {\n       if (existingMenuItemInControlCenter != null && existingMenuItemInControlCenter.Items.Contains(addOnFrameworkMenuItem))\n           existingMenuItemInControlCenter.Items.Remove(addOnFrameworkMenuItem);\n \n       addOnFrameworkMenuItem.Click -= OnMenuItemClick;\n       addOnFrameworkMenuItem = null;\n   }\n} \n```\n\n## Adding NinjaTrader Custom Controls\n\nUser-interface controls, such as buttons, text fields, and dropdown menus can be defined via XAML (or C#), then behavior and functionality of those controls can be set via C# along with the core logic of your AddOn. In addition to the [standard WPF controls](standard_wpf_controls), the NinjaScript AddOn framework provides access to each of the custom NinjaTrader controls that can be found throughout the platform. Below is a list of the most commonly used NinjaTrader controls, along with examples of defining these controls in XAML and adding functionality to them in C#:\n\n### 1. The Instrument Selector\n\n![AddOns_InstrumentSelector](addons_instrumentselector.png)\n\n```xaml\n<!-- Instrument Selector Definition -->\n<t:instrumentselector grid.column=\"0\" grid.row=\"6\" instrumentchanged=\"OnInstrumentChanged\" lastusedgroup=\"AddOnFramework\" x:name=\"instrumentSelector\">\n    <t:instrumentselector.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginBase}\" top=\"{StaticResource PaddingColumn}\"></thickness>\n    </t:instrumentselector.margin>\n</t:instrumentselector> \n```\n\n```csharp\n// Using the Instrument Selector\nprivate InstrumentSelector instrumentSelector;\n \n...\n \n// Find instrument selector and attach event handler\ninstrumentSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"instrumentSelector\") as InstrumentSelector;\nif (instrumentSelector != null)\n   instrumentSelector.InstrumentChanged += OnInstrumentChanged; \n```\n\n### 2. The Interval Selector\n\n![AddOns_IntervalSelector](addons_intervalselector.png)\n\n```xaml\n<!-- Interval Selector Definition -->\n<t:intervalselector grid.column=\"0\" horizontalalignment=\"Left\" intervalchanged=\"OnIntervalChanged\" x:name=\"intervalSelector\">\n    <t:intervalselector.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginBase}\" top=\"{StaticResource PaddingColumn}\"></thickness>\n    </t:intervalselector.margin>\n</t:intervalselector> \n```\n\n```csharp\n// Using the Interval Selector\nprivate IntervalSelector intervalSelector;\n \n...\n \n// Find interval selector and attach event handler\nintervalSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"intervalSelector\") as IntervalSelector;\nif (intervalSelector != null)\n   intervalSelector.IntervalChanged += OnIntervalChanged; \n```\n\n### 3. The Quantity Up/Down Selector\n\n![AddOns_QuantitySelector](addons_quantityselector.png)\n\n```xaml\n<!-- Quantity Up/Down Selector Definition -->\n<t:quantityupdown grid.column=\"0\" grid.row=\"12\" value=\"1\" x:name=\"qudSelector\">\n    <t:quantityupdown.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginBase}\" top=\"{StaticResource MarginControl}\"></thickness>\n    </t:quantityupdown.margin>\n</t:quantityupdown> \n```\n\n```csharp\n// Using the Quantity Up/Down Selector\nprivate QuantityUpDown qudSelector;\n \n...\n \n// Find Quantity selector\nqudSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"qudSelector\") as QuantityUpDown; \n```\n\n### 4. The Time-in-Force Selector\n\n![AddOns_TifSelector](addons_tifselector.png)\n\n```xaml\n<!-- Time-in-Force Selector Definition -->\n<t:tifselector grid.column=\"1\" grid.row=\"12\" x:name=\"tifSelector\">\n    <t:tifselector.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginButtonLeft}\" right=\"0\" top=\"{StaticResource MarginControl}\"></thickness>\n    </t:tifselector.margin>\n</t:tifselector> \n```\n\n```csharp\n// Using the Time-in-Force Selector\nprivate TifSelector tifSelector;\n \n...\n \n// Find TIF selector\ntifSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"tifSelector\") as TifSelector;\n \n// Be sure to bind our account selector to our TIF selector to ensure proper functionality\ntifSelector.SetBinding(TifSelector.AccountProperty, new Binding { Source = accountSelector, Path = new PropertyPath(\"SelectedAccount\") });\n \n// When our TIF selector's selection changes\ntifSelector.SelectionChanged += (o, args) =>\n{\n   // Change the selected TIF in the ATM strategy too\n   if (atmStrategySelector.SelectedAtmStrategy != null)\n   {\n       atmStrategySelector.SelectedAtmStrategy.TimeInForce = tifSelector.SelectedTif;\n   }\n}; \n```\n\n### 5. The ATM Strategy Selector\n\n![AddOns_AtmSelector](addons_atmselector.png)\n\n```xaml\n<!-- ATM Strategy Selector Definition -->\n<atmstrategy:atmstrategyselector grid.column=\"2\" grid.row=\"12\" linkedquantity=\"{Binding ElementName=qudSelector, Path=Value, Mode=OneWay}\" x:name=\"atmStrategySelector\">\n    <atmstrategy:atmstrategyselector.margin>\n        <thickness bottom=\"0\" left=\"{StaticResource MarginButtonLeft}\" right=\"{StaticResource MarginBase}\" top=\"{StaticResource MarginControl}\"></thickness>\n    </atmstrategy:atmstrategyselector.margin>\n</atmstrategy:atmstrategyselector> \n```\n\n#### Using the ATM Strategy Selector\n\n```csharp\nprivate AtmStrategy.AtmStrategySelector atmStrategySelector;\n\n \n...\n \n// Find ATM Strategy selector and attach event handler\natmStrategySelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"atmStrategySelector\") as AtmStrategy.AtmStrategySelector;\natmStrategySelector.Id = Guid.NewGuid().ToString(\"N\");\nif (atmStrategySelector != null)\n   atmStrategySelector.CustomPropertiesChanged += OnAtmCustomPropertiesChanged;\n \n// Be sure to bind our account selector to our ATM strategy selector to ensure proper functionality\natmStrategySelector.SetBinding(AtmStrategy.AtmStrategySelector.AccountProperty, new Binding { Source = accountSelector, Path = new PropertyPath(\"SelectedAccount\") });\n \n// When our ATM selector's selection changes\natmStrategySelector.SelectionChanged += (o, args) =>\n{\n   if (atmStrategySelector.SelectedItem == null)\n       return;\n   if (args.AddedItems.Count > 0)\n   {\n       // Change the selected TIF in our TIF selector too\n       NinjaTrader.NinjaScript.AtmStrategy selectedAtmStrategy = args.AddedItems[0] as NinjaTrader.NinjaScript.AtmStrategy;\n       if (selectedAtmStrategy != null)\n       {\n           tifSelector.SelectedTif = selectedAtmStrategy.TimeInForce;\n       }\n   }\n}; \n```\n\n## Linking with Other Windows\n\nIf you utilize NinjaTrader controls to allow selection of instruments or intervals, you can add instrument or interval linking functionality to your window. The **PropagateInstrumentChange()** and **PropagateIntervalChange()** methods can be used to accomplish this. To call **PropagateIntervalChange()**, use the process below:\n\n1. Hide the **Instrument** property of the **IInstrumentProvider** interface, which your **NTTabPage** inheriting class should be implementing\n2. Call **PropagateInstrumentChange()** within the setter for the hidden **Instrument** property\n\n```csharp\n// **IInstrumentProvider** member. Required if you want to use the instrument link mechanism on this window.\npublic **Cbi.Instrument** Instrument\n{\n   get { return instrument; }\n   set\n   {\n       // Send instrument to other windows linked to the same color\n       PropagateInstrumentChange(value);\n   }\n} \n```\n\nIn a real-world scenario, you would most likely use an instrument selector to call the setter for the **Instrument** property. Thus, when a user toggled the instrument selector, **PropagateInstrumentChange()** would be called in addition to any other logic you put in place. In the same way, you can use an interval selector to push changes to the Interval Linking feature. In this case, you can attach a custom event handler to an interval selector's **IntervalChanged** event, then call **PropagateIntervalChange()** within that event handler:\n\n```csharp\n...\n \n// Find an interval selector that we've added to our UI, and attach a custom event handler\nintervalSelector = LogicalTreeHelper.FindLogicalNode(pageContent, \"intervalSelector\") as IntervalSelector;\nif (intervalSelector != null)\n   intervalSelector.IntervalChanged += OnIntervalChanged;\n     \n...\n \n// This method is fired when our interval selector changes intervals\nprivate void OnIntervalChanged(object sender, BarsPeriodEventArgs args)\n{\n   if (args.BarsPeriod == null)\n       return;\n \n   PropagateIntervalChange(args.BarsPeriod); \n} \n```"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "advanced_custom_drawing",
    "order": 0,
    "section": "guides",
    "markdown": "## Entering Calculation Logic\n\nThe **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method called for indicator calculation, and we will calculate the CCI value and set the conditions used to draw the CCI plot within this method.\n\nThe **OnStateChange()** method is called once before any bar data is loaded, and is used to configure the indicator (among other things).\n\n## Initializing the Indicator  \n\nThe code below is automatically generated by the wizard and added to the **OnStateChange()** method, within **State.SetDefaults**. It configures the indicator for one plot and five lines, and sets the parameters entered in the wizard:\n\n```csharp\nAddPlot(Brushes.Orange, \"MyPlot\");\nAddLine(Brushes.DimGray, 200, \"Level 2\");\nAddLine(Brushes.DimGray, 100, \"Level 1\");\nAddLine(Brushes.DimGray, 0, \"Zero Line\");\nAddLine(Brushes.DimGray, -100, \"Level -1\");\nAddLine(Brushes.DimGray, -200, \"Level -2\");\n````\n\nTo change the visual properties of the Zero Line, replace the fourth line in the code above with the line below. This will change the color to black and the line style to \"dash:\"\n\n```csharp\n\n* AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n```\n\nThe code above uses an alternative method overload (an alternative set of arguments passed in to the **AddLine()** method), in order to pass in a **Stroke** object rather than a **Brush**. With a Stroke, not only can we still specify a Brush, but we have additional options to change the dash style (via **DashStyleHelper**) and the line width. After this change, your configured lines and plots should look like this:\n\n```csharp\nAddPlot(Brushes.Orange, \"MyCCI_Plot\");\nAddLine(Brushes.DimGray, 200, \"Level 2\");\nAddLine(Brushes.DimGray, 100, \"Level 1\");\nAddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\nAddLine(Brushes.DimGray, -100, \"Level -1\");\nAddLine(Brushes.DimGray, -200, \"Level -2\");\n```\n\n## Adding Core Indicator Logic\n\nSince this tutorial is meant to cover custom drawing and manually changing properties within an indicator, we will not go too in-depth into the core calculation logic for this custom CCI. Instead, we will copy and paste the core calculation logic from the **@CCI** indicator already built-in to NinjaTrader.\n\nThe **@CCI** indicator uses an **SMA** object in its calculations. To add this, copy the line below from **@CCI** into your custom CCI, directly below the class declaration:\n\n```csharp\nprivate SMA sma;\n```\n\nNext, copy the following initialization for the **SMA** object into the **OnStateChange()** method, within **State.DataLoaded**:\n\n```csharp\n\nsma = SMA(Typical, Period);\n```\n\nNext, copy the core calculation logic from **@CCI** into the **OnBarUpdate()** method of your custom indicator:\n\n```csharp\nif (CurrentBar == 0)\n   Value[0] = 0;\nelse\n{\n   double mean = 0;\n   double sma0 = sma[0];\n\n   for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n       mean += Math.Abs(Typical[idx] - sma0);\n\n   Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n}\n```\n\nThe code for your **MyCCI** class should now look as follows (in addition to the using statements and class declaration):\n\n```csharp\n\npublic class MyCCI : Indicator\n{\n   private SMA sma;\n\n   protected override void OnStateChange()\n   {\n       if (State == State.SetDefaults)\n       {\n           Description = @\"NinjaScript Custom Drawing Indicator Tutorial\";\n           Name = \"MyCCI\";\n           Calculate = Calculate.OnBarClose;\n           IsOverlay = false;\n           DisplayInDataBox = true;\n           DrawOnPricePanel = true;\n           DrawHorizontalGridLines = true;\n           DrawVerticalGridLines = true;\n           PaintPriceMarkers = true;\n           ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;\n           IsSuspendedWhileInactive = true;\n           Period = 14;\n           AddPlot(Brushes.Orange, \"MyPlot\");\n           AddLine(Brushes.DimGray, 200, \"Level 2\");\n           AddLine(Brushes.DimGray, 100, \"Level 1\");\n           AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n           AddLine(Brushes.DimGray, -100, \"Level -1\");\n           AddLine(Brushes.DimGray, -200, \"Level -2\");\n       }\n       else if (State == State.DataLoaded)\n       {\n           sma = SMA(Typical, Period);\n       }\n   }\n\n   protected override void OnBarUpdate()\n   {\n       if (CurrentBar == 0)\n           Value[0] = 0;\n       else\n       {\n           double mean = 0;\n           double sma0 = sma[0];\n\n           for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n               mean += Math.Abs(Typical[idx] - sma0);\n\n           Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n       }\n   }\n}\n```\n\n## Custom Drawing  \n\nAdd the following code into the **OnBarUpdate()** method, directly beneath the core calculation logic:\n\n```csharp\n\n// if the plot value is greater than 100, paint the plot green at that bar index\nif (Value[0] > 100)\n   PlotBrushes[0][0] = Brushes.Green;\n\n// if the plot value is less than -100, paint the plot red at that bar index\nif (Value[0] < -100)\n   PlotBrushes[0][0] = Brushes.Red;\n\n// if the plot value is between 100 and -100, paint the plot orange at that bar index\nif (Value[0] >= -100 && Value[0] <= 100)\n   PlotBrushes[0][0] = Brushes.Orange;\n```\n\nThis will conditionally change the color of the CCI plot (referenced by **Values[0]**) based on its value. By using **PlotBrushes[0][0]**, we are specifying that we wish to change the color of the first plot in the collection at a specific bar index (the current bar index each time the condition is triggered), and we wish for the plot to remain that color at that index, even if the plot value changes in the future. If instead we wished to change the entire plot color, we could use **Plots[0].Brush**.\n\n**PlotBrushes** holds a collection of brushes used for the various plots in the indicator. In addition to this, there are several other collections that serve similar purposes, which can be used in the same way. Some examples of these collections are below:\n\n{% table %}\n\n* Collection | Description\n\n---\n\n* [BackBrushes](backbrushes.htm) | A collection of Brushes used for chart background color at specific bar indexes\n* [BarBrushes](barbrushes.htm) | A collection of Brushes used to paint bars at specific indexes\n* [CandleOutlineBrushes](candleoutlinebrushes.htm) | A collection of Brushes used to paint candle outlines at specific indexes\n{% /table %}\n\nNow that everything is in place, your class code should look as below. You are now ready to [compile the indicator](compiling6.htm) and configure it on a chart.\n\n```csharp\n\npublic class MyCCI : Indicator\n{\n   private SMA sma;\n\n   protected override void OnStateChange()\n   {\n       if (State == State.SetDefaults)\n       {\n           Description = @\"NinjaScript Custom Drawing Indicator Tutorial\";\n           Name = \"MyCCI\";\n           Calculate = Calculate.OnBarClose;\n           IsOverlay = false;\n           DisplayInDataBox = true;\n           DrawOnPricePanel = true;\n           DrawHorizontalGridLines = true;\n           DrawVerticalGridLines = true;\n           PaintPriceMarkers = true;\n           ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;\n           IsSuspendedWhileInactive = true;\n           Period = 14;\n           AddPlot(Brushes.Orange, \"MyPlot\");\n           AddLine(Brushes.DimGray, 200, \"Level 2\");\n           AddLine(Brushes.DimGray, 100, \"Level 1\");\n           AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n           AddLine(Brushes.DimGray, -100, \"Level -1\");\n           AddLine(Brushes.DimGray, -200, \"Level -2\");\n       }\n       else if (State == State.DataLoaded)\n       {\n           sma = SMA(Typical, Period);\n       }\n   }\n\n   protected override void OnBarUpdate()\n   {\n       if (CurrentBar == 0)\n           Value[0] = 0;\n       else\n       {\n           double mean = 0;\n           double sma0 = sma[0];\n\n           for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n               mean += Math.Abs(Typical[idx] - sma0);\n\n           Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n       }\n\n       if (Value[0] > 100)\n           PlotBrushes[0][0] = Brushes.Green;\n\n       if (Value[0] < -100)\n           PlotBrushes[0][0] = Brushes.Red;\n\n       if (Value[0] >= -100 && Value[0] <= 100)\n           PlotBrushes[0][0] = Brushes.Orange;\n   }\n\n   #region Properties\n   [NinjaScriptProperty]\n   [Range(1, int.MaxValue)]\n   [Display(Name=\"Period\", Description=\"The CCI Period\", Order=1, GroupName=\"Parameters\")]\n   public int Period\n   { get; set; }\n\n   [Browsable(false)]\n   [XmlIgnore]\n   public Series<double> MyPlot\n   {\n       get { return Values[0]; }\n   }\n   #endregion\n}\n```"
  },
  {
    "_id": "aba73bf1f1c07b2d35c9b2f14b7ae04b571db42bb9659de08e4b3f5efddc43fe",
    "_type": "desktopSdkDoc",
    "title": "Advanced - Custom Drawing",
    "pathName": "advanced_custom_drawing",
    "parent": "developing_indicators",
    "order": 0,
    "section": "guides",
    "markdown": "## Custom Drawing Overview\n\nIn this advanced tutorial, we are going to build a custom indicator which is a variation on the CCI, to show different drawing options for bar color, line color, and background color.\n\n* [Set Up](set_up9)\n* [Entering Calculation Logic](entering_calculation_logic6)\n* [Compiling](compiling6)\n* [Using](using6)\n\n{% callout type=\"note\" %}\n\nPlease note that the JavaScript code and HTML artifacts have been removed as per the instructions.\n{% /callout %}"
  },
  {
    "_id": "08ff2f1125f8035054bbb835909111bf9060904444bed8309ec59a88c617bf77",
    "_type": "desktopSdkDoc",
    "title": "Beginner - Indicator on Indicator",
    "pathName": "beginner_indicator_on_indicator",
    "parent": "developing_indicators",
    "order": 0,
    "section": "guides",
    "markdown": "## Indicator on Indicator Overview\r\n\r\nIn this beginner level tutorial we are going to build a custom indicator that calculates a moving average of volume. This indicator will show you how to use the built in indicators of [Moving Average (SMA)](moving_average_-_simple_sma) and [Volume](volume.md).\r\n\r\n* [Set Up](set_up5)\r\n* [Entering Calculation Logic](entering_calculation_logic2)\r\n* [Compiling](compiling2)\r\n* [Using](using2)"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "developing_indicators",
    "order": 0,
    "section": "guides",
    "markdown": "The **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (testing to see if a Close price on a specified bar was greater than the previous Close price) within this method.\r\n\r\n## Adding the Condition and Assigning the Plot Value\r\n\r\nEnter the following code in the **OnBarUpdate()** method in the NinjaScript Editor:\r\n\r\n```csharp\r\nValues[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize))\r\n```\r\n\r\nAlthough the code above fits on a single line, it is doing several things. Firstly, it is important to understand the structure that we are using in this statement. We are using a **Ternary Operator**, which provides a way to assign one of two values to a variable based on a condition. We begin by stating that we wish to assign a value to the indicator plot at a bar index corresponding to **BarsAgo**. We do this by using **Values**, which is a collection holding values for all plots configured in the indicator:\r\n\r\n```csharp\r\n Values[0][BarsAgo] =\r\n```\r\n\r\nNext, we add a condition to test. In this case, we are testing to see whether **Close** at a bar index corresponding to the value of **BarsAgo** was greater than **Close** at a value of **BarsAgo + 1**. If **BarsAgo** was set to 5, for example, this would compare **Close[5]** to **Close[6]**:\r\n\r\n```csharp\r\nValues[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ?\r\n```\r\n\r\nIf the condition evaluates to true, then the first expression will be run (the expression on the left side of the colon \":\"), which will assign the value of the indicator plot to the **High** price of the specified bar, plus five ticks. We obtain the tick size value for the configured instrument via the **TickSize** property:\r\n\r\n```csharp\r\nValues[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 * TickSize)) :\r\n```\r\n\r\nIf the condition evaluates to false, then the second expression will be run (the expression on the right side of the colon \":\", which will assign the value of the indicator plot to the **Low** price of the specified bar, less five ticks:\r\n\r\n```csharp\r\nValues[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 *TickSize)) : (Low[BarsAgo] - (5* TickSize))\r\n```\r\n\r\nThe core indicator logic is now in place, but running this code as it is can result in an \"Index out of range\" exception. Since we are looking a certain number of bars back in time, we need to make sure that there are always enough bars on the chart for us to look back. For example, if **BarsAgo** were set to 5, then we would be comparing the value of five bars ago to the value of six bars ago, but on Bars # 1, 2, 3, 4, or 5, at which point we do not have five or six bars to look back, the indicator will cause an error. To resolve this, we will add a condition which will prevent the core calculations from running unless we know there are enough bars on the chart. Add the following line just above the line you have been working on throughout this page:\r\n\r\n```csharp\r\nif(CurrentBar < BarsAgo + 1)\r\n   return;\r\n```\r\n\r\nThis line says, \"if there is not a number of bars equal to one number greater than the value of **BarsAgo**, then exit **OnBarUpdate()**.\"\r\n\r\nNow that everything is in place, your class code should look as below. You are now ready to **compile the indicator** and configure it on a chart:\r\n\r\n```csharp\r\npublic class PriceVariableTutorial : Indicator\r\n{\r\n   protected override void OnStateChange()\r\n   {\r\n       if (State == State.SetDefaults)\r\n       {\r\n           Description                     = @\"NinjaScript Price Variables Tutorial\";\r\n           Name                           = \"PriceVariableTutorial\";\r\n           Calculate                       = Calculate.OnBarClose;\r\n           IsOverlay                       = false;\r\n           DisplayInDataBox               = true;\r\n           DrawOnPricePanel               = true;\r\n           DrawHorizontalGridLines         = true;\r\n           DrawVerticalGridLines           = true;\r\n           PaintPriceMarkers               = true;\r\n           ScaleJustification               = NinjaTrader.Gui.Chart.ScaleJustification.Right;\r\n           //Disable this property if your indicator requires custom values that cumulate with each new market data event.\r\n           //See Help Guide for additional information.\r\n           IsSuspendedWhileInactive       = true;\r\n           BarsAgo                         = 0;\r\n           AddPlot(Brushes.Orange, \"MyPlot\");\r\n       }\r\n       else if (State == State.Configure)\r\n       {\r\n       }\r\n   }\r\n\r\n   protected override void OnBarUpdate()\r\n   {\r\n       if(CurrentBar < BarsAgo + 1)\r\n           return;\r\n\r\n       Values[0][BarsAgo] = (Close[BarsAgo] > Close[(BarsAgo + 1)]) ? (High[BarsAgo] + (5 * TickSize)) : (Low[BarsAgo] - (5 * TickSize));\r\n   }\r\n\r\n   #region Properties\r\n   [Range(0, int.MaxValue)]\r\n   [NinjaScriptProperty]\r\n   [Display(Name=\"BarsAgo\", Description=\"How many bars ago to use for the plot value\", Order=1)]\r\n   public int BarsAgo\r\n   { get; set; }\r\n\r\n   [Browsable(false)]\r\n   [XmlIgnore]\r\n   public Series<double> MyPlot\r\n   {\r\n       get { return Values[0]; }\r\n   }\r\n   #endregion\r\n}\r\n```"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "developing_indicators",
    "order": 0,
    "section": "guides",
    "markdown": "The **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (calculating an average of volume) within this method.\n\n## Calculating the Average\n\nNinjaTrader has built in indicators that you can reference in your calculations. Since we are calculating a simple moving average of volume it would make sense for us to use the built in SMA indicator and Volume indicators.\n\nEnter the following code into the **OnBarUpdate()** method in the NinjaScript Editor:\n\n```csharp\n// Calculate the volume average\ndouble average = SMA(VOL(), Periods)[0];\n```\n\nHere we declared the variable \"average\" which is of type double. This serves as the temporary storage for the current value of the simple moving average of volume. We then use the simple moving average indicator and pass in the volume indicator as its input, pass in our indicator \"Periods\" property (a parameter we defined in the wizard) and access the current value \"[0]\" that we will assign to our variable \"average\". If we wanted to assign the value one bar ago, we could have used \"[1]\".\n\n## Final Assignment\n\nEnter the following code into the **OnBarUpdate()** method and below the code snippet you entered above:\n\n```csharp\n// Set the calculated value to the plot\nMyPlot[0] = average;\n```\n\nHere we assign the \"average\" value to the property that represents the plot data using the '=' assignment operator. We have just finished coding our simple moving average of volume. Your class code should look identical to the code below. You are now ready to [compile the indicator](compiling2) and configure it on a chart.\n\n```csharp\npublic class VolSMA : Indicator\n{\n   protected override void OnStateChange()\n   {\n     if (State == State.SetDefaults)\n     {\n         Description                     = @\"Moving average of volume\";\n         Name                             = \"VolSMA\";\n         Calculate                         = Calculate.OnBarClose;\n         IsOverlay                         = false;\n         DisplayInDataBox                 = true;\n         DrawOnPricePanel                 = true;\n         DrawHorizontalGridLines           = true;\n         DrawVerticalGridLines             = true;\n         PaintPriceMarkers                 = true;\n         ScaleJustification               = NinjaTrader.Gui.Chart.ScaleJustification.Right;\n         //Disable this property if your indicator requires custom values that cumulate with each new market data event. \n         //See Help Guide for additional information.\n         IsSuspendedWhileInactive         = true;\n         Periods                           = 10;\n         AddPlot(Brushes.Orange, \"MyPlot\");\n     }\n     else if (State == State.Configure)\n     {\n     }\n   }\n   protected override void OnBarUpdate()\n   {\n     // Calculate the volume average\n     double average = SMA(VOL(), Periods)[0];\n     // Set the calculated value to the plot\n     MyPlot[0] = average;\n   }\n   #region Properties\n   [NinjaScriptProperty]\n   [Range(1, int.MaxValue)]\n   [Display(Name=\"Periods\", Description=\"Number of periods\", Order=1, GroupName=\"Parameters\")]\n   public int Periods\n   { get; set; }\n   [Browsable(false)]\n   [XmlIgnore]\n    public Series<double> MyPlot\n   {\n     get { return Values[0]; }\n   }\n   #endregion\n```"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "developing_indicators",
    "order": 0,
    "section": "guides",
    "markdown": "## Entering Calculation Logic\r\n\r\nThe **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate a simple moving average.\r\n\r\n## Are there enough bars?\r\n\r\nEnter the following code into the **OnBarUpdate()** method in the NinjaScript Editor:\r\n\r\n```csharp\r\n// Do not calculate if we don't have enough bars \r\nif (CurrentBar < Period) return;\r\n```\r\n\r\nTo calculate a 20 period moving average you will need a minimum of 20 bars of data. The first statement in our **OnBarUpdate()** method checks to see if there are enough bars of data to perform the moving average calculation. **CurrentBar** returns the index number of the current bar and this is checked against the user-defined parameter **Period**. If the current bar number is less than the user-defined period we \"return\" which skips calculating the moving average.\r\n\r\n## Getting a sum of closing prices\r\n\r\nEnter the following code into the **OnBarUpdate()** method and below the code snippet you entered above:\r\n\r\n```csharp\r\n// Get a sum of prices over the specified period\r\ndouble sum = 0; \r\nfor (int barsAgo = 0; barsAgo < Period; barsAgo++) \r\n{ \r\n   sum = sum + Input[barsAgo]; \r\n}\r\n```\r\n\r\nFirst we must declare a variable that will store our sum total.\r\n\r\n```csharp\r\ndouble sum = 0;\r\n```\r\n\r\nThe variable **sum** whose value is of type **double** will serve as temporary storage.\r\n\r\n```csharp\r\nfor (int barsAgo = 0; barsAgo < Period; barsAgo++) \r\n{ \r\n   sum = sum + Input[barsAgo]; \r\n}\r\n```\r\n\r\nNext we must calculate the sum. We use a standard \"for\" loop to skip through prices and add them to the **sum** variable. Although the command that represents the loop may look intimidating, it's really quite simple. Let's look at it in English....\r\n\r\nWhat the loop is saying is:\r\n\r\n1. the number of bars ago is now zero\r\n2. as long as the number of bars ago is less than the moving average period, then go to line 3 otherwise this loop is finished\r\n3. get the price **Input[number of bars ago]** and add it to the running sum total\r\n4. add one to the number of bars ago (if number of bars ago was zero it will now be one)\r\n5. go to line 2\r\n\r\nYou can find more information on [how loops work here](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements). Once the loop has finished, it will have calculated the total sum of closing prices for the period of our moving average.\r\n\r\n* We use the value of **Input[barsAgo]** to get a price to use for our calculation. We could have substituted **Close[barsAgo]** to use closing prices or **High[barsAgo]** to use high prices. The reason we use **Input[barsAgo]** is since this allows flexibility for what the indicator is calculated based off of. Remember users have the option to select a price type (High, Open, Close etc...) from the Indicator Dialog window.\r\n\r\n## The final calculation\r\n\r\nEnter the following code into the **OnBarUpdate()** method and below the code snippet you entered above:\r\n\r\n```csharp\r\n// Calculate and set the average value to the 'MyPlot' property\r\nMyPlot[0] = sum / Period;\r\n```\r\n\r\nWe can now calculate the final moving average value and assign its value to the property that represents the plot data. We have just finished coding our simple moving average. The class code in your editor should look identical to the image below. You are now ready to [compile the indicator](compiling3).\r\n\r\n```csharp\r\npublic class MySMA : Indicator\r\n{\r\n   protected override void OnStateChange()\r\n   {\r\n     if (State == State.SetDefaults)\r\n     {\r\n         Description                     = @\"Simple Moving Average\";\r\n         Name                             = \"MySMA\";\r\n         Calculate                         = Calculate.OnBarClose;\r\n         IsOverlay                         = true;\r\n         DisplayInDataBox                 = true;\r\n         DrawOnPricePanel                 = true;\r\n         DrawHorizontalGridLines           = true;\r\n         DrawVerticalGridLines             = true;\r\n         PaintPriceMarkers                 = true;\r\n         ScaleJustification               = NinjaTrader.Gui.Chart.ScaleJustification.Right;\r\n         //Disable this property if your indicator requires custom values that cumulate with each new market data event. \r\n         //See Help Guide for additional information.\r\n         IsSuspendedWhileInactive         = true;\r\n         Period                           = 20;\r\n         AddPlot(Brushes.Orange, \"MyPlot\");\r\n     }\r\n     else if (State == State.Configure)\r\n     {\r\n     }\r\n   }\r\n\r\n   protected override void OnBarUpdate()\r\n   {\r\n     // Do not calculate if we don't have enough bars \r\n     if (CurrentBar < Period) return;\r\n       \r\n     // Get a sum of prices over the specified period\r\n     double sum = 0; \r\n     for (int barsAgo = 0; barsAgo < Period; barsAgo++) \r\n     { \r\n         sum = sum + Input[barsAgo]; \r\n     }\r\n       \r\n     // Calculate and set the average value to the 'MyPlot' property\r\n     MyPlot[0] = sum / Period;\r\n   }\r\n\r\n   #region Properties\r\n   [NinjaScriptProperty]\r\n   [Range(1, int.MaxValue)]\r\n   [Display(Name=\"Period\", Description=\"Number of Periods\", Order=1, GroupName=\"Parameters\")]\r\n   public int Period\r\n   { get; set; }\r\n\r\n   [Browsable(false)]\r\n   [XmlIgnore]\r\n   public Series<double> MyPlot\r\n   {\r\n     get { return Values[0]; }\r\n   }\r\n   #endregion\r\n}\r\n```\r\n\r\n## Alternate Implementation\r\n\r\nIn this tutorial we are using a \"for\" loop to iterate through a collection of prices and accumulate a sum value. We chose this approach to demonstrate the use of a loop. A simple moving average can actually be expressed in a more efficient manner using the built-in **SUM** indicator as shown below.\r\n\r\n```csharp\r\n// Do not calculate if we don't have enough bars\r\nif (CurrentBar < Period) return;\r\n\r\n// Calculate and set the 'average' value to the 'MyPlot' property\r\nMyPlot[0] = SUM(Input, Period)[0] / Period;\r\n```"
  },
  {
    "_id": "7781b9b3e3cdd3e61ceb81d160f0a08c196a54bb8d078a9b10b88999b09344c3",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic",
    "parent": "developing_indicators",
    "order": 0,
    "section": "guides",
    "markdown": "The OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations and is called on each bar of a data series when re-calculating the indicator. For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed. Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate the ROC value.\r\n\r\n## Setting Plot Thresholds  \r\n\r\nThe OnStateChange() method is called once before any bar data is loaded and is used to configure the indicator. The code below is automatically generated by the wizard and added to the OnStateChange() method. It configures the indicator for two plots and one line and sets the parameters.\r\n\r\n```csharp\r\nAddLine(Brushes.Black, 0, \"ZeroLine\");\r\nAddPlot(Brushes.Green, \"AboveZero\");\r\nAddPlot(Brushes.OrangeRed, \"BelowZero\");\r\n```\r\n\r\nEnter the following code in the OnStateChange() method and below the wizard generated code:\r\n\r\n```csharp\r\n// Set the threshold values for each plot\r\nPlots[0].Min = 0;\r\nPlots[1].Max = 0;\r\n```\r\n\r\nThe concept of setting threshold values is to set when and when not to paint a plot on the chart. In this indicator, we have an \"AboveZero\" plot with a default color of green which we only want to see when the value of ROC is above zero and a \"BelowZero\" plot with a default color of OrangeRed which we only want to see when the value of ROC is below zero. In order to make that happen we have to set the threshold values of each plot.\r\n\r\n**Plots[0].Min = 0;**\r\n\r\nThis statement says, in the collection of Plot objects, take the first one (**Plots[0]**) and set its minimum value to zero. This means any value below zero will not display.\r\n\r\n**Plots[1].Max = 0;**\r\n\r\nThis statement says, in the collection of Plot objects, take the second one (**Plots[1]**) and set its maximum value to zero. This means any value above zero will not display.\r\n\r\nWe now have a simple plot switching mechanism that displays the correct colored line depending on if the value of ROC is above or below zero. In fact, you can take this concept a little bit farther. You can even set different plots style (bar, dot etc..) depending on threshold values.\r\n\r\nA quick word about collections. Collections are objects that store a collection of objects, kind of like a container. In this case we are working with a collection of plots. In the above wizard generated code you will notice that we are adding new plots to the \"Plots\" collection. \"AboveZero\" was added first and then \"BelowZero\". This means that we can reference the \"AboveZero\" plot object through **Plots[0]**. The reason we don't pass in a value of 1 is because collections are zero based indexes. This means the first item has an index of 0, the second time an index of 1 and so forth.\r\n\r\n## Completing the Indicator\r\n\r\nThis indicator is actually quite simple in its implementation. The last thing we need to do is add the calculation code and set the value of ROC to both our plot lines.\r\n\r\nReplace the wizard generated code with the following code into the OnBarUpdate() method in the NinjaScript Editor:\r\n\r\n```csharp\r\n\r\n// Are there enough bars\r\nif (CurrentBar < Period) return;\r\n\r\n// Set the plot values\r\nAboveZero[0] = SMA(ROC(Period), Smooth)[0];\r\nBelowZero[0] = SMA(ROC(Period), Smooth)[0];\r\n```\r\n\r\nThe calculation first checks to ensure there are enough bars to complete the calculation and then sets both plot lines to the ROC value.\r\n\r\nThe class code in your editor should look identical to the image below. You are now ready to [compile the indicator](compiling) and configure it on a chart.\r\n\r\n```csharp\r\n\r\npublic class CustomROC : Indicator\r\n{\r\n    protected override void OnStateChange()\r\n    {\r\n        if (State == State.SetDefaults)\r\n        {\r\n            Description = @\"ROC with custom line color options\";\r\n            Name = \"CustomROC\";\r\n            Calculate = Calculate.OnBarClose;\r\n            IsOverlay = false;\r\n            DisplayInDataBox = true;\r\n            DrawOnPricePanel = true;\r\n            DrawHorizontalGridLines = true;\r\n            DrawVerticalGridLines = true;\r\n            PaintPriceMarkers = true;\r\n            ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;\r\n            //Disable this property if your indicator requires custom values that cumulate with each new market data event.\r\n            //See Help Guide for additional information.\r\n            IsSuspendedWhileInactive = true;\r\n            Period = 14;\r\n            Smooth = 3;\r\n            AddLine(Brushes.Black, 0, \"ZeroLine\");\r\n            AddPlot(Brushes.Green, \"AboveZero\");\r\n            AddPlot(Brushes.OrangeRed, \"BelowZero\");\r\n            Plots[0].Min = 0;\r\n            Plots[1].Max = 0;\r\n        }\r\n        else if (State == State.Configure)\r\n        {\r\n        }\r\n    }\r\n\r\n    protected override void OnBarUpdate()\r\n    {\r\n        // Are there enough bars\r\n        if (CurrentBar < Period) return;\r\n\r\n        // Set the plot values\r\n        AboveZero[0] = SMA(ROC(Period), Smooth)[0];\r\n        BelowZero[0] = SMA(ROC(Period), Smooth)[0];\r\n    }\r\n\r\n    #region Properties\r\n    [NinjaScriptProperty]\r\n    [Range(1, int.MaxValue)]\r\n    [Display(Name=\"Period\", Description=\"Number of periods\", Order=1, GroupName=\"Parameters\")]\r\n    public int Period\r\n    { get; set; }\r\n\r\n    [NinjaScriptProperty]\r\n    [Range(1, int.MaxValue)]\r\n    [Display(Name=\"Smooth\", Description=\"Smoothing rate\", Order=2, GroupName=\"Parameters\")]\r\n    public int Smooth\r\n    { get; set; }\r\n\r\n    [Browsable(false)]\r\n    [XmlIgnore]\r\n    public Series<double> AboveZero\r\n    {\r\n        get { return Values[0]; }\r\n    }\r\n\r\n    [Browsable(false)]\r\n    [XmlIgnore]\r\n    public Series<double> BelowZero\r\n    {\r\n        get { return Values[1]; }\r\n    }\r\n    #endregion\r\n}\r\n\r\n```"
  },
  {
    "_id": "fef3e6c716dd0c8b595877b84cfca557a1c9229c52baf72d6b12639a4080edef",
    "_type": "desktopSdkDoc",
    "title": "Developing Indicators",
    "pathName": "developing_indicators",
    "parent": "educational_resources",
    "order": 0,
    "section": "guides",
    "markdown": "Indicators are the building blocks of any automated trading system. NinjaScript allows you to develop custom indicators quickly. A few key points are:\n\n* Custom indicators are compiled and run natively within the NinjaTrader application, providing the highest performance possible\n* Indicator values are calculated at the current bar, which ensures that you do not accidentally include future data in your calculations\n* You can retain calculations between bar updates\n* You can retain and share calculation values between bar updates and across indicators\n\nCustom indicator development follows a logical progression.\n\n## Wizard\n\nThe wizard allows you to define your overall indicator parameters which include name, properties, inputs, plots and oscillator lines. The wizard will then generate the necessary NinjaScript code and open up the NinjaScript [Editor](ninjascript_editor_overview.md).\n\n## OnStateChange() Method\n\nThe [OnStateChange()](onstatechange) method is called once before any initial calculation triggered by an update bar event. This method is used to configure the indicators plots, lines and properties. The wizard will generate the required NinjaScript code for this method for most cases.\n\n## OnBarUpdate() Method\n\nThe [OnBarUpdate()](onbarupdate) method is called with either with each incoming tick or on the close of each bar, depending on how you deploy the indicator at run time. Your core indicator calculation logic is contained within this method.\n\n## Debug\n\nThe NinjaScript Editor will perform both syntax and semantic checks and list any errors at the bottom of the window. If there are logic problems with your indicator, they will be listed in the [Log tab](log_tab2) of the NinjaScript [Control Center](control_center) during run time. You can use the **Print()** method within your script to help debug your code. Output will be sent to the NinjaScript Output window.\n\n## Compilation\n\nOnce the coding effort is completed, you must then compile the indicator (several second process) directly from the NinjaScript Editor.\n\n## Usage\n\nThe completed indicator is now available through any window that can use an indicator, such as a [Chart](charts).\n\n## Tutorial Descriptions\n\nAll internal NinjaTrader indicators come with full source code and can be viewed within the NinjaScript Editor. Please review the tutorials within this section for detailed walk throughs of custom indicator development.\n\n{% table %}\n\n* Level\n* Description\n\n---\n\n* [Level 1](beginner_-_using_price_variabl) - Demonstrating the use of price variables\n* [Level 2](beginner_-_indicator_on_indica) - Demonstrating the use of indicator on indicator\n* [Level 3](intermediate_-_your_own_sma) - Demonstrating the use of a \"for\" loop to build a simple moving average indicator\n* [Level 4](intermediate_-_historical_cust) - Demonstrating the use of Indicator Series objects to retain historical custom calculations data series\n* [Level 5](advanced_-_custom_plot_colors_) - Demonstrating the use of custom plot coloring based on threshold values\n* [Level 6](docs/guides/Educational%20Resources/Developing%20Indicators/advanced_custom_drawing.md) - Demonstrating the use of custom of drawing using bar color, back color and line colors\n{% /table %}"
  },
  {
    "_id": "92eeda832f6e89d11ad2cb8e685f69c4d111b9dc4c64a2f8a3a0c09134dc173b",
    "_type": "desktopSdkDoc",
    "title": "Formatting numbers",
    "pathName": "formatting_numbers",
    "parent": "tips",
    "order": 0,
    "section": "guides",
    "markdown": "## Formatting numbers\r\n\r\nString formatting on numbers is very useful for creating readable output. This can be done through the use of the number object's **ToString()** method.\r\n\r\nA common practice is printing out mathematical operations with the use of the **ToString()** method on the **double** object. What usually happens is the printing of a long string containing all the decimal places existing in the **double**. This sometimes makes output cluttered and hard to read. Luckily, C# has a robust set of string formatting options available to make the string more comprehendible.\r\n\r\nHere is a list of common formatting options available in the **ToString()** method:\r\n\r\n```csharp\r\ndouble c = 10.25693;\r\nPrint(\"No formatting: \" + c.ToString());\r\nPrint(\"Currency formatting: \" + c.ToString(\"C\"));\r\nPrint(\"Exponential formatting: \" + c.ToString(\"E\"));\r\nPrint(\"Fixed-point formatting: \" + c.ToString(\"F2\"));\r\nPrint(\"General formatting: \" + c.ToString(\"G\"));\r\nPrint(\"Percent formatting: \" + c.ToString(\"P0\"));\r\nPrint(\"Formatted to 2 decimal places: \" + c.ToString(\"N2\"));\r\nPrint(\"Formatted to 3 decimal places: \" + c.ToString(\"N3\"));\r\nPrint(\"Formatted to 4 decimal places: \" + c.ToString(\"N4\"));\r\n```\r\n\r\nThe corresponding output is as follows:\r\n\r\n{% table %}\r\n\r\n* Output\r\n\r\n---\r\n\r\n* No formatting: 10.25693\r\n* Currency formatting: $10.26\r\n* Exponential formatting: 1.025693E+001\r\n* Fixed-point formatting: 10.26\r\n* General formatting: 10.25693\r\n* Percent formatting: 1,026 %\r\n* Formatted to 2 decimal places: 10.26\r\n* Formatted to 3 decimal places: 10.257\r\n* Formatted to 4 decimal places: 10.2569\r\n{% /table %}\r\n\r\nFor custom formatting you can use the following:\r\n\r\n```csharp\r\n\r\ndouble phoneNumber = 9165551022;\r\nPrint(\"Phone number: \" + phoneNumber.ToString(\"(###) ### - ####\"));\r\n```\r\n\r\nCorresponding output:\r\n\r\n{% table %}\r\n\r\n* Phone number\r\n\r\n---\r\n\r\n* Phone number: (916) 555 - 1022\r\n{% /table %}\r\n\r\nFor more information on general string formatting the Microsoft documentation may be of use. Many other resources can be found online through a Google search as well."
  },
  {
    "_id": "786426b27007b3bb326871a6e1c05f1523d51bd6beff8fd2bb907ab798f0a4f3",
    "_type": "desktopSdkDoc",
    "title": "Make sure you have enough bars in the data series you are accessing",
    "pathName": "make_sure_you_have_enough_bars",
    "parent": "tips",
    "order": 0,
    "section": "guides",
    "markdown": "A common programming error is not checking to ensure there are enough bars contained in the data series you are accessing. This will explain some of the concepts to check for this situation.\r\n\r\nFor example:\r\n\r\n```csharp\r\n\r\nprotected override void OnBarUpdate()\r\n{\r\n    if (Close[0] > Close[1])\r\n        // Do something\r\n}\r\n\r\nIn the code snippet above, the **OnBarUpdate()** method is called for each bar contained in your data series.\r\n\r\nOn the very first bar (think of the 1st bar on the chart from left to right) the value of \"close of 1 bar ago\" (**Close**[1]) does not yet exist and your indicator/strategy will not work and throw an exception to the Control Center Log tab \"Index was out of range...\".\r\n\r\nFollowing are two ways to resolve this:\r\n\r\n```csharp\r\n\r\nprotected override void OnBarUpdate()\r\n{\r\n   if (CurrentBar < 1)\r\n       return;\r\n   if (Close[0] > Close[1])\r\n        // Do something\r\n}\r\n\r\nThe resolution above is to check how many bars we have seen (**CurrentBar**) and to exit the **OnBarUpdate()** method if an insufficient number of bars has been seen.\r\n\r\n```csharp\r\n\r\nprotected override void OnBarUpdate()\r\n{\r\n    if (Close[0] > Close[Math.Min(CurrentBar, 1)])\r\n        // Do something\r\n}\r\n\r\n\r\nThe resolution above substitutes the minimum value between the current bar being processed and the desired number of bars ago value, in this case 1.\r\n\r\n```csharp\r\n\r\n---\r\n\r\nprotected override void OnStateChange()\r\n{\r\n   if (State == State.SetDefaults)\r\n    {\r\n        Name = \"Multi-Time Frame & Instruments Example\";\r\n    }\r\n    else if (State == State.Configure)\r\n    {\r\n        // Adds a secondary bar object to the script.\r\n        AddDataSeries(BarsPeriodType.Minute, 5);\r\n\r\n        // Adds an additional bar object to the script.\r\n        AddDataSeries(BarsPeriodType.Minute, 5);\r\n    }\r\n}\r\n\r\nprotected override void OnBarUpdate()\r\n{\r\n    // Checks to ensure all Bars objects contain enough bars before beginning\r\n    // If this is a strategy, use **BarsRequiredToTrade** instead of **BarsRequiredToPlot**\r\n    if (CurrentBars[0] <= BarsRequiredToPlot || CurrentBars[1] <= BarsRequiredToPlot || CurrentBars[2] <= BarsRequiredToPlot)\r\n        return;\r\n}\r\n```\r\n\r\nThe resolution above would be used in a [Multi Time Frame](multi-time_frame__instruments) script. Since **OnBarUpdate()** processes multiple data series, we need to make sure each Data Series we reference has processed enough bars."
  },
  {
    "_id": "3e2944174f2b8a99ae1c756c654a8900457cf9448bb62f4969b6e46950731b06",
    "_type": "desktopSdkDoc",
    "title": "Referencing the correct bar",
    "pathName": "referencing_the_correct_bar",
    "parent": "tips",
    "order": 0,
    "section": "guides",
    "markdown": "When coding an indicator or strategy it is important to be able to access the intended bars for correct calculations. In **NinjaScript** we are able to access the bars we want through proper use of the bar's indexing.\r\n\r\nThe bar's indexing is setup in a reverse chronological order. This means \"0\" refers to the most recent bar, \"1\" refers to the previous bar, \"2\" refers to the bar before that one, etc.\r\n\r\nFor example, if we wanted to subtract the high and low of 10 bars ago from each other we would do this:\r\n\r\n```csharp\r\ndouble value = High[10] - Low[10];\r\n```\r\n\r\nNow that we know how the indexing works there are several properties and methods at our disposal that can help us access important keystone bars. The more important ones are [CurrentBar](currentbar) and [BarsSinceNewTradingDay](barssincenewtradingday).\r\n\r\n## CurrentBar\r\n\r\nCurrentBar returns an int representing the number of bars existing on the chart. This property is most useful when you want to run calculations from the very beginning of the chart.\r\n\r\nFor example, if you wanted to find the average high value of the first 10 bars on the chart you could do this:\r\n\r\n```csharp\r\ndouble highValue = 0;\r\nint x = CurrentBar;\r\nwhile (x > CurrentBar - 10)\r\n{\r\n    highValue += High[x];\r\n    x--;\r\n}\r\nPrint(\"The average high value: \" + highValue/10)\r\n```\r\n\r\n{% callout type=\"note\" %}\r\nA common mistake in using CurrentBar is using it in the index to access the most recent bar. In this situation, instead of doing something like Close[CurrentBar] you will want to do Close[0].\r\n{% /callout %}\r\n\r\n## BarsSinceNewTradingDay\r\n\r\nBarsSinceNewTradingDay is another property that can help you find the first bar of the current trading day. The difference between BarsSinceNewTradingDay and CurrentBar is that BarsSinceNewTradingDay resets its count whenever a new session begins. This means if you use it in an index it will only get you to the beginning of the current session and not any previous sessions.\r\n\r\nFor example, if you wanted to find the open of the current session you could do this:\r\n\r\n```csharp\r\ndouble openValue = Open[Bars.BarsSinceNewTradingDay];\r\n```\r\n\r\nThe example used in the discussion about CurrentBar can also be done with Bars.BarsSinceNewTradingDay if you wanted to calculate values based on the current session instead of the start of the chart too.\r\n\r\n{% callout type=\"note\" %}\r\nIf you wish to access values older than 256 bars ago you will need to ensure the [MaximumBarsLookBack](maximumbarslookback) is set to .Infinite.\r\n{% callout type=\"note\" %}\r\n\r\n## Other Properties and Methods\r\n\r\nThere are also a number of other properties and methods that can be useful in helping you locate the correct bars index to reference. Please take a look at these in the help guide:\r\n\r\n* [BarsSinceEntryExecution()](barssinceentryexecution)\r\n* [BarsSinceExitExecution()](barssinceexitexecution)\r\n* [GetBar()](getbar)\r\n* [GetDayBar()](getdaybar)\r\n* [HighestBar()](highestbar)\r\n* [LowestBar()](lowestbar)\r\n* [LRO()](least_recent_occurence_lro)\r\n* [MRO()](most_recent_occurence_mro)"
  },
  {
    "_id": "887b76d904b47e98a49fe7f42449dfc0b26b4cc6ab959f67ac9fd5ec86b58c48",
    "_type": "desktopSdkDoc",
    "title": "NinjaScript Best Practices",
    "pathName": "ninjascript_best_practices",
    "parent": "ninjascript",
    "order": 2,
    "section": "guides",
    "markdown": "There are some best practices to be aware of when developing **NinjaScript** classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.\n\n{% callout type=\"note\" %}\n\n* NinjaTrader is multi-threaded and event driven. Always assume that any of the methods you implement in NinjaScript could be called from another thread.\n{% /callout %}\n\n## State management practices\n\n{% table %}\n\n* Managing Resources\n* Setting Default UI Property Grid values\n\n---\n\n* The **OnStateChange()** method is called anytime there has been a change of **State** and can be used to help you setup, manage, and destroy several types of resources. Where these values are setup is highly dependent on the kind of resource you are using. The section below will cover how to manage various resources throughout different states.\n* Reserve **State.SetDefaults** for defaulting any public properties you wish to have exposed on the UI property grid. You should also use this **State** for setting default desired **NinjaScript** property behavior which can be overridden from the property grid (e.g. **Calculate**, **IsOverlay**, etc.). For Plots and Lines you wish to configure, **AddPlot()**, **AddLine()** should also have their default values set during this **State**.\n{% /table %}\n\n{% table %}\n\n* Why\n\n---\n\n* Public values of the **NinjaScript** object in **SetDefaults** are pushed to the UI property grid for an opportunity to change settings of your object.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   // these are the values that show up as default on the UI\n   if (State == State.SetDefaults)\n   {\n     Calculate = Calculate.OnPriceChange;\n     IsOverlay = false;\n\n     Period = 50;\n\n     AddPlot(Brushes.Blue, \"Plot Value\");\n     AddLine(Brushes.Gray, 100, \"Threshold\");\n   }\n\n```\n\nFor public properties you do NOT wish exposed to the UI property grid, set the **Browsable** attribute to false:\n\n```csharp Best practice\n[Browsable(false)] // prevents from showing up on the UI property grid\npublic int Communicator { get; set; \n```\n\nOn indicators, properties you wish to set from other objects, set the **NinjaScriptPropertyAttribute**:\n\n```csharp Best practice\n[NinjaScriptProperty] // can now call **MyIndicator**(20) from another object\npublic int Period { get; set; }\n```\n\nThe default behavior is to serialize any public properties and fields to a Workspace or Template file when saving. However, not all objects can be serialized - or you may wish to exclude a property from being saved and restored. For these scenarios, set the **XmlIgnore** attribute to the property:\n\n```csharp Best practice\n[XmlIgnore] // removes from serialization\npublic Brush DownBrush\n{ get; set; }\n```\n\nAs a best practice as well, your **NinjaScript** should not have any public fields, since those would get serialized as well - which means their state would be persisted, which in turn could lead to unexpected outcomes.\n\n{% callout type=\"note\" %}\n\n* See the [Working with Brushes](working_with_brushes) section of the Help Guide for information on properly serializing brushes.\n\n{% /callout %}\n\nCalculating run-time object values\n\nDo not attempt to do advanced calculations or try to access object references in **State.SetDefaults**. This **State** should be kept as lean as possible, and any calculation logic should be delayed until at least **State.Configure**.\n\n{% table %}\n\n* Why\n\n---\n\n* Your object will be called in situations you may not be expecting. You can read more about this subject on [Understanding the life cycle of your NinjaScript objects](understanding_the_lifecycle_of).\n{% /table %}\n\n```csharp Practice to avoid\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n       // logic could take longer than desired as the list of indicator names is populated\n       for (int i = 0; i <= array.length; i++)\n           DoWork(i);\n\n       // possible null reference exception since **TickSize** is not set yet\n       Period = 5 * TickSize;\n   }\n```\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   // Complex operations should be delayed to >= State.Configure\n   if (State == State.Configure)\n   {\n       for (int i = 0; i <= array.length; i++)\n           DoWork(i);\n   }\n\n   // information related to market data is not available until at least State.DataLoaded\n   else if (State == State.DataLoaded)\n   {\n       Period = 5 * TickSize;\n   }\n}\n```\n\nSetting class level variables\n\nDo not set variables at the class level unless they are constant. You should delay setting or resetting variables until the **State** has reached **State.Configure**. You can use **const** keyword to differentiate values which do not change from variables which do change.\n\n{% table %}\n\n* Why\n\n---\n\n* Waiting to set up and define resources until the object has been configured ensures that values not set up and declared prematurely.\n{% /table %}\n\n```csharp Best practice\n// value is always 5, it can be made constant and declared at the class level\nprivate const int multiplier = 5;\n\n// these values can change, may be better to delay setting until State.Configure\nprivate int counter;\nprivate List<int> myList;\n\nprotected override void OnStateChange()\n{\n   if (State == State.Configure)\n   {\n       counter = 0;\n       myList = new List<int>();\n   }  \n```\n\nResetting class level variables for Strategy Analyzer Optimization\n\nTo take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.\n\n{% table %}\n\n* Why\n\n---\n\n* When optimizing a strategy, instances may or may not be recycled depending on the strategy **IsInstantiatedOnEachOptimizationIteration** setting.\n{% /table %}\n\n```csharp Best practice\n// examples of fields which need to be reset\nprivate double myDouble;\nprivate bool myBool;\nprivate DateTime myDateTime;\nprivate Order myOrderObject;\nprivate Brush myBrushObject;\nprivate Array myIntArray;\nprivate List<object> myList;\nprivate SMA mySMAIndicator;\nprivate Series<double> mySeries;\n\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n       // disabled to take advantage of performance gains\n       // However any strategy state that would be mutable after State.SetDefaults needed to be reset for the next run.\n       IsInstantiatedOnEachOptimizationIteration = false;\n   }\n   else if (State == State.Configure)\n   {\n       // Since these values are not dependent on bars, they can be reset as early as State.Configure\n       myDouble = double.MinValue;\n       myBool = false;\n       myDateTime = DateTime.MinValue;\n       myOrderObject = null;\n       myBrushObject = null;\n\n       if (myIntArray != null)\n           Array.Clear(myIntArray, 0, myIntArray.Length);\n       else\n           myIntArray = new int[20];\n\n       if (myList != null)\n           myList.Clear();\n       else\n           myList = new List<object>();\n   }\n\n   else if (State == State.DataLoaded)\n   {\n       // Since these values do are dependent on bars, they should only reset during State.DataLoaded\n       mySMAIndicator = SMA(14);\n       mySeries = new Series<double>(this);\n   }\n\n```\n\nAccessing properties related to market data\n\nDo not attempt to access objects related to instrument market data until the **State** has reached **State.DataLoaded**.\n\n{% table %}\n\n* Why\n\n---\n\n* Waiting to access objects that depend on market data until **DataLoaded** prevents access errors in all scenarios.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   if (State == State.DataLoaded)\n   {\n       // these objects and their related members are not available until State.DataLoaded\n       Print(Bars.Count);\n       Print(Instrument.FullName);\n       Print(BarsPeriod.BarsPeriodType);\n       Print(TradingHours.TimeZon;\n       Print(Input);\n   }\n}\n```\n\n{% table %}\n\n* Note\n\n---\n\n* All additional data series must be added in **State.Configure** (this includes series that any hosted script potentially needs as well - [more info](http://ninjatrader.com/support/helpGuides/nt8/en-us/adddataseries.htm)). Since objects such as **Instrument**, **BarsPeriod**, **TradingHours**, etc. are NOT guaranteed to be available until **State.DataLoaded**, you cannot reliably use the primary instrument properties as arguments in **AddDataSeries()**. Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided. In some cases, you may be able to use a **BarsRequest()** to obtain market data for other instruments and intervals.\n{% /table %}\n\nSetting up resources that rely on market data\n\nFor objects which depend on market data, delay their construction until the **State** has reached **State.DataLoaded**.\n\n{% table %}\n\n* Why\n\n---\n\n* Waiting to construct objects that depend on market data until **DataLoaded** ensures that their underlying input contains significant values in all scenarios.\n{% /table %}\n\n```csharp Best practice\n// these resources depend on bars, wait until State.DataLoaded to instantiated\nprivate EMA myEMA;\nprivate Series<double> mySeries;\nprivate SessionIterator mySessionIterator;\n\nprotected override void OnStateChange()\n{  \n   if (State == State.DataLoaded)\n   {\n       myEMA = EMA(20);\n       mySeries = new Series<double>(this);\n       mySessionIterator = new SessionIterator(Bars);\n   }\n\n```\n\nAccessing element on the UI\n\nFor objects which exist on the UI (e.g., **ChartControl**, **ChartPanel**, **ChartBars**, **NTWindow**, etc.) wait until the **State** has reached **State.Historical**. This practice is correct for both reading properties or should you wish to add custom elements to the existing UI.\n\n{% table %}\n\n* Why\n\n---\n\n* **NinjaTrader** UI related objects are not guaranteed to be available until historical data processing has started.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   // wait until at least State.Historical\n   if (State == State.Historical)\n   {\n       // and double check UI object is not null before accessing\n       if (ChartControl != null)\n       {\n           Print(ChartControl.Properties.ChartBackground);\n       }\n   }\n}\n```\n\nTransitioning order references from historical to real-time\n\nWhen dealing with strategy based orders which have transitioned from historical to real-time, you will need to ensure that locally stored order references are also updated.\n\n{% table %}\n\n* Why\n\n---\n\n* As the core order object updates, **NinjaTrader** has no specific way to update your locally stored order references. You can read more about this subject on the Advanced Order Handling topic: [Transitioning order references from historical to live](advanced_order_handling).\n{% /table %}\n\n```csharp Best practice\nprivate Order entryOrder = null;\n\nprotected override void OnBarUpdate()\n{\n   if (entryOrder == null && Close[0] > Open[0])\n       entryOrder = EnterLongLimit(\"myEntryOrder\", Low[0]);\n}\n\nprotected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string nativeError)\n{\n   // One time only, as we transition from historical\n   // Convert any old historical order object references to the live order submitted to the real-time account\n   if (entryOrder != null && entryOrder.IsBacktestOrder && State == State.Realtime)\n       entryOrder = GetRealtimeOrder(entryOrder);\n\n   // Null entryOrder if filled or cancelled. We do not use the Order objects after the order is filled, so we can null it here\n   if (entryOrder != null && entryOrder == order)\n   {\n       if (order.OrderState == OrderState.Cancelled && order.Filled == 0)\n           entryOrder = null;\n       if (order.OrderState == OrderState.Filled)\n           entryOrder = null;\n   }\n\n```\n\nTerminating custom resources\n\nUse a flag to track when resources have been set up properly before attempting to destroy them.\n\n{% table %}\n\n* Why\n\n---\n\n* Checking that an object has been configured ensures that values not destroyed prematurely. You can read more about this subject on [Understanding the life cycle of your NinjaScript objects](understanding_the_lifecycle_of).\n{% /table %}\n\n```csharp Best practice\n\n---\n\nprotected override void OnStateChange()\n{\n   if (State == State.Configure)\n   {\n       myObject = new object();\n       // set a flag to indicator object has been configured\n       configured = true;\n   }\n\n   else if (State == State.Terminated)\n   {\n       // only dispose of object if it has been configured\n       if (configured)\n       {\n           myObject.Dispose();\n       }\n   }\n}\n```\n\n## Error handling practices\n\n{% table %}\n\n* Safely accessing reference objects\n\n---\n\n* Although there are documented States where objects are available, the implementation could change. If you are accessing a reference object, please do so by first checking that the object is not null.\n{% /table %}\n\n```csharp Best practice\n\n// checking to ensure chart control is available in all situations\n// will help to ensure this logic below does not generate errors at a later time\nif(ChartControl != null)\n{\n   myBackgroundBrush = ChartControl.Properties.ChartBackground;\n}\n```\n\nAccessing objects which terminate\n\nTo protect against race conditions and access errors, you should temporarily check for reference errors any time you attempt to do something with an object.\n\n{% table %}\n\n* Why\n\n---\n\n* **OnStateChange()** runs asynchronous to other **NinjaScript** events. You can run into scenarios where you **State.Terminated** logic is called in the middle of **OnBarUpdate()**, **OnRender()** etc.\n{% /table %}\n\n```csharp Best practice\n\nprotected override void OnStateChange()\n{\n   // this logic runs asynchronously to other events\n   if (State == State.Terminated)\n   {\n       myObject = null;\n   }\n}\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (myObject == null)\n       return;\n\n   // for safety, always check for null references before attempting to access an object\n   // even if you have once checked for null references earlier run-time\n   if (myObject != null)\n       myObject.DoSomething();\n}\n```\n\nProving instructions for non-ninjascript properties\n\nDo not attempt to modify existing UI \"Properties\" to meet your specific needs. These features are exposed to allow you to read the environment state and make decisions to alter how your code executes, but should not be relied on to modify settings on behalf of the user. While these objects from these classes have setters for technical reasons, you should not attempt to amend the values through code. Instead, you should issue warnings or log errors instructing users to modify settings when required:\n\n{% table %}\n\n* Why\n\n---\n\n* **NinjaTrader** makes no guarantee that the requested changes will take effect, and user settings always take precedences. This includes the user defined **ChartControl.Properties**, **ChartBars.Properties**, and **ChartPanel.Properties**. Furthermore, two different user scripts could be installed which also attempt to modify properties you are relying which could introduce conflicts.\n{% /table %}\n\n```csharp Best practice\nif (State == State.Historical)\n{\n   if (ChartControl.Properties.EquidistantBarSpacing == true)\n   {\n       Draw.TextFixed(this, \"error\", \"This indicator works best with Equidistant BarSpacing set to false.\", TextPosition.BottomRight);\n   }\n}\n```\n\nModifying UI elements and multi-threading\n\nWhen interacting with UI objects, such as obtaining UI information, or modifying the existing layout, always use the **NinjaScript**'s **Dispatcher** asynchronously.\n\n{% table %}\n\n* Critical\n\n---\n\n* Improper thread handling from a **NinjaScript** object is a common cause of application deadlocks. Please be sure to read more information on [Multi-Threading Consideration for NinjaScript](multi-threading).\n{% /table %}\n\n```csharp Best practice\n// using a Dispatcher will ensure that the corresponding action executes on the associated thread\nthis.Dispatcher.InvokeAsync(() =>\n{\n   UserControlCollection.Add(new System.Windows.Controls.TextBlock\n   {\n       Text = \"\\nAdded by the ChartControl Dispatcher.\"\n   });\n});\n```\n\nProperly implementing try/catch blocks\n\nUnless you are specifically debugging a method, the use of a try-catch block should be scoped to a particular area of logic. Do NOT try to handle all of your execution logic under one giant try-catch block.\n\n{% table %}\n\n* Why\n\n---\n\n* Larger try-catch blocks can not only be harder to debug, but can introduce performance issues at run-time.\n{% /table %}\n\n```csharp Practice to avoid\nprotected override void OnBarUpdate()\n{\n   try\n   {\n       // encapsulates entire OnBarUpdate logic\n   }\n   catch (Exception ex)\n   {\n       // attempt to handle all errors in one catch\n   }\n}\n```\n\nUsing WPF brushes\n\nTry to use a static predefined **Brush** if possible. If you need to customize a new brush object, make sure to **.Freeze()** the brush before using it.\n\n{% table %}\n\n* Why\n\n---\n\n* The pre-defined brushes are thread safe and do not require any special handling. Custom defined brushes, on the other hand, are NOT thread-safe and must be frozen otherwise cross-thread exceptions can occur.\n{% /table %}\n\n```csharp Best practice\n// predefined brush\nBackBrush = Brushes.Blue;\n\n// if you are using a custom brush to e.g., modify the opacity\nSolidColorBrush opaqueBlue = new SolidColorBrush(Colors.Blue) {Opacity = .25f};\n\n// or just using at custom color not available in pre-defined brushes class\nSolidColorBrush coolGreen = new SolidColorBrush(Color.FromRgb(30, 255, 128));\n\n// you must freeze these brushes after they are constructed!\nopaqueBlue.Freeze();\ncoolGreen.Freeze();\n```\n\nbarsAgo indexer vs. absolute bar Index\nAs you probably know, you can quickly look up the bar value on the chart by calling a PriceSeries<`t`> barsAgo indexer, e.g., Close[0].\nHowever, the internal indexer and pointers about the barsAgo value are only guaranteed to be correctly synced and updated during a market data event. As a result, you should favor using the absolute GetValueAt() methods during events which are not driven by price.\n\n{% table %}\n\n* Why\n\n---\n\n* Attempting to call the barsAgo indexer in an event method that is not driven by market data can yield unexpected results.\n{% /table %}\n\n```csharp Best practice\n// OnRender is not a market data event; barsAgo pointers are not guaranteed to be in sync\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   Print(mySMA.GetValueAt(CurrentBar));\n}\n\n// same is true for you custom events\nprivate void myCustomClickHandler(object sender, MouseButtonEventArgs e)\n{\n   Print(Close.GetValueAt(CurrentBar));\n}\n```\n\n{% table %}\n\n* Tip\n\n---\n\n* If you have programming requirements which rely on a **PriceSeries** indexer, you can use the **TriggerCustomEvent()** delegate which will update the internal pointers and indexes before executing the logic you specify.\n{% /table %}\n\nCasting safely\n\nAvoid type casting and type conversion as much as possible. Casting from a mixed collection of types is also prone to exceptions especially in situations that may not occur when you originally test your code.\n\n{% table %}\n\n* Why\n\n---\n\n* The practice to avoid code below could work in some scenarios but would generate errors if other types were added to that collection that you were not anticipating.\n{% /table %}\n\n```csharp Practice to avoid\n// This would run without errors if there were ONLY type HorizontalLine on the chart\n// But you risk a likely 'System.InvalidCastException' when other draw types are in that collection\nforeach (HorizontalLine hLine in DrawObjects)\n{\n\n```\n\nIf you must cast, do so safely and avoid implicit casts to types which may not be guaranteed to succeeded.\n\n```csharp Best practice\n\n---\n\n// Use the base IDrawingTool type and then cast to the desired type within the for loop\nforeach (IDrawingTool hLine in DrawObjects)\n{\n   // Note: to prevent further errors, your type casting should be done using the \"as\" keyword\n   // Opposed to a direct cast:\n   // HorizontalLine myLine = (HorizontalLine) hLine;\n\n   HorizontalLine myLine = hLine as HorizontalLine;\n\n   // This will allow you to ensure the cast actually occurred\n   if (myLine != null)\n   {\n       Print(myLine.StartAnchor.Price);\n   }\n\n```\n\n## Performance practices\n\n{% table %}\n\n* Referencing indicator methods\n\n---\n\n* In general, when calling an Indicator return method, there is some internal caching which occurs by design to help reduce memory consumption.\n{% /table %}\n\n{% table %}\n\n* Why\n\n---\n\n* While the designed indicator caching improves general memory performance, there is an implied cost of actually looking up the cached indicator.\n{% /table %}\n\n```csharp Practice to avoid\n// each time you call the SMA() return method there is a small performance cost\n// implied from the time it takes to look up the cached instance\nif (Close[0] > SMA[20](0))\n{\n   Print(SMA[20](0));\n   EnterLongLimit(SMA[20](0));\n   Draw.Dot(this, Time[0].ToString(), false, 0, SMA[20](0), Brushes.DarkGreen);\n```\n\n{% table %}\n\n* Note\n\n---\n\n* Indicator caching ONLY occurs when an indicator is recalled with the same EXACT parameters and input from the SAME calling script. (i.e. when a previously called indicator is called a second time with new parameters in the same script, a second instance will be created / cached).\n{% /table %}\n\nIf you are reusing an indicator several times through your code (especially indicators with many parameters), you can take further steps to refine performance by storing a reference to the indicator instance yourself (although it is by no means a requirement, and this suggestion does not need to be followed strictly).\n\n```csharp Best practice\n\nprivate SMA mySma;\n\nprotected override void OnStateChange()\n{\n   // when the indicator begins processing\n   // save an instance of the SMA indicator with the desired input\n   if (State == State.Historical)\n   {\n       mySma = SMA(20);\n   }\n}\n\nprotected override void OnBarUpdate()\n{\n   // use the referenced mySMA throughout the lifetime of the script\n   if (Close[0] > mySma[0])\n   {\n       Print(mySma[0]);\n       EnterLongLimit(mySma[0]);\n       Draw.Dot(this, Time[0].ToString(), false, 0, mySma[0], Brushes.DarkGreen);\n   }\n\n```\n\nMarking object references for garbage collection\n\nWhile it is not always necessary to set objects to null, doing so will mark them for garbage collection sooner and help prevent unnecessary memory resources from being utilized.\n\n{% table %}\n\n* Why\n\n---\n\n* In general you should be diligent to set stored memory objects to null when you are done using them, especially in situations where a **NinjaScript** object may be running for an extended period.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnBarUpdate()\n{\n   // saving \"myDot\" creates an additional reference in memory\n   Dot myDot = Draw.Dot(this, \"myDot\" + CurrentBar, false, Time[0], Close[0], Brushes.Blue);\n\n   if (conditionToRemove)\n   {\n       // remove draw object will remove the object from the chart\n       RemoveDrawObject(\"myDot\");\n\n       // but your local object \"myDot\" is still stored in memory.\n       // Explicitly setting to null will ensure object is marked for garbage collection\n       myDot = null;\n   }\n}\n```\n\n{% table %}\n\n* Note\n\n---\n\n* The example above demonstrates using a draw object, but the practice can be extended to any object you store in memory (e.g., orders, brushes, custom objects, etc).\n{% /table %}\n\nDisposing of custom resources\n\nDispose of objects that inherit from **IDisposable** or put into a Using statement.\n\n{% table %}\n\n* Why\n\n---\n\n* **NinjaTrader** is not guaranteed to dispose of objects for you. To avoid unnecessary memory consumption, always manage your resources by creating a variable and dispose of the object.\n{% /table %}\n\n```csharp Best practice\n// example of object instantiated which need to be disposed\nStreamWriter writer = new StreamWriter(\"some_file.txt\");\n\n// use the object\nwriter.WriteLine(\"Some text\");\n\n// implements IDisposbile, make sure to call .Dispose() when finished\nwriter.Dispose();\n\n// or put in \"using\" statement which implicitly calls .Dispose() when finished\nusing (StreamWriter writer2 = new StreamWriter(\"some_file.txt\"))\n{\n   writer2.WriteLine(\"Some text\");\n}\n```\n\n{% table %}\n\n* Tip\n\n---\n\n* This is most commonly applicable when using **SharpDX** resources for custom rendering. Please be sure to review the information on [Best Practices for SharpDX Resources](using_sharpdx_for_custom_chart_rendering#bestpracticesforsharpdxresources).\n{% /table %}\n\nAvoiding duplicate calculations\n\nBe mindful where and when your potentially complex calculations would be recalculated and thus run the risk of being calculated redundantly. For example, you may have logic which only needs to calculate, e.g., once per instance, once per session, once per bar, etc.\n\n```csharp Best practice\n\n// get GetPreviousTradingDayEnd() is expensive to look up\n// but value only needs to be looked up once a day -> only calculate on first bar of session\nif (Bar.IsFirstBarOfSession)\n{\n   TradingHours.GetPreviousTradingDayEnd(Time[0]);\n}\n```\n\nThe same considerations would apply to variables or function calls that would not change their output value for the currently processed bar on **Calculate.OnEachTick** or **.OnPriceChange**, thus there would be no need handling them outside of **IsFirstTickOfBar**.\n\n```csharp Best practice\n// dedicated logic to cache the prior sum on each tick of bar\n// While it is a good practice, this can cause problems for bar types which may remove last bar (see below)\nif (IsFirstTickOfBar)\n   priorSum = sum;\n\nsum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);\nValue[0] = sum / (CurrentBar < Period ? CurrentBar + 1 : Period);\n```\n\nCaching values on bars which remove last bar\n\nBuilding on the previous example, be careful when caching values on the first tick of bar if using bars types which are **IsRemoveLastBarSupported**. To see how to handle these situations best, take a look at the default **SMA** indicator which has an additional logic branch which disables caching on those bar types:\n\n```csharp Best practice\n // logic below disables first tick of bar caching only on bar types which remove last bar\nif (BarsArray[0].BarsType.IsRemoveLastBarSupported)\n{\n   if (CurrentBar == 0)\n       Value[0] = Input[0];\n   else\n   {\n       double last = Value[1] * Math.Min(CurrentBar, Period);\n\n       if (CurrentBar >= Period)\n           Value[0] = (last + Input[0] - Input[Period]) / Math.Min(CurrentBar, Period);\n       else\n           Value[0] = ((last + Input[0]) / (Math.Min(CurrentBar, Period) + 1));\n   }\n\n```\n\nPrecomputing values instead of calculating in **OnRender()**\n\nTo preserve good performance, always err on the side of caution if you are using **OnRender** for any calculation logic.\n\n{% table %}\n\n* Why\n\n---\n\n* **OnRender()** is called frequently as you interact with the Chart, which can cause calculations to occur much more often than the related market data events and can cause unnecessary spikes in CPU consumption.\n{% /table %}\n\n```csharp Practice to avoid\n\n---\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // continually recalling the same value methods is unnecessary in this situation\n   double myValue = Bars.GetClose(CurrentBar) + Bars.GetOpen(CurrentBar);\n\n   // render myValue\n}\n```\n\n```csharp Best practice\n\n---\n\nprivate double myValue;\n\nprotected override void OnBarUpdate()\n{\n   // myValue only needs to update when OnBarUpdate() is called\n   // and then can be passed to OnRender() for chart rendering purposes\n   myValue = Close[0] + Open[0];\n}\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // if needed, you can always check that myValue has actually been set\n   if (myValue > double.MinValue)\n   {\n       // render myValue\n   }\n\n```\n\nRestricting **OnRender()** calculations to visible **ChartBars**\n\nUse the **ChartBars.FromIndex** and **ChartBars.ToIndex** to limit calculations to only what is visible on the chart.\n\n{% table %}\n\n* Why\n\n---\n\n* Rendering should be reserved for rendering on what is visible on the Chart. Performing calculations on bar index which are not visible can cause random spikes in CPU consumption.\n{% /table %}\n\n```csharp Best practice\n\n---\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // restricting this loop to only the ChartBars.From/ToIndex limits the loop to only what is visible on the chart\n   for (int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n   {\n       Print(ChartControl.GetSlotIndexByX(barIndex));\n   }\n}\n```\n\nUsing **DrawObjects** vs custom graphics in **OnRender()**\n\nWhen using **Draw methods**, a new instance of the **Draw** object is created including its custom rendering and calculation logic. These methods are convenient in many situations, but can quickly introduce performance issues if used too liberally. In some situations, you may see better performance for rendering via **SharpDX** in **OnRender()**.\n\n{% table %}\n\n* Why\n\n---\n\n* Each draw object instance will see its own **OnRender()** called to render values. If you instead implement custom rendering in the your object, you would only see a single **OnRender()** call for your custom created graphics.\n{% /table %}\n\n```csharp Practice to avoid\nprotected override void OnBarUpdate()\n{\n   // this would draw a dot on every bar on the chart\n   // each instance would need to call its own OnRender() method\n   // not a very efficient use a draw method\n   Draw.Dot(this, \"everyDot\" + CurrentBar, false, 0, Close[0], Brushes.Blue);\n}   \n\n```\n\nWith just a little extra code (much less than what is in the **Draw methods**) custom **SharpDX** rendering greatly reduces CPU and Memory consumption. Please ensure a **Direct2D1** factory would only be instantiated from **OnRender()** or **OnRenderTargetChanged()** (which run in the UI thread), as access from other threads outside those methods could cause a degradation in performance.\n\n```csharp Best practice\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // achieves the same effect of drawing a dot on every bar\n   // but only needs to call your object's OnRender()\n   for (int index = ChartBars.FromIndex; index <= ChartBars.ToIndex; index++)\n   {\n       float price = chartScale.GetYByValue(Close.GetValueAt(index));\n       float bar = chartControl.GetXByBarIndex(ChartBars, index);\n       float radius = (float) chartControl.BarWidth;\n\n       SharpDX.Direct2D1.Ellipse dot = new SharpDX.Direct2D1.Ellipse(new SharpDX.Vector2(bar, price), radius, radius);\n\n       using (SharpDX.Direct2D1.SolidColorBrush brush = new SharpDX.Direct2D1.SolidColorBrush(RenderTarget, SharpDX.Color.Blue))\n       {\n           RenderTarget.FillEllipse(dot, brush);\n       }\n   }\n}\n```\n\n{% table %}\n\n* Tip\n\n---\n\n* One of the advantages of using a **Draw.Method** is the returned **Draw** Objects contains metadata which could be used later (such as for obtain the bar index or price value of the dot later on). If you would use this metadata later on, using a **Draw method** would be in your best interests. However, if you are solely looking to render figures on a chart, favoring your custom **SharpDX** methods can drastically improve performance.\n{% /table %}\n\nResponding to user events\n\nDo NOT use **OnRender()** for purposes other than rendering. If you need events to hook into user interactions, consider adding your own event handler. The example below shows registering the **ChartPanel** **MouseDown** event and registering a custom WPF control.\n\n{% table %}\n\n* Why\n\n---\n\n* **OnRender()** may call more or less frequently than you anticipated. Using your own custom event handlers allows you control and isolate user event logic you are looking to capture.\n{% /table %}\n\n```csharp Best practice\nprotected override void OnStateChange()\n{\n   if (State == State.Historical)\n   {\n       // subscribe to chart panel mouse down event\n       if (ChartPanel != null) ChartPanel.MouseDown += DoUserClickedChartPanelEvent;\n\n       // subscribe to a custom UI element mouse down event\n       if (myWPFControl != null) myWPFControl.MouseDown += DoCustomWPFControlClickEvent;\n   }\n\n   else if (State == State.Terminated)\n   {\n       // remember to unsubscribe when finished\n       if (ChartPanel != null) ChartPanel.MouseDown -= DoUserClickedChartPanelEvent;\n       if (myWPFControl != null) myWPFControl.MouseDown -= DoCustomWPFControlClickEvent;\n   }\n}\n\nprivate void DoUserClickedChartPanelEvent(object sender, MouseButtonEventArgs e)\n{  \n   Print(\"User clicked on the ChartPanel, executing custom mouse down logic...\");\n}\n\nprivate void DoCustomWPFControlClickEvent(object sender, MouseButtonEventArgs e)\n{\n   Print(\"User clicked on my button, executing button logic...\");\n}\n```\n\nDelaying logic for a particular time interval\n\nDo NOT call **Thread.Sleep()** as it will lock the Instrument thread executing your **NinjaScript** object.\n\n{% table %}\n\n* Why\n\n---\n\n* Market data events exposed to **NinjaScript** run on the underlying Instrument thread pool shared by all Instruments. Sleeping the underlying thread of your object will cause the entire Instrument thread to sleep, adversely affecting other features using that same Instrument.\n{% /table %}\n\n```csharp Practice to avoid\n\n---\n\nprotected override void OnBarUpdate()\n{\n   if (IsFirstTickOfBar && State == State.Realtime)\n   {\n       Print(\"Run some logic before:: \" + DateTime.Now);\n       Thread.Sleep(5000); // sleeping the Instrument thread will have adverse effects on elements outside of your script!\n       Print(\"Run some logic after: \" + DateTime.Now);\n   }\n}\n```\n\nInstead, try using a **Timer** object if you need to delay logic execution.\n\n```csharp Best practice\nprotected override void OnBarUpdate()\n{\n   if (IsFirstTickOfBar && State == State.Realtime)\n   {\n       // Instead of Thread.Sleep for, create a timer that runs at the desired interval\n       System.Windows.Forms.Timer timer = new System.Windows.Forms.Timer {Interval = 5000};\n\n       // queue the \"after\" logic to run when the timer elapses\n       timer.Tick += delegate\n       {\n           timer.Stop(); // make sure to stop the timer to only fire ones (if desired)\n           Print(\"Run some logic after: \" + DateTime.Now);\n           timer.Dispose(); // make sure to dispose of the timer\n       };\n\n       Print(\"Run some logic before: \" + DateTime.Now);\n\n       timer.Start(); // start the timer immediately following the \"before\" logic\n   }\n\n```\n\n## Miscellaneous practices\n\n{% table %}\n\n* Floating-point comparison\n\n---\n\n* Be aware of floating-point precision problems. It can sometimes be more reliable to check within a certain degree of tolerance, such as the **TickSize**.\n{% /table %}\n\n{% table %}\n\n* Why\n\n---\n\n* You can read more about [Floating-Point Arithmetic](http://ninjatrader.com/support/forum/showthread.php?t=3929) as it applies to **NinjaTrader** on our support forum.\n{% /table %}\n\n```csharp Practice to avoid\n\n---\n\n// depending on how Value[0] was calculated, it could be off by a degree of floating points\n// where this logic below would never be true\n// e.g., 2050.2499999 vs 2050.50\nif (Value[0] == Close[0])\n{\n   // do something\n}\n```\n\n```csharp Best practice\n// you can avoid these precision issues by rewriting the comparison to evaluate within a certain tolerance.\nif (Math.Abs(Value[0] - Close[0]) < TickSize)\n{\n   // do something\n}\n\n// You will also see NinjaTrader developed objects use a custom Extension Method\n// double.ApproxCompare() which Returns an int based on a Epsilon value:\nif (Close[0].ApproxCompare(Value[0]) == 0)\n{\n   // do something\n}\n```\n\nCreating user defined parameter types / enums\n\nWhen creating enums for your **NinjaScript** objects, it is strongly suggested to define those outside the class and in a custom namespace. A reference sample providing all details could be [found here](creating_a_user_defined_parame).\n\nEfficiently debugging\n\nExtremely liberal use of **Log()** and **Print()** methods can represent a performance hit on your PC as it takes memory and time to process each one of those method calls. When running custom **NinjaScript**, especially when using **Calculate = Calculate.OnEachTick**, please be mindful of how often **Log()** and **Print()** methods are processed as it can quickly consume PC resources.\n\n* **Log()** method should not be used except for critical messages as each log entry makes it to the Control Center log which stays active till the end of the day. Excessive logging can result in huge amounts of memory being allocated just to display all the log messages which would mean less memory for **NinjaTrader** to do other tasks.\n* **Print()** method can be used more liberally than the **Log()** method, but can still represent a performance hit if used with extremely high frequency. Consider decreasing the printing from your script if you experience slowdowns when running the script.\n\nDebug Mode\n\nThe debug mode should only be used if you are actively debugging a script and [attached to a debugger](visual_studio_debugging).\n\n{% table %}\n\n* Why\n\n---\n\n* Debug Mode will compile all of the files in the custom project as a \"Debug\" build, which omits certain optimizations which occur in the C# compilation process. It is more efficient to use your custom objects in the default \"Release\" build if you are using your scripts during production.\n{% /table %}\n\nTo disable Debug Mode:\n\n* Right mouse click in any **NinjaScript Editor**\n* Ensure the \"Debug Mode\" menu item is unchecked\n* Press F5 to recompile your scripts\n* Your scripts will be re-built using \"Release\" mode\n\nKnown **NinjaScript** Wrappers limitations\n\n* The **NinjaScript** editor detects code changes in external editors, and will compile on code changes, however code will only be automatically generated by the **NinjaScript** editor if it's edited within the **NinjaScript** editor itself (or **Visual Studio**).\n* Wrappers cannot be generated automatically for partial and abstract classes.\n* Code in the Properties region of the **NinjaScript** object cannot be commented out with the /**/ style commenting, as it will cause issues with the wrapper generation. Code must be commented out with the // style.\n* Subclassing would not allow for wrappers to be generated."
  },
  {
    "_id": "93c5b08df439bd719c489cdebe98ecc0b4266679d927ebd3d41506886e947e62",
    "_type": "desktopSdkDoc",
    "title": "OnCalculatePerformanceValue()",
    "pathName": "oncalculateperformancevalue",
    "parent": "optimization_fitness",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nThis method calculates the value for the Optimization Fitness.\n\n## Syntax\n\n**protected override void OnCalculatePerformanceValue(StrategyBase strategy)**\n\n## Examples\n\n```csharp\nprotected override void OnCalculatePerformanceValue(StrategyBase strategy)\n{\n\n     Value = strategy.SystemPerformance.AllTrades.TradesPerformance.Percent.Drawdown;\n\n}"
  },
  {
    "_id": "04fd71c9d76bea810219891b2322dade1bf4943536487339cf4b4381189d9237",
    "_type": "desktopSdkDoc",
    "title": "OptimizationParameters",
    "pathName": "optimizationparameters",
    "parent": "optimizer",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nThe optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)\n\n## Property Value\n\nA bool value.\n\n## Syntax\n\n**Strategies[0].OptimizationParameters**\n\n## Examples\n\n```csharp\nprotected override void OnOptimize()\n{\n     // If there are no optimization parameters to optimize, return\n     if (Strategies[0].OptimizationParameters.Count == 0)\n         return;\n\n     // Do something with the optimization parameter\n     Parameter parameter = Strategies[0].OptimizationParameters[0];\n}\n```"
  },
  {
    "_id": "c1acf7c2d0ca1975b5c37281c3f66dea95aaf670b9e3caa49e4e9bc34ac6a5f3",
    "_type": "desktopSdkDoc",
    "title": "GetAtmStrategyPositionQuantity()",
    "pathName": "getatmstrategypositionquantity",
    "parent": "atm_strategy_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGets the current position quantity of the specified ATM Strategy.\n\n{% callout type=\"note\" %}\n\nChanges to positions will not be reflected till at least the next **OnBarUpdate()** event after an order fill.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing the quantity.\n\n## Syntax\n\n**GetAtmStrategyPositionQuantity(string atmStrategyId)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **atmStrategyId**\n* The unique identifier for the ATM strategy\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Check if flat\n     if (GetAtmStrategyMarketPosition(\"idValue\") != MarketPosition.Flat)\n         Print(\"Position size is \" + GetAtmStrategyPositionQuantity(\"idValue\").ToString());\n}\n```"
  },
  {
    "_id": "f9e48b0b8d66263618447acc80a6c66f1ebacdd66f830441ee208ff68ba574ea",
    "_type": "desktopSdkDoc",
    "title": "GetAtmStrategyUniqueId()",
    "pathName": "getatmstrategyuniqueid",
    "parent": "atm_strategy_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGenerates a unique ATM Strategy ID value.\n\n## Method Return Value\n\nA **string** value representing a unique id value.\n\n## Syntax\n\n**GetAtmStrategyUniqueId()**\n\n## Parameters\n\nThis method does not take any parameters.\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    string orderId = GetAtmStrategyUniqueId();\n}\n```"
  },
  {
    "_id": "6334b16fda74bde3f63bbf1b7ef1de3156e627bae8693d447c379189f1861218",
    "_type": "desktopSdkDoc",
    "title": "GetRealtimeOrder()",
    "pathName": "getrealtimeorder",
    "parent": "managed_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns a matching real-time order object based on a specified historical order object reference.\n\n{% callout type=\"note\" %}\n\nThis method is only needed if you have historical order references which you wish to transition and manage in real-time (i.e., you had a working order which was submitted historically and re-submitted in real-time as the strategy is enabled). This method only needs to be called once per order object, and should be done in OnOrderUpdate to handle all scenarios. Please see the [Advanced Order Handling](advanced_order_handling) section on transition orders for more details.\n\n{% /callout %}\n\n## Method Return Value\n\nReturns a real-time [order](order) reference associated with the historical order object. If no associated order exists (i.e. OrderState is Filled, Canceled, Rejected, Unknown), a null value returns.\n\n## Syntax  \n\n**GetRealtimeOrder(Order historicalOrder)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* historicalOrder\n* The historical [order](order) object to update to real-time\n{% /table %}\n\n## Examples\n\n```csharp\nprivate Order myOrder;\n\nprotected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string nativeError)\n{\n    // One time only, as we transition from historical\n    // Convert any old historical order object references to the live order submitted to the real-time account\n    if (myOrder != null && myOrder.IsBacktestOrder && State == State.Realtime)\n        myOrder = GetRealtimeOrder(myOrder);\n\n    // Assign Order objects here\n    // This is more reliable than assigning Order objects in OnBarUpdate, as the assignment is not guaranteed to be complete if it is referenced immediately after submitting\n    if (order.Name == \"myOrder Signal Name\")\n        myOrder = order;\n\n    // Null Entry order if filled or cancelled. We do not use the Order objects after the order is filled, so we can null it here\n    if (myOrder != null && myOrder == order)\n    {\n        if (order.OrderState == OrderState.Cancelled && order.Filled == 0)\n            myOrder = null;\n        if (order.OrderState == OrderState.Filled)\n            myOrder = null;\n    }\n}\n```"
  },
  {
    "_id": "9c701261b149c7acc3125aa9f615a0f3c29e7f032402cca7798f8baf9e883afe",
    "_type": "desktopSdkDoc",
    "title": "SubmitOrderUnmanaged()",
    "pathName": "submitorderunmanaged",
    "parent": "unmanaged_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGenerates an **Unmanaged** order.\n\n## Method Return Value\n\nAn **Order** read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the **Unmanaged Approach** section.\n\n## Syntax\n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity)  \n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity, double limitPrice)  \n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity, double limitPrice, double stopPrice)  \n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity, double limitPrice, double stopPrice, string oco)  \n\n**SubmitOrderUnmanaged**(int selectedBarsInProgress, **OrderAction** orderAction, **OrderType** orderType, int quantity, double limitPrice, double stopPrice, string oco, string signalName)\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* selectedBarsInProgress\n* The index of the Bars object the order is to be submitted against. This determines what instrument the order is submitted for.  \nNote: See the **BarsInProgress** property.\n\n---\n\n* orderAction\n* Determines if the order is a buy or sell order  \nPossible values:  \n**OrderAction.Buy**  \n**OrderAction.BuyToCover**  \n**OrderAction.Sell**  \n**OrderAction.SellShort**\n\n---\n\n* orderType\n* Determines the type of order submitted  \nPossible values:  \n**OrderType.Limit**  \n**OrderType.Market**  \n**OrderType.MIT**  \n**OrderType.StopMarket**  \n**OrderType.StopLimit**\n\n---\n\n* quantity\n* Sets the number of contracts to submit with the order\n\n---\n\n* limitPrice\n* Order limit price. Use \"0\" should this parameter be irrelevant for the OrderType being submitted.\n\n---\n\n* stopPrice\n* Order stop price. Use \"0\" should this parameter be irrelevant for the OrderType being submitted.\n\n---\n\n* oco\n* A string representing the OCO ID used to link OCO orders together  \nNote: OCO strings should not be reused. Use unique strings for each OCO group, and reset after orders in that group are filled/canceled\n\n---\n\n* signalName\n* A string representing the name of the order. Max 50 characters.\n{% /table %}\n\n## Examples\n\n```csharp\nprivate Order entryOrder = null;  \nprotected override void OnBarUpdate()  \n{  \n    // Entry condition  \n    if (Close[0] > SMA[20](0) && entryOrder == null)  \n        SubmitOrderUnmanaged(0, OrderAction.Buy, OrderType.Market, 1, 0, 0, \"\", \"Enter Long\");  \n}  \nprotected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string nativeError)  \n{  \n    // Assign entryOrder in OnOrderUpdate() to ensure the assignment occurs when expected.  \n    // This is more reliable than assigning Order objects in OnBarUpdate, as the assignment is not guaranteed to be complete if it is referenced immediately after submitting  \n    if (order.Name == \"Enter Long\" && orderState == OrderState.Filled)  \n        entryOrder = order;  \n}\n\n```"
  },
  {
    "_id": "fc3532b8a6e42c0ee02e53787fd147d09f5cda0703eb60132b0856ae5a8af045",
    "_type": "desktopSdkDoc",
    "title": "OrderFillResolution",
    "pathName": "orderfillresolution",
    "parent": "strategy",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nDetermines how strategy orders are filled during historical states.\n\nPlease see [Understanding Historical Fill Processing](understanding_historical_fill_) for general information on historical fill processing.\n\n## Property Value\n\nAn enum value that determines how the strategy orders are filled. Default value is set to **OrderFillResolution.Standard**. Possible values are:\n\n* **OrderFillResolution.Standard**  | Faster - Uses the existing bar type and interval that you are running the backtest on to fill your orders.\n* **OrderFillResolution.High** | More granular - Allows you to set a secondary bar series to be used as the price data to fill your orders. (See also [OrderFillResolutionType](orderfillresolutiontype) and [OrderFillResolutionValue](orderfillresolutionvalue))\n{% /table %}\n\n## Syntax\n\n**OrderFillResolution**\n\n{% callout type=\"warning\" %}\n\n* Warning: This property should ONLY be set from the [OnStateChange()](onstatechange) method during State.SetDefaults\n{% /callout %}\n\n## Examples\n\n```csharp\n\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"ExampleStrategy\";\n     OrderFillResolution = OrderFillResolution.Standard;\n   }\n}\n```"
  },
  {
    "_id": "6839fb341fad4c54fe90a3500a6b385bc0f8111b9ca282d8349cad4e1a9d1706",
    "_type": "desktopSdkDoc",
    "title": "AveragePrice",
    "pathName": "averageprice",
    "parent": "position",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGets the average price of a strategy position.\n\n## Property Value\n\nA **double** value representing the position's average price per unit.\n\n## Syntax\n\n**Position.AveragePrice**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Raise stop loss to breakeven when there is at least 10 ticks in profit\n     if (Close[0] >= Position.AveragePrice + 10 * TickSize)\n         ExitLongStopMarket(Position.Quantity, Position.AveragePrice);\n}\n```"
  },
  {
    "_id": "8954420e242cd3fe39689337270964fc8e955395ea0c1557e10cc62d90bf9e35",
    "_type": "desktopSdkDoc",
    "title": "StrategyBaseConverter Class",
    "pathName": "strategybaseconverter",
    "parent": "strategy",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA custom **TypeConverter** class handling the designed behavior of a strategy's property descriptor collection. Use this as a base class for any custom TypeConverter you are applying to a strategy class.\n\n{% callout type=\"note\" %}\nNotes:\n\n* A working NinjaScript demo can be found through the reference sample on \"[Using a TypeConverter to Customize Property Grid Behavior](http://ninjatrader.com/support/forum/showthread.php?t=97919)\"\n* When applying the custom converter, you must fully qualify the name (e.g., \"NinjaTrader.NinjaScript.Strategies.MyCustomConveter\")\n* Additional TypeConverter information can be found from the [MSDN documentation](https://msdn.microsoft.com/en-us/library/system.componentmodel.typeconverter%28v=vs.110%29.aspx)\n* See also [TypeConverterAttribute](typeconverterattribute.htm)\n* For Indicators, see the [IndicatorBaseConverter](indicatorbaseconverter.htm) class\n{% /callout %}\n\n## Relevant base methods\n\n{% table %}\n\n* Method\n* Description\n\n---\n\n* [TypeConverter.GetProperties()](https://msdn.microsoft.com/en-us/library/system.componentmodel.typeconverter.getproperties(v=vs.110).aspx)\n* When overriding GetProperties(), calling base.GetProperties() ensures that all default property grid behavior works as designed\n\n---\n\n* [TypeConverter.GetPropertiesSupported()](https://msdn.microsoft.com/en-us/library/system.componentmodel.typeconverter.getpropertiessupported(v=vs.110).aspx)\n* In your custom converter class, you must override GetPropertiesSupported() and return a value of true in order for your custom type converter to work\n{% /table %}\n\n## Syntax\n\n**public class StrategyBaseConverter : TypeConverter**\n\n{% callout type=\"warning\" %}\nWarning: Failure to apply a type of **StrategyBaseConverter** on a strategy class can result in unpredictable behavior of the standard NinjaTrader WPF property grid.\n{% /callout %}\n\n{% callout type=\"note\" %}\nTip: Common strategy functions like **Print()** are not available to a type converter instance. To debug a type converter class, you can use the AddOn [Debug Concepts](alert_and_debug_concepts.htm) or [attach to a debugger](visual_studio_debugging.htm) (recommended)\n{% /callout %}\n\n## Examples\n\n```csharp\n// This namespace holds Strategies in this folder and is required. Do not change it.\nnamespace NinjaTrader.NinjaScript.Strategies\n{\n   // When applying the type converter, you must fully qualify the name\n   [TypeConverter(\"NinjaTrader.NinjaScript.Strategies.MyCustomConveter\")]\n   public class MyCustomStrategy : Strategy\n   {\n     protected override void OnStateChange()\n     {\n         if (State == State.SetDefaults)\n         {\n           Name                             = \"MyCustomStrategy\";\n         }\n     }\n\n     protected override void OnBarUpdate()\n     {\n         //Add your custom strategy logic here.\n     }\n   }\n\n   // custom converter class for strategies\n   public class MyCustomConveter : StrategyBaseConverter\n   {\n     // A general TypeConveter method used for converting types\n     public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attrs)\n     {\n         // sometimes you may need the strategy instance which actually exists on the grid\n         MyCustomStrategy strategy = component as MyCustomStrategy;\n\n         // base.GetProperties ensures we have all the properties (and associated property grid editors)\n         // NinjaTrader internal logic handles for a given strategy\n         PropertyDescriptorCollection propertyDescriptorCollection = base.GetPropertiesSupported(context)\n                 ? base.GetProperties(context, component, attrs) : TypeDescriptor.GetProperties(component, attrs);\n\n         if (strategy == null || propertyDescriptorCollection == null)\n           return propertyDescriptorCollection;\n\n         // example of why you may need the instance that exists on the grid....\n         if (strategy.EntryHandling == EntryHandling.UniqueEntries)\n         {\n           // do something in the event a property contains some value...\n         }\n\n         // Loop all of the properties of the strategy\n         foreach (PropertyDescriptor property in propertyDescriptorCollection)\n         {\n           // do something with a specific property\n\n           // cannot call **Print()** here\n           // but you can call the static Output window \"Process()\"\n           NinjaTrader.Code.Output.Process(property.Name, PrintTo.OutputTab1);\n         }\n\n         // must return the collection after making changes\n         return propertyDescriptorCollection;\n     }\n\n     // Important:  This must return true otherwise the type converter will not be called\n     public override bool GetPropertiesSupported(ITypeDescriptorContext context)\n     { return true; }\n   }\n}\n```"
  },
  {
    "_id": "6f03ed5c0d98e6ef4ad6ad69c19332bf75394162f3694340d0ee87f3ae605ddb",
    "_type": "desktopSdkDoc",
    "title": "TradesPerformance",
    "pathName": "tradesperformance",
    "parent": "strategy",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nPerformance profile of a **collection** of **Trade** objects.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* AverageBarsInTrade\n* A double value representing the average number of bars per trade\n\n---\n\n* AverageEntryEfficiency\n* A double value representing the average entry efficiency\n\n---\n\n* AverageExitEfficiency\n* A double value representing the average exit efficiency\n\n---\n\n* AverageTimeInMarket\n* A TimeSpan value representing quantity-weighted average duration of a trade\n\n---\n\n* AverageTotalEfficiency\n* A double value representing the average total efficiency\n\n---\n\n* TotalCommission\n* A double value representing the total commission\n\n---\n\n* Currency\n* Gets a TradesPerformanceValues object in currency\n\n---\n\n* GrossLoss\n* A double value representing the gross loss\n\n---\n\n* GrossProfit\n* A double value representing the gross profit\n\n---\n\n* LongestFlatPeriod\n* A TimeSpan value representing longest duration of being flat\n\n---\n\n* MaxConsecutiveLoser\n* An int value representing the maximum number of consecutive losses seen\n\n---\n\n* MaxConsecutiveWinner\n* An int value representing the maximum number of consecutive winners seen\n\n---\n\n* MaxTime2Recover\n* A TimeSpan value representing maximum time to recover from a draw down\n\n---\n\n* MonthlyStdDev\n* A double value representing the monthly standard deviation\n\n---\n\n* MonthlyUlcer\n* A double value representing the monthly Ulcer index\n\n---\n\n* NetProfit\n* A double value representing the net profit\n\n---\n\n* Percent\n* Gets a TradesPerformanceValues object in percent\n\n---\n\n* PerformanceMetrics\n* An array of custom NinjaScript performance metrics\n\n---\n\n* Pips\n* Gets a TradesPerformanceValues object in pips\n\n---\n\n* Points\n* Gets a TradesPerformanceValues object in points\n\n---\n\n* ProfitFactor\n* A double value representing the profit factor\n\n---\n\n* R2\n* A double value representing the R-squared value\n\n---\n\n* RiskFreeReturn\n* A double value representing the risk free return rate\n\n---\n\n* SharpeRatio\n* A double value representing the Sharpe Ratio\n\n---\n\n* SortinoRatio\n* A double value representing the Sortino Ratio\n\n---\n\n* Ticks\n* Gets a TradesPerformanceValues object in ticks\n\n---\n\n* TotalQuantity\n* An int value representing the total quantity\n\n---\n\n* TotalSlippage\n* A double value representing the total slippage. This is presented in points, I.E. 0.25 for 1 execution on E-mini S&P 500 Futures.\n\n---\n\n* TradesCount\n* An int value representing the trades count\n\n---\n\n* TradesPerDay\n* An int value representing the avg trades per day\n\n---\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Only trade if you have less than 5 consecutive losers in a row\n    if (SystemPerformance.RealTimeTrades.TradesPerformance.MaxConsecutiveLoser < 5)\n    {\n        // Trade logic here\n    }\n}\n```"
  },
  {
    "_id": "989d407698796cf007a0aa447a6aae166eca109ec3002f774876e6b4efbfc965",
    "_type": "desktopSdkDoc",
    "title": "AverageMae",
    "pathName": "averagemae",
    "parent": "tradesperformancevalues",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the average MAE (max adverse excursion) of the collection.\n\n## Property Value\n\nA **double** value that represents the average MAE of the collection.\n\n## Syntax\n\ntradecollection.TradesPerformance.tradesperformancevalues.**AverageMae**\n\n## Examples\n\n{% callout type=\"note\" %}\n\nThe following example shows how to print out the average MAE of all trades in currency.\n\n{% /callout %}\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Print out the average MAE of all trades in currency\n     Print(\"Average MAE of all trades is: \" + SystemPerformance.AllTrades.TradesPerformance.Currency.AverageMae);\n}\n```"
  },
  {
    "_id": "0014f61bd3b346437cb834c7cc2cdd1c88dd63ee0a9fec6f7b743e1e591dfc18",
    "_type": "desktopSdkDoc",
    "title": "ApproxCompare()",
    "pathName": "approxcompare",
    "parent": "analytical",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nCompares two double or float values for equality or being greater than / less than the compared to value.\n\n{% callout type=\"note\" %}\n\nComparing for being greater than / less is done using an epsilon value of 1E19\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing the outcome of the comparison. Returns 0 if values are equal, 1 if value1 is greater than value2. -1 if value1 is less than value2.\n\n## Syntax\n\n**this.ApproxCompare(this double double1, double double2)**\n**this.ApproxCompare(this float float1, double float2)**\n\n## Parameters\n\n{% table %}\n* Parameter\n* Description\n---\n* double1 / float1\n* First value to compare against (not actually passed in)\n---\n* double2 / float2\n* Second passed in value to compare against\n---\n\n{% callout type=\"note\" %}\n\nMain use would be using it for equality comparisons to circumvent running into floating point considerations, value compares for < or > could be usually done more straightforward directly.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Build the High / Low difference and if 0 sets the indicator main Value series to 0\nif ((High[0] - Low[0]).ApproxCompare(0) == 0)\n   Value[0] = 0;\n```"
  },
  {
    "_id": "c836d4b1ec1f66d08f6fa00450403b3d372d5066b740e3282ad55b18143f7c93",
    "_type": "desktopSdkDoc",
    "title": "GetCurrentAsk()",
    "pathName": "getcurrentask",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the current real-time ask price.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n1. When accessed during **State.Historical**, the **Close** price of the evaluated bar is substituted. To access historical Ask prices, please see **Developing for Tick Replay**.\n2. The **GetCurrentAsk()** method runs on the bar series currently updating determined by the **BarsInProgress** property. For **multi-instrument** scripts, an additional int **barsSeriesIndex** parameter can be supplied which forces the method to run on an supplementary bar series.\n{% /callout %}\n\n## Method Return Value\n\nA **double** value representing the current ask price.\n\n## Syntax  \n\n**GetCurrentAsk()**  \n**GetCurrentAsk(int barsSeriesIndex)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **barsSeriesIndex**\n* An **int** value determining the bar series the method runs. Note: This optional parameter is reserved for multi-instrument scripts\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Ensure we do not call GetCurrentAsk() on historical data\n   if (State == State.Historical)\n     return;\n\n   double currentAsk = GetCurrentAsk();\n\n   Print(\"The Current Ask price is: \" + currentAsk);\n\n   // The Current Ask price is: 1924.75\n```\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Example's Indicator\";\n   }\n   if (State == State.Configure)\n   {\n     //Add MSFT as our additional data series\n     AddDataSeries(\"MSFT\", BarsPeriodType.Minute, 1);\n   }\n}\n\nprotected override void OnBarUpdate()\n{\n   // Ensure we do not call GetCurrentBid() on historical data\n   if (State == State.Historical)\n     return;\n\n   if (BarsInProgress == 0)\n   {\n     double primaryAsk = GetCurrentAsk(0);\n     Print(\"The Primary Ask price is: \" + primaryAsk);\n     // The Primary Ask price is: 1924.75\n   }\n\n   if (BarsInProgress == 1)\n   {\n     double msftAsk = GetCurrentAsk(1);\n     Print(\"MSFT's Current Ask price is: \" + msftAsk);\n     // MSFT's Current Ask is: 43.63\n   }\n```"
  },
  {
    "_id": "be6df13306a21c86f3098150dbcc366b06834c88cb66ae0b599dd68e4cdb1027",
    "_type": "desktopSdkDoc",
    "title": "GetMedian()",
    "pathName": "getmedian",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the statistical median value of the specified series over the specified look-back period. This method sorts the values of the specified look back period in ascending order and returns the middle value.\n\n{% callout type=\"note\" %}\n\n1. This method should NOT be confused with **Median** prices defined as (**High** + **Low**) / 2. This method returns the statistical median of a series.\n2. If an even number is passed as the look-back period, the average of the two middle values in the sorted values will be returned.\n{% /callout %}\n\n## Method Return Value\n\nA **double** value representing the median value of the series.\n\n## Syntax\n\n**GetMedian**(**ISeries`<double>`** series, **int** lookBackPeriod)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **lookBackPeriod**\n* Number of bars back to include in the calculation\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, **Close**, **High**, **Low**, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{   \n   // Print the median price of the last 10 open prices \n   //(current open price + look back period's 9 open prices before that)\n   double openMedian = GetMedian(Open, 9);         \n   Print(\"The median of the last 10 open prices is: \" + openMedian);      \n}\n```"
  },
  {
    "_id": "f62717a9bd9c19d6495285bc52b022cb734d3b41566c005d2573a86fd79e970f",
    "_type": "desktopSdkDoc",
    "title": "HighestBar()",
    "pathName": "highestbar",
    "parent": "analytical",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the number of bars ago the highest price value occurred within the specified look-back period.\n\n## Method Return Value\n\nAn **int** value representing a value of bars ago.\n\n## Syntax\n\n**HighestBar**(**ISeries`<double>`** series, **int** period)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **period**\n* The number of bars to include in the calculation\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, Close, High, Low, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // store the highest bars ago value\n   int highestBarsAgo = HighestBar(**High, Bars.BarsSinceNewTradingDay);\n\n   //evaluate high price from highest bars ago value\n   double highestPrice = High[highestBarsAgo];\n\n   //Printed result:  Highest price of the session: 2095.5 - occurred 24 bars ago\n   Print(string.Format(\"Highest price of the session: {0} - occurred {1} bars ago\", highestPrice, highestBarsAgo));\n}\n```"
  },
  {
    "_id": "514b308c0e0274639ac488aa7c7f3f57531f05d39b11ca0772ed1f37c721154d",
    "_type": "desktopSdkDoc",
    "title": "LowestBar()",
    "pathName": "lowestbar",
    "parent": "analytical",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the number of bars ago the lowest price value occurred within the specified look-back period.\n\n## Method Return Value\n\nAn **int** value representing a value of bars ago.\n\n## Syntax\n\n**LowestBar**(**ISeries`<double>`** series, **int** period)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **period**\n* The number of bars to check for the test condition\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, **Close**, **High**, **Low**, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // store the lowest bar ago value\n   int lowestBar = LowestBar(Low, Bars.BarsSinceNewTradingDay);\n\n   //evaluate low price from lowest bar ago value\n   double lowestPrice = Low[lowestBar];\n\n   //Printed result:  Lowest price of the session: 2087.25 - occurred 362 bars ago\n   Print(string.Format(\"Lowest price of the session: {0} - occurred {1} bars ago\", lowestPrice, lowestBar));\n}\n```"
  },
  {
    "_id": "2cd7abdb476ef7d4cb186427fd34e14342d07d0b49fa2214239d8a7a8f67edbe",
    "_type": "desktopSdkDoc",
    "title": "GetOpen()",
    "pathName": "getopen",
    "parent": "bars",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the open price at the selected bar index value.\n\n## Method Return Value\n\nA **double** value that represents the open price at the desired bar index.\n\n## Syntax\n\n**Bars.GetOpen(int index)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **index**\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   base.OnRender(chartControl, chartScale);\n   // loop through only the rendered bars on the chart\n   for(int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n   {\n     // get the open price at the selected bar index value\n     double openPrice = Bars.GetOpen(barIndex);\n     Print(\"Bar #\" + barIndex + \" open price is \" + openPrice);\n   }\n}\n```"
  },
  {
    "_id": "a87720808cb749a3562b4766bc29836ef9116d956d21b2ded030b45c8bccdb5c",
    "_type": "desktopSdkDoc",
    "title": "CanvasZoomState",
    "pathName": "canvaszoomstate",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the current state of the Zoom tool on the chart. This property reveals the state of the tool while it is in use, and does not indicate a chart is zoomed in on or not. As soon as a zoom action is completed, the tool is considered to be no longer in use.\n\n## Property Value\n\nAn enum representing the state of the Zoom tool on the chart. Possible values are listed below:\n\n{% table %}\n\n* State\n* Description\n\n---\n\n* None\n* The Zoom tool is not currently being used\n\n---\n\n* Selected\n* The Zoom tool is selected, but has not yet been used to zoom in\n\n---\n\n* DrawingRectangle\n* The Zoom tool is currently in use (User is currently drawing the rectangle in which to zoom)\n{% /table %}\n\n## Syntax\n\n**<`chartcontrol`>.CanvasZoomState**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    CanvasZoomState zoomState = chartControl.CanvasZoomState;\n\n    // Trigger an alert while a user is zooming in on a chart\n    if (zoomState == CanvasZoomState.DrawingRectangle)\n        Alert(\"zoomAlert\", Priority.Medium, \"Make sure to zoom in on the entire chart pattern!\", \" \", 60, Brushes.White, Brushes.Black);\n}\n```\n\nBased on the image below, CanvasZoomState confirms that the Zoom rectangle is currently being drawn:\n\n![ChartControl_CanvasZoomState](chartcontrol_canvaszoomstate.png)"
  },
  {
    "_id": "84cdd7644b6eba3e43b975ec83728e6094d83caabead8cb1ed7beb91394f2539",
    "_type": "desktopSdkDoc",
    "title": "BarWidth",
    "pathName": "barwidth",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nMeasures the value of the **bar width** set for the primary Bars object on the chart.\n\n{% callout type=\"note\" %}\n\nThis property value is not stated in pixels. To obtain the pixel-width of bars on the chart, use **GetBarPaintWidth()** instead.\n\n{% /callout %}\n\n## Property Value\n\nA double representing the value of the bar width.\n\n## Syntax\n\n**<`chartcontrol`>.BarWidth**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    double barWidth = chartControl.BarWidth;\n\n    // Prints the width of bars on the chart\n    Print(barWidth);\n}\n```\n\nBased on the image below, BarWidth reveals that the bars on the chart are 4.02 pixels wide.\n\n![ChartControl_BarWidth](chartcontrol_barwidth.png)"
  },
  {
    "_id": "75e84f20cc44339e09c7c722d233f826cfcbf8aa6e13dbafd5162068a97250ac",
    "_type": "desktopSdkDoc",
    "title": "Strategies",
    "pathName": "strategies",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA collection of strategies configured on the chart.\n\n## Property Value\n\nA **ChartObjectCollection** of **StrategyRenderBase** objects containing information on all configured strategies on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.Strategies**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the number of strategies configured on the chart\n   if (chartControl.Strategies.Count > 0) \n           Print(chartControl.Strategies[0].Name);\n}\n```"
  },
  {
    "_id": "97df83fb06bbf7a4392974a48e872ab332a8f3b79203046a34d55c4f4389a3bd",
    "_type": "desktopSdkDoc",
    "title": "GetSlotIndexByX()",
    "pathName": "getslotindexbyx",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the slot index relative to the chart control corresponding to a specified x-coordinate.\n\n{% callout type=\"note\" %}\n\n* A \"Slot\" is used in Equidistant **bar spacing** and represents a position on the chart canvas background which may or may not contain a bar. The concept of \"Slots\" does NOT exist on a **TimeBased** bar spacing type.  \n* If you are looking for information on a bar series, please see [ChartBars.GetBarIdxByX()](chartbars_getbaridxbyx).  \n* Since the slot index is based on the chart canvas, the value returned by **GetSlotIndexByX()** can be expected to change as new bars are painted, or as the chart is scrolled backward or forward on the x-axis.\n{% /callout %}\n\n## Method Return Value\n\nA double representing a slot index; returns -1 on a time based bar spacing type.\n\n## Syntax\n\n**<`chartcontrol`>.GetSlotIndexByX(int x)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* x\n* An int used to determine a slot index\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Find the index of the bar painted at x-coordinate 35\n    double slotIndex = chartControl.GetSlotIndexByX(35);\n    \n    // Print the slot index of the specified time\n    Print(slotIndex);\n}\n```"
  },
  {
    "_id": "0f20d88ad6eb84616129c4f43687bd032a727b9e40736b588b0f4b9525e198bf",
    "_type": "desktopSdkDoc",
    "title": "GetTimeByX()",
    "pathName": "gettimebyx",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns a time value related to the primary **Bars** slot index at a specified x-coordinate relative to the **ChartControl**.\n\n{% callout type=\"note\" %}\n\nSince the time is based upon a coordinate of the chart canvas, the value returned by **GetTimeByX()** can be expected to change as new bars are painted on the chart, or as the chart is scrolled backward or forward on the x-axis.\n\n{% /callout %}\n\n## Method Return Value\n\nA **DateTime** object corresponding to a slot index at a specified x-coordinate.\n\n## Syntax\n\n**<`chartcontrol`>.GetTimeByX(int x)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* x\n* The x-coordinate used to find a time value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Find the timestamp of the bar at x-coordinate 100\n   DateTime slotTime = chartControl.GetTimeByX(100);\n \n   // Print the date of slotTime\n   Print(slotTime);\n}\n```"
  },
  {
    "_id": "0913a4eb0cdf3658b6b356ab4d3292fad7dbada52aca251b14083f1a21ddda03",
    "_type": "desktopSdkDoc",
    "title": "GetXByTime()",
    "pathName": "getxbytime",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the chart-canvas x-coordinate of the slot index of the primary **Bars** object corresponding to a specified time.\n\n{% callout type=\"note\" %}\n\nSince the time correlates with a specific bar index, and since bars move on the chart canvas as new bars are painted, the value returned by **GetXByTime()** can be expected to change as new bars are painted on the chart, or as the chart is scrolled backward or forward on the x-axis.\n\n{% /callout %}\n\n## Method Return Value\n\nAn int representing a chart-canvas x-coordinate.\n\n## Syntax\n\n**<`chartcontrol`>.GetXByTime(DateTime time)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* time\n* A [DateTime](datetime) object used to determine an x-coordinate\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   DateTime timeToCheck = new DateTime(2017, 8, 6, 11, 0, 0);\n\n   // Find the chart-canvas x-coordinate of the bar at the specified time\n    int xCoordinate = chartControl.GetXByTime(timeToCheck);\n\n   // Print the x-coordinate value\n   Print(xCoordinate);\n}\n```"
  },
  {
    "_id": "324a1a79e0915fdabc98abf72403851d7ba4566e64a907706948a01f23aa3abb",
    "_type": "desktopSdkDoc",
    "title": "TimePainted",
    "pathName": "timepainted",
    "parent": "charts",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the range of time in which bars are painted on the visible chart canvas.\n\n## Property Value\n\nA TimeSpan measuring the difference between the earliest and latest times at which bars are painted on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.TimePainted**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print a message if less than three hours' worth of data is painted on the chart canvas\n   if(chartControl.TimePainted.Hours < 3)\n       Print(String.Format(\"It is recommended to view at least three hours worth of data on your chart with this indicator. You are currently viewing {0}\", chartControl.TimePainted));\n}\n```\n\n{% callout type=\"note\" %}\n\nNote: TimePainted is intended to be used when Non-Equidistant (time-based) bar spacing is enabled on the chart. Otherwise, it will have a value of 0.\n\n{% /callout %}"
  },
  {
    "_id": "6c35493a2b937829c9815c39e23af964bc84e5430a7dc104c700bbc0de2b59e3",
    "_type": "desktopSdkDoc",
    "title": "Count",
    "pathName": "count",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nThe total number of **ChartBars** in the charts primary data series.\n\n## Property Value\n\nAn **int** value representing the total number of bars.\n\n## Syntax\n\n**ChartBars.Count**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if(ChartBars != null)\n   {\n     Print(\"ChartBars contain \" + ChartBars.Count + \" bars\");\n     //Output:  ChartBars contain 73 bars\n   }\n}\n\n```"
  },
  {
    "_id": "04487aee7bf758381044f0ce61a9e62d055388fdcdb3e81fd1e69d009543d991",
    "_type": "desktopSdkDoc",
    "title": "FromIndex",
    "pathName": "fromindex",
    "parent": "charts",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nAn index value representing the first bar rendered on the chart. See also **ToIndex**.\n\n{% callout type=\"note\" %}\n\nThis value is NOT the first value that exists on the **ChartBars**, but rather the first bar index that is within the viewable range of the chart canvas area. This value changes as the user interacts with the **ChartControl** time-scale (x-axis).\n\n{% /callout %}\n\n## Property Value\n\nAn int representing the first bar index painted on the chart.\n\n## Syntax\n\n**ChartBars.FromIndex**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (ChartBars != null)\n   {\n     // loop through all of the viewable range of the chart\n     for (int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n     {\n         // print the High value for each index within the viewable range\n         Print(High.GetValueAt(barIndex));\n     }\n   }\n}\n```"
  },
  {
    "_id": "9446617b7e22085324cfed925c054f13e928678c5dae2c91cbafaa9f85857cdb",
    "_type": "desktopSdkDoc",
    "title": "GetBarIdxByTime()",
    "pathName": "getbaridxbytime",
    "parent": "charts",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the **ChartBars** index value calculated from the time parameter provided.\n\n## Method Return Value\n\nAn **int** representing the bar index value at a specific time.\n\n## Syntax\n\n**ChartBars.GetBarIdxByTime(ChartControl chartControl, DateTime time)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **chartControl**\n* The **ChartControl** object used to determine the chart's time axis\n\n---\n\n* **time**\n* The **DateTime** value used to convert to a ChartBar index value\n{% /table %}\n\n## Examples\n\n```csharp\n\nprotected override void OnBarUpdate()\n{\n   if (ChartBars != null)\n   {\n     Print(ChartBars.GetBarIdxByTime(ChartControl, Time[0]));  \n   }\n}\n```"
  },
  {
    "_id": "41cf0f0f4e5291d663eea890dc16d2afccde5f9abd23b7467bd917c8194b1ad9",
    "_type": "desktopSdkDoc",
    "title": "GetBarIdxByX()",
    "pathName": "getbaridxbyx",
    "parent": "charts",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the **ChartBars** index value at a specified x-coordinate relative to the ChartControl.\n\n## Method Return Value\n\nAn **int** value representing the bar index.\n\n## Syntax\n\n**ChartBars.GetBarIdxByX(ChartControl chartControl, int x)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **chartControl**\n* The **ChartControl** object used to determine the chart's time axis\n\n---\n\n* **x**\n* The x-coordinate used to find a bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // get the users mouse down point and convert to device pixels for DPI accuracy\n   int mousePoint = chartControl.MouseDownPoint.X.ConvertToHorizontalPixels(chartControl.PresentationSource);\n   \n   // convert mouse point to bar index\n   int barIdx = ChartBars.GetBarIdxByX(chartControl, mousePoint);\n   \n   Print(\"User clicked on Bar #\" + barIdx);\n}\n```"
  },
  {
    "_id": "9580a46312d4f08cc7d6751615994c5c133f2149bf84c0efac66f0279a68e500",
    "_type": "desktopSdkDoc",
    "title": "GetTimeByBarIdx()",
    "pathName": "gettimebybaridx",
    "parent": "charts",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the **ChartBars** time value calculated from a bar index parameter provided.\n\n## Method Return Value\n\nA **DateTime** struct representing a bar time value at a specific bar index value.\n\n## Syntax\n\n**ChartBars.GetTimeByBarIdx(ChartControl chartControl, int barIndex)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **chartControl**\n* The **ChartControl** object used to determine the chart's time axis\n\n---\n\n* **barIndex**\n* An **int** value representing a bar index used to convert to a **ChartBar** index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   if (ChartBars != null)\n   {\n     Print(ChartBars.GetTimeByBarIdx(ChartControl, 50)); //8/11/2015 4:30:00 AM\n   }\n}\n```"
  },
  {
    "_id": "eaac1bdb6c594c3a31fed654f05fd03472069255913e872679ed5171da9ffef4",
    "_type": "desktopSdkDoc",
    "title": "PanelIndex",
    "pathName": "panelindex",
    "parent": "charts",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the index of the chart panel in the collection of configured panels.\n\n{% callout type=\"note\" %}\n\nThis property comes from a zero-based index, which is not the same as the panel number displayed in the Indicators window opened from within the chart. The panel number displayed in the Indicators window will equate to **ChartPanel.PanelIndex** + 1.\n\n{% /callout %}\n\n## Property Value\n\nA int representing the zero-based index of the panel.\n\n## Syntax\n\n**ChartPanel.PanelIndex**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    base.OnRender(chartControl, chartScale);\n\n    // Print the panel's zero-based index\n    Print(String.Format(\"This panel sits at index {0}\", ChartPanel.PanelIndex));\n}\n```\n\nNotice three things in the image below:\n\n* An indicator containing the example code above is configured on the second chart panel.\n* In the Indicators window, the \"Panel\" property is set to 2.\n* The output of the example code displays the zero-based index of Panel #2, which is at index 1.\n\n![ChartPanel_PanelIndex](chartpanel_panelindex.png)"
  },
  {
    "_id": "62a450a3ae6652a43f41f8094326c58e1577d44b69371951dcdc467e85967cb6",
    "_type": "desktopSdkDoc",
    "title": "ScaleJustification",
    "pathName": "scalejustification",
    "parent": "charts",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the location of the chart scale relative to the chart control.\n\n## Property Value\n\nA **ScaleJustification** enum. Possible values are:\n\n* **Right**\n* **Left**\n* **Overlay**\n\n## Syntax\n\n**ScaleJustification**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (chartScale.ScaleJustification == ScaleJustification.Right)\n   {\n     // do something\n   }\n\n}\n```"
  },
  {
    "_id": "c30b8ee5b1a3ac4ccb2add0e8cb485b1fe2ae98f06f4493a6ed4ba18e35c67dd",
    "_type": "desktopSdkDoc",
    "title": "DirectWriteFactory",
    "pathName": "directwritefactory",
    "parent": "rendering",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nProvides a default **DirectWrite** factory used for creating [**SharpDX.DirectWrite**](sharpdx_directwrite) components.\n\n## Property Value\n\nA read-only **SharpDX.DirectWrite.Factory** used to create DirectWrite objects compatible with **NinjaTrader** rendering.\n\n## Syntax\n\n**NinjaTrader.Core.Globals.DirectWriteFactory**\n\n## Examples\n\n```csharp\n// create a text format object with default NinjaTrader DirectWrite factory\n\nSharpDX.DirectWrite.TextFormat textFormat = new SharpDX.DirectWrite.TextFormat(NinjaTrader.Core.Globals.DirectWriteFactory,\n   \"Arial\", 12f);\n\n// create a text layout object with default NinjaTrader DirectWrite factory\n\nSharpDX.DirectWrite.TextLayout textLayout = new SharpDX.DirectWrite.TextLayout(NinjaTrader.Core.Globals.DirectWriteFactory,\n\n   \"text to render\", textFormat, ChartPanel.W, ChartPanel.H);\n```"
  },
  {
    "_id": "638ff34ed784588796f0e7a2ca4d3f6d2e19eef0b2fd57e4ca7a0afcbf98a501",
    "_type": "desktopSdkDoc",
    "title": "Draw.ArrowLine()",
    "pathName": "draw_arrowline",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nDraws an arrow line.\n\n## Method Return Value\n\nAn **ArrowLine** object that represents the draw object.\n\n## Syntax\n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n  * **DashStyleHelper.Dash**  \n  * **DashStyleHelper.DashDot**  \n  * **DashStyleHelper.DashDotDot**  \n  * **DashStyleHelper.Dot**  \n  * **DashStyleHelper.Solid**  \n  Note: Drawing objects with y values very far off the visible canvas can lead to performance hits. Fancier DashStyles like **DashDotDot** will also require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a dotted lime green arrow line\nDraw.ArrowLine(this, \"tag1\", 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);\n```"
  },
  {
    "_id": "8bba89fef0945fef581be912547cbc265cbd47ca853e5a71d7dd986170f99e04",
    "_type": "desktopSdkDoc",
    "title": "Draw.Polygon()",
    "pathName": "draw_polygon",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nDraws a polygon which can have a user defined set of anchors.\n\n## Method Return Value\n\nA **Polygon** object that represents the draw object.\n\n## Syntax\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, bool isGlobal, string templateName)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, Brush brush, DashStyleHelper dashStyle, Brush areaBrush, int areaOpacity)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y, int anchor5BarsAgo, double anchor5Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y, DateTime Anchor5Time, double anchor5Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y, int anchor5BarsAgo, double anchor5Y, int anchor6BarsAgo, double anchor6Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y, DateTime Anchor5Time, double anchor5Y, DateTime Anchor6Time, double anchor6Y)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* chartAnchors\n* A list of the chart anchors.\n\n---\n\n* anchor1BarsAgo\n* The bar the first anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor2BarsAgo\n* The bar the second anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor3BarsAgo\n* The bar the third anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor4BarsAgo\n* The bar the forth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor5BarsAgo\n* The bar the fifth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor6BarsAgo\n* The bar the sixth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor1Y\n* The first anchor y value.\n\n---\n\n* anchor2Y\n* The second anchor y value.\n\n---\n\n* anchor3Y\n* The third anchor y value.\n\n---\n\n* anchor4Y\n* The forth anchor y value.\n\n---\n\n* anchor5Y\n* The fifth anchor y value.\n\n---\n\n* anchor6Y\n* The sixth anchor y value.\n\n---\n\n* Anchor1Time\n* The time the first anchor of the object will be drawn at.\n\n---\n\n* Anchor2Time\n* The time the second anchor of the object will be drawn at.\n\n---\n\n* Anchor3Time\n* The time the third anchor of the object will be drawn at.\n\n---\n\n* Anchor4Time\n* The time the forth anchor of the object will be drawn at.\n\n---\n\n* Anchor5Time\n* The time the fifth anchor of the object will be drawn at.\n\n---\n\n* Anchor6Time\n* The time the sixth anchor of the object will be drawn at.\n\n---\n\n* areaBrush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Draws a Polygon object based on bars ago and y anchors\nDraw.Polygon(this, \"tag1\", false, 20, 194, 10, 184, 13, 176, 25, 182);\n\n// Draws a Polygon object based on a list of anchors with specified times\nList<chartanchor> anchors = new List<chartanchor>();\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 25), 194, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 12), 184, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 7), 176, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 21), 182, ChartControl));\nDraw.Polygon(this, \"tag1\", false, anchors, Brushes.CornflowerBlue, DashStyleHelper.Solid, Brushes.CornflowerBlue, 40);\n\n```"
  },
  {
    "_id": "093deb93fa32838dc12316097db78596c505c04bc55504564df7be7769815aa2",
    "_type": "desktopSdkDoc",
    "title": "Draw.Rectangle()",
    "pathName": "draw_rectangle",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nDraws a rectangle.\n\n## Method Return Value\n\nA **Rectangle** object that represents the draw object.\n\n## Syntax\n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* areaBrush\n* The brush used to color the fill area of the draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Draws a blue rectangle from the low 10 bars back to the high of 5 bars back\nDraw.Rectangle(this, \"tag1\", 10, Low[10] - TickSize, 5, High[5] + TickSize, Brushes.Blue);\n\n// Draws a blue rectangle from the low 10 bars back to the high of 5 bars back with a fill color or pale green with a transparency level of 2\nDraw.Rectangle(this, \"tag1\", false, 10, Low[10] - TickSize, 5, High[5] + TickSize, Brushes.PaleGreen, Brushes.PaleGreen, 2);\n\n```"
  },
  {
    "_id": "be0256bc43cd28db9b0298aa3666c312c12bbd7890a823541f1672d9c7bcccf1",
    "_type": "desktopSdkDoc",
    "title": "Draw.RegionHighlightY()",
    "pathName": "draw_regionhighlighty",
    "parent": "drawing",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nDraws a region highlight y on a chart.\n\n## Method Return Value\n\nA **RegionHighlightY** object that represents the draw object.\n\n## Syntax\n\n**Draw.RegionHighlightY(NinjaScriptBase owner, string tag, double startY, double endY, Brush brush)**  \n\n**Draw.RegionHighlightY(NinjaScriptBase owner, string tag, bool isAutoScale, double startY, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.RegionHighlightY(NinjaScriptBase owner, string tag, double startY, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endY\n* The ending y value co-ordinate where the draw object will be drawn.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](brushes)).\n\n---\n\n* areaBrush\n* The brush used to color the fill area of the draw object ([reference](brushes)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Fills in the region between the startY and endY\nDraw.RegionHighlightY(this, \"tag1\", true, High[0], Low[0], Brushes.Blue, Brushes.Green, 20);\n```"
  },
  {
    "_id": "db49c0794f1828a7028d9000c5fb642239092b0b99e751682c8568b897fe0f76",
    "_type": "desktopSdkDoc",
    "title": "Draw.Text()",
    "pathName": "draw_text",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nDraws text.\n\n## Method Return Value\n\nA **Text** object that represents the draw object.\n\n## Syntax\n\n**Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y)**  \n\n**Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y, Brush textBrush)**  \n\n**Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y, bool isGlobal, string templateName)**  \n\n**Draw.Text(NinjaScriptBase owner, string tag, bool isAutoScale, string text, int barsAgo, double y, int yPixelOffset, Brush textBrush, SimpleFont font, TextAlignment alignment, Brush outlineBrush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Text(NinjaScriptBase owner, string tag, bool isAutoScale, string text, DateTime time, double y, int yPixelOffset, Brush textBrush, SimpleFont font, TextAlignment alignment, Brush outlineBrush, Brush areaBrush, int areaOpacity)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* text\n* The text you wish to draw.\n\n---\n\n* barsAgo\n* The bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* time\n* The time where the draw object will be drawn.\n\n---\n\n* y\n* The y co-ordinate location the object will be drawn.\n\n---\n\n* yPixelOffset\n* The offset value in pixels from within the text box area.\n\n---\n\n* textBrush\n* The brush used to color the text of the draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.textalignment%28v=vs.110%29.aspx)).\n\n---\n\n* font\n* A **Simple Font** object.\n\n---\n\n* alignment\n* **TextAlignment.Center**, **TextAlignment.Left**, **TextAlignment.Right**, **TextAlignment.Justify** ([reference](https://msdn.microsoft.com/en-us/library/system.windows.textalignment(v=vs.110).aspx)).\n\n---\n\n* outlineBrush\n* The brush used to color the text box outline ([reference](http://msdn.microsoft.com/en-us/library/system.drawing.color_members(v=vs.90).aspx)).\n\n---\n\n* areaBrush\n* The brush used to color the text box fill area ([reference](http://msdn.microsoft.com/en-us/library/system.drawing.color_members(v=vs.90).aspx)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws text\nDraw.Text(this, \"tag1\", \"Text to draw\", 10, 1000, Brushes.Black);\n```\n\n{% callout type=\"note\" %}\n\nTip: In some cases, it may be useful to pass in the **ChartControl.Properties** **TextFont** brush as well as the **LabelFont** **SimpleFont** object to render your custom text. This will help ensure that the text will be visible and match what a user has configured for their chart label display settings.\n\n{% /callout %}\n\n```csharp\n\n// match the text brush to what the user has configured on their chart\nDraw.Text(this, \"tag1\", \"Text to draw\", 10, 1000, ChartControl.Properties.ChartText);\n\n```"
  },
  {
    "_id": "d288797487a9dc35105745efa38c15000455abc15039eae1ee66ba1de431a658",
    "_type": "desktopSdkDoc",
    "title": "Draw.VerticalLine()",
    "pathName": "draw_verticalline",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nDraws a vertical line.\n\n## Method Return Value\n\nA **VerticalLine** object that represents the draw object.\n\n## Syntax\n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, Brush brush)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, Brush brush)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, bool isGlobal, string templateName)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* dashStyle\n\t* **DashStyleHelper.Dash**  \n\t* **DashStyleHelper.DashDot**  \n\t* **DashStyleHelper.DashDotDot**  \n\t* **DashStyleHelper.Dot**  \n\t* **DashStyleHelper.Solid**  \n\t  \n\n  Note: Fancier DashStyles like **DashDotDot** will require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a vertical line  \nDraw.VerticalLine(this, \"tag1\", 10, Brushes.Black);\n\n```"
  },
  {
    "_id": "d3e43f83d066d0cc621c971c101d990224e9a9e387b6cd47e8eea834192129aa",
    "_type": "desktopSdkDoc",
    "title": "Instrument",
    "pathName": "instrument",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA tradable symbol. Represents an instance of a **Master Instrument**.\n\n{% callout type=\"note\" %}\n\nWarning: The properties in this class should NOT be accessed within the **OnStateChange()** method before the State has reached State.DataLoaded.\n\n{% /callout %}\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [Exchange](exchange)\n* Exchange of the current instrument\n\n---\n\n* [Expiry](expiry)\n* Expiration date of the futures contract\n\n---\n\n* [FullName](instrument_fullname)\n* Full name of the instrument\n\n---\n\n* [GetInstrument()](getinstrument)\n* Returns an Instrument object by the master instrument name configured in the database.\n\n---\n\n* [MasterInstrument](masterinstrument)\n* An instrument's configuration settings. These are settings and properties which are defined in the **Instrument** window.\n\n---\n\n* FundamentalData\n* Instrument thread specific **FundamentalData** events\n\n---\n\n* MarketData\n* Instrument thread specific **MarketData** events\n\n---\n\n* MarketDepth\n* Instrument thread specific **MarketDepth** events\n\n---\n\n* Dispatcher\n* A Dispatcher used for subscribing to Instrument related events. See **Multi-Threading Considerations**.\n{% /table %}"
  },
  {
    "_id": "68bee3a3bb454b2c36f6ad63241d04638a2680fd096b50bdc928ea3917ef3dc4",
    "_type": "desktopSdkDoc",
    "title": "InstrumentType",
    "pathName": "instrumenttype",
    "parent": "instruments",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the type of instrument.\n\n## Property Value\n\nAn **InstrumentType** representing the type of an instrument.\n\nPossible values are:\n\n* **InstrumentType.Future**\n* **InstrumentType.Stock**\n* **InstrumentType.Index**\n* **InstrumentType.Forex**\n* **InstrumentType.Cfd**\n* **InstrumentType.Cryptocurrency**\n\n## Syntax\n\n**Instrument.MasterInstrument.InstrumentType**\n\n## Examples\n\n```csharp\nif (Instrument.MasterInstrument.InstrumentType == InstrumentType.Future)\n{\n // Do something\n}\nelse\n{\n // Do something else\n}\n```\n\n## Additional Access Information\n\nThis property can be accessed without a null reference check in the **OnBarUpdate()** event handler. When the **OnBarUpdate()** event is triggered, there will always be an **Instrument** object. Should you wish to access this property elsewhere, check for null reference first. e.g. if (**Instrument** != null)"
  },
  {
    "_id": "7ea827ff63e4640e87e79da2f09dd0c4ea5528f2c95c935612a1392e5432c241",
    "_type": "desktopSdkDoc",
    "title": "SetState()",
    "pathName": "setstate",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nThis method is used for changing the **State** of any running NinjaScript object.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* Attempting to set a State earlier than the current State will be ignored.\n* Calling **SetState()** multiple times will be ignored to prevent the object from erroneously setting states unexpectedly.\n* Setting State to **State.Terminated** is meant as a way to abort the strategy as it is running. Doing this in a Strategy Analyzer backtest will abort the backtest entirely, and no partial backtest results will be shown.\n* After setting **State.Terminated**, you should return from the calling method to help ensure subsequent logic is not processed asynchronously to **OnStateChange()**.\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**SetState(State state)**\n\n{% callout type=\"warning\" %}\n\nThis method should only be called after the **State** reaches **State.DataLoaded**.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **state**\n* The **State** to be set\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Terminate strategy at 2PM\n   if (ToTime(Time[0]) == 140000)\n   {\n     SetState(State.Terminated);\n     return;\n   }\n}\n```"
  },
  {
    "_id": "b6bce5fe36b74d475463b2370a664f90b757455a8001b835f73cfc2cd7b7dd0b",
    "_type": "desktopSdkDoc",
    "title": "Accumulation/Distribution (ADL)",
    "pathName": "accumulation_distribution_adl",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThere are many indicators available to measure volume and the flow of money for a particular stock, index or security. One of the most popular volume indicators over the years has been the Accumulation/Distribution Line. The basic premise behind volume indicators, including the Accumulation/Distribution Line, is that volume precedes price. Volume reflects the amount of shares traded in a particular stock, and is a direct reflection of the money flowing into and out of a stock. Many times before a stock advances, there will be period of increased volume just prior to the move. Most volume or money flow indicators are designed to identify early increases in positive or negative volume flow to gain an edge before the price moves. (Note: the terms \"money flow\" and \"volume flow\" are essentially interchangeable.)\n\n## Syntax\n\n**ADL()**\n\n**ADL(ISeries<`double`> input)**\n\nReturns default value\n\n**ADL()[int barsAgo]**\n\n**ADL[ISeries<`double`> input](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n\n---\n\n* Indicator [source data](valid_input_data_for_indicator)\n{% /table %}\n\n## Example\n\n```csharp\n// Evaluates if ADL is rising\nbool isRising = IsRising(ADL());\nPrint(\"Is ADL rising? \" + isRising);\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "45278cb840d8fa53c0f4b574b66b530e6bbc9432b2191d533d0d4fca3c46b949",
    "_type": "desktopSdkDoc",
    "title": "Adaptive Price Zone (APZ)",
    "pathName": "adaptive_price_zone_apz",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Adaptive Price Zone indicator from the S&C, September 2006 article \"Trading With An Adpative Price Zone\" by Lee Leibfarth is a set of bands based on a short term double smooth exponential moving average. The bands form a channel that surrounds the average price and tracks price fluctuations quickly, especially in volatile markets. As price crosses above the zone it can signal an opportunity to sell in anticipation of a reversal. As price crosses below the zone it can signal an opportunity to buy in anticipation of a reversal.\n\n## Syntax\n\n**APZ(double bandPct, int period)**\n\n**APZ(ISeries<`double`> input, double bandPct, int period)**\n\nReturns upper band value\n\n**APZ(double bandPct, int period).Upper[int barsAgo]**\n\n**APZ(ISeries<`double`> input, double bandPct, int period).Upper[int barsAgo]**\n\nReturns lower band value\n\n**APZ(double bandPct, int period).Lower[int barsAgo]**\n\n**APZ(ISeries<`double`> input, double bandPct, int period).Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* bandPct\n* The number of standard deviations\n\n---\n\n* input\n* Indicator source data\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current upper band value of a 20 period APZ\ndouble upperValue = APZ(2, 20).Upper[0];\nPrint(\"The current APZ upper value is \" + upperValue.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "dd16713ee555b089e5c033a85b45d5ad9e2cc1aa3e879d3fe094f606f7f514cb",
    "_type": "desktopSdkDoc",
    "title": "Aroon",
    "pathName": "aroon",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by Tushar Chande in 1995, Aroon is an indicator system that can be used to determine whether a stock is trending or not and how strong the trend is. \"Aroon\" means \"Dawn's Early Light\" in Sanskrit and Chande chose that name for this indicator since it is designed to reveal the beginning of a new trend.\n\nThe Aroon indicator system consists of two lines, **Aroon(up)** and **Aroon(down)**. It takes a single parameter which is the number of time periods to use in the calculation. Aroon(up) is the amount of time (on a percentage basis) that has elapsed between the start of the time period and the point at which the highest price during that time period occurred. If the stock closes at a new high for the given period, Aroon(up) will be +100. For each subsequent period that passes without another new high, Aroon(up) moves down by an amount equal to (1 / # of periods) x 100.\n\n## Syntax\n\n**Aroon(int period)**\n**Aroon(ISeries<`double`> input, int period)**\n\nReturns up value\n\n**Aroon(int period).Up[int barsAgo]**\n**Aroon(ISeries<`double`> input, int period).Up[int barsAgo]**\n\nReturns down value\n\n**Aroon(int period).Down[int barsAgo]**\n**Aroon(ISeries<`double`> input, int period).Down[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current up/down values of a 20 period Aroon indicator\ndouble upValue = Aroon(20).Up[0];\ndouble downValue = Aroon(20).Down[0];\nPrint(\"The current Aroon up value is \" + upValue);\nPrint(\"The current Aroon down value is \" + downValue);\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "75d20faac7f4d2aa4d6b925431fa545f0643d1565034e993b2eb4097b64be482",
    "_type": "desktopSdkDoc",
    "title": "Aroon Oscillator",
    "pathName": "aroon_oscillator",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nA trend-following indicator that uses aspects of the Aroon indicator (\"Aroon up\" and \"Aroon down\") to gauge the strength of a current trend and the likelihood that it will continue. The Aroon oscillator is calculated by subtracting Aroon down from Aroon up. Readings above zero indicate that an uptrend is present, while readings below zero indicate that a downtrend is present.\n\nCourtesy of [Investopedia](http://investopedia.com/terms/a/aroonoscillator.asp)\n\n## Syntax\n\n**AroonOscillator(int period)**  \n\n**AroonOscillator(ISeries<`double`> input, int period)**\n\nReturns default value  \n\n**AroonOscillator[int period](int barsAgo)**  \n\n**AroonOscillator[ISeries<`double`> input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current values of a 20 period AroonOscillator using default price type\ndouble upValue = AroonOscillator(20)[0];\nPrint(\"The current AroonOscillator value is \" + upValue.ToString());\n\n// Prints the current values of a 20 period AroonOscillator using high price type\ndouble upValue = AroonOscillator(High, 20)[0];\nPrint(\"The current AroonOscillator value is \" + upValue.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "93939c37a51683b39f9a96a76c9a36b5b92685df27e61360256383104427260d",
    "_type": "desktopSdkDoc",
    "title": "Average Directional Index (ADX)",
    "pathName": "average_directional_index_adx",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nAn indicator used in technical analysis as an objective value for the strength of trend. ADX is non-directional so it will quantify a trend's strength regardless of whether it is up or down. ADX is usually plotted in a chart window along with two lines known as the DMI (Directional Movement Indicators). ADX is derived from the relationship of the DMI lines.\n\n... Courtesy of [Investopedia](http://investopedia.com/terms/a/adx.asp)\n\n## Syntax\n\n**ADX(int period)**  \n\n**ADX(ISeries<`double`> input, int period)**\n\nReturns default value  \n\n**ADX[int period](int barsAgo)**  \n\n**ADX[ISeries<`double`> input, int period](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period ADX\ndouble value = ADX[20](0);\nPrint(\"The current ADX value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "0caa0c2cf9f209eb88d67b7aa582f43d9752c492fa20ba123452290138bb11b2",
    "_type": "desktopSdkDoc",
    "title": "Average Directional Movement Rating (ADXR)",
    "pathName": "average_directional_movement_rating_adxr",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe ADXR is equal to the current [ADX](average_directional_index_adx) plus the ADX from n bars ago divided by two.\n\n## Syntax\n\n**ADXR(int interval, int period)**\n\n**ADXR(ISeries<`double`> input, int interval, int period)**\n\nReturns default value\n\n**ADXR[int interval, int period](int barsAgo)**\n\n**ADXR[ISeries<`double`> input, int interval, int period](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* Indicator source data\n\n---\n\n* interval\n* The interval between the first ADX value and the current ADX value\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value of a 20 period ADXR using default price type\ndouble value = ADXR(10, 20)[0];\nPrint(\"The current ADXR value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "39826898489bf81e083db898a29fa979b6b71a2acd2bc56ecdc815e2ff963a91",
    "_type": "desktopSdkDoc",
    "title": "Average True Range (ATR)",
    "pathName": "average_true_range_atr",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nA measure of volatility introduced by Welles Wilder in his book: New Concepts in Technical Trading Systems.\n\nThe True Range indicator is the greatest of the following:\n\n* current high less the current low.\n* the absolute value of the current high less the previous close.\n* the absolute value of the current low less the previous close.\n\nThe Average True Range is a moving average (generally 14-days) of the True Ranges.\n\n... Courtesy of [Investopedia](http://www.investopedia.com/terms/a/atr.asp)\n\nThe original Wilder formula for an exponential moving average with a smoothing constant (k = 1/ Period) is used to calculate the ATR.\n\n## Syntax\n\n**ATR(int period)**  \n**ATR(ISeries<`double>` input, int period)**\n\nReturns default value  \n**ATR[int period](int barsAgo)**  \n**ATR[ISeries<`double`> input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data\n\n---\n\n* period\n\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value of a 20 period ATR using default price type\ndouble value = ATR(20)[0];\nPrint(\"The current ATR value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "10a1af20bcac8704156bc83543971e234098c520871783115fcf5055653eeb6d",
    "_type": "desktopSdkDoc",
    "title": "Balance of Power (BOP)",
    "pathName": "balance_of_power_bop",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe balance of power (BOP) indicator measures the strength of the bulls vs. bears by assessing the ability of each to push price to an extreme level.\n\n## Syntax\n\n**BOP(int smooth)**\n**BOP(ISeries<`double`> input, int smooth)**\n\nReturns default value  \n\n**BOP(int smooth)[int barsAgo]**  \n**BOP(ISeries<`double`> input, int smooth)[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* smooth\n\n---\n\n* Indicator source data\n* The smoothing period\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value of BOP using default price type and 3 period smoothing\ndouble value = BOP(3)[0];\nPrint(\"The current BOP value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "3c65743c477b0db9a4edf19d8efdd49b425a1d98814136587325f5d558241f78",
    "_type": "desktopSdkDoc",
    "title": "Block Volume",
    "pathName": "block_volume",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nBlock volume detects block trades and display how many occurred per bar. This can be displayed either as trades or volume. Historical tick data is required to plot historically.\n\n## Syntax\n\n**BlockVolume(int blockSize, CountType countType)**\n\n**BlockVolume(ISeries<`double`> input, int blockSize, CountType countType)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* Indicator source data\n\n---\n\n* blockSize\n* The minimum volume a trade must be to be considered a block trade\n\n---\n\n* countType\n* The format to count the block trades. By number of block trades that occurred or total block trade volume\n{% /table %}\n\n## Examples\n\n```csharp\n// A 1 tick data series must be added to OnStateChange() as this indicator runs off of tick data\nelse if (State == State.Configure)\n{\n   AddDataSeries(Data.BarsPeriodType.Tick, 1);\n}\n \n// Prints the current value of an 80 block trade size counted in volume for the Block Volume\nif (BarsInProgress == 0)\n{\ndouble value = BlockVolume(80, CountType.Volume)[0];\nPrint(\"The current Block Volume value is \" + value.ToString());\n}\n```"
  },
  {
    "_id": "ab9b117f824acffe920b6bea72b9ac3acd70562d0b9015ea2e7a7a4331909387",
    "_type": "desktopSdkDoc",
    "title": "Bollinger Bands",
    "pathName": "bollinger_bands",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by John Bollinger, Bollinger Bands are an indicator that allows users to compare volatility and relative price levels over a period time. The indicator consists of three bands designed to encompass the majority of a security's price action.\n\n1. A simple moving average in the middle\n2. An upper band (SMA plus 2 standard deviations)\n3. A lower band (SMA minus 2 standard deviations)\n\nStandard deviation is a statistical unit of measure that provides a good assessment of a price plot's volatility. Using the standard deviation ensures that the bands will react quickly to price movements and reflect periods of high and low volatility. Sharp price increases (or decreases), and hence volatility, will lead to a widening of the bands.\n\n... Courtesy of [StockCharts](http://stockcharts.com/education/IndicatorAnalysis/indic_Bbands.html)\n\n## Syntax\n\n**Bollinger(double numStdDev, int period)**  \n**Bollinger(ISeries<`double`> input, double numStdDev, int period)**\n\nReturns upper band value  \n**Bollinger(double numStdDev, int period).Upper[int barsAgo]**  \n**Bollinger(ISeries<`double`> input, double numStdDev, int period).Upper[int barsAgo]**\n\nReturns lower band value  \n**Bollinger(double numStdDev, int period).Lower[int barsAgo]**  \n**Bollinger(ISeries<`double`> input, double numStdDev, int period).Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator [source data](valid_input_data_for_indicator)\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current upper band value of a 20 period Bollinger using default price type\ndouble upperValue = Bollinger(2, 20).Upper[0];\nPrint(\"The current Bollinger upper value is \" + upperValue.ToString());\n\n// Prints the current upper band value of a 20 period Bollinger using low price type\ndouble upperValue = Bollinger(Low, 2, 20).Upper[0];\nPrint(\"The current Bollinger upper value is \" + upperValue.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "98096314a3b91edd0c30cc2f4b5c3b8082efcb958ed8d6fa0f3de30099352fd9",
    "_type": "desktopSdkDoc",
    "title": "BuySell Pressure",
    "pathName": "buysell_pressure",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe **BuySellPressure** indicator displays both the current bar's buying and selling pressure as percentage values based on the categorization of trades as buy or sell trades. Trades are categorized in real-time as a buy (at the ask or above) or as a sell (at the bid or below). Trades in between the market are ignored.\n\n{% callout type=\"note\" %}\n\nFor historical calculations, [Tick Replay](tick_replay) must be enabled.\n\n{% /callout %}\n\n## Syntax\n\n**BuySellPressure()**  \n\n**BuySellPressure(ISeries`<double>` input)**\n\n## Returns buy pressure value  \n\n**BuySellPressure().BuyPressure[int barsAgo]**  \n\n**BuySellPressure(ISeries`<double>` input).BuyPressure[int barsAgo]**\n\n## Returns sell pressure value  \n\n**BuySellPressure().SellPressure[int barsAgo]**  \n\n**BuySellPressure(ISeries`<double>` input).SellPressure[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.SetDefaults)\n    {\n        // Indicators will inherit the Calculate mode from the hosting script.\n        // Since BuySellPressure requires the use of Calculate.OnEachTick, we must ensure the hosting script has this Calculate mode set\n        Calculate = Calculate.OnEachTick;\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // This checks that 70% or more of the volume hit the ask or higher\n    if (State == State.Historical || BuySellPressure().BuyPressure[0] > 70)\n    {\n        EnterLong();\n    }\n}\n```\n\n{% callout type=\"note\" %}\n\nTip: Since this indicator operates in a real-time environment, remember to check for **State.Realtime**, or enable **Tick Replay** on the associated Data Series. In the above example we check that 50% or more of the volume hit the ask or higher. Our statement checks if the data is being calculated on historical data first, if true, we enter long, if not true (live), the statement then checks for the Buy Volume condition.\n\n{% /callout %}\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "db1270cfe406c620712843b81e6f91d61858d6e03e4dfc5cf4749e69d0249a73",
    "_type": "desktopSdkDoc",
    "title": "BuySell Volume",
    "pathName": "buysell_volume",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe **BuySellVolume** indicator displays a real-time horizontal histogram of volume categorized as buy or sell trades. Trades are categorized in real-time as a buy (at the ask or above) or as a sell (at the bid or below) and then color coded. Trades in between the market are ignored.\n\n{% callout type=\"note\" %}\n\nFor historical calculations, [Tick Replay](tick_replay) must be enabled.\n\n{% /callout %}\n\n## Syntax\n\n**BuySellVolume()**  \n\n**BuySellVolume(ISeries`<double>` input)**\n\nReturns buy volume  \n\n**BuySellVolume().Buys[int barsAgo]**  \n\n**BuySellVolume(ISeries`<double>` input).Buys[int barsAgo]**\n\nReturns sell volume  \n\n**BuySellVolume().Sells[int barsAgo]**  \n\n**BuySellVolume(ISeries`<double>` input).Sells[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* **Parameter**\n* **Description**\n\n---\n\n* **input**\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.SetDefaults)\n    {\n        // Indicators will inherit the Calculate mode from the hosting script.\n        // Since BuySellVolume requires the use of Calculate.OnEachTick, we must ensure the hosting script has this Calculate mode set\n        Calculate = Calculate.OnEachTick;\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // This checks that 5,000 or more of the volume hit the bid or lower\n    if (State == State.Historical || BuySellVolume().Sells[0] > 5000)\n    {\n        EnterLong();      \n    }\n}\n```\n\n{% callout type=\"note\" %}\n\nTip: Since this indicator operates in a real-time environment, remember to check for **State.Realtime**, or enable **Tick Replay** on the associated Data Series. In the above example we check that 5,000 or more of the volume hit the bid or lower. Our statement checks if the data is being calculated on historical data first; if true, we enter long. If not true (live), the statement then checks for the Buy Volume condition.\n\n{% /callout %}\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "10d54d83def96bb4d35c37fc23b5fd88a9c44385485e1e6f00f0d535e7c45f14",
    "_type": "desktopSdkDoc",
    "title": "Camarilla Pivots",
    "pathName": "camarilla_pivots",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nCamarilla pivots are a price analysis tool that generates potential support and resistance levels by multiplying the prior range then adding or subtracting it from the close.\n\n## Syntax\n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)**\n\nReturns R1 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]**\n\nReturns R2 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]**\n\nReturns R3 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]**\n\nReturns R4 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R4[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R4[int barsAgo]**\n\nReturns S1 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]**\n\nReturns S2 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]**\n\nReturns S3 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]**\n\nReturns S4 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S4[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S4[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* **pivotRangeType**\n* Sets the range for the type of pivot calculated. Possible values are:  \n**PivotRange.Daily**  \n**PivotRange.Weekly**  \n**PivotRange.Monthly**\n\n---\n\n* **priorDayHLC**\n* Sets how the prior range High, Low, Close values are calculated. Possible values are:  \n**HLCCalculationMode.CalcFromIntradayData**  \n**HLCCalculationMode.DailyBars**  \n**HLCCalculationMode.UserDefinedValues**\n\n---\n\n* **userDefinedClose**\n* Sets the close for Pivots calculations when using **HLCCalculationMode.UserDefinedValues**.\n\n---\n\n* **userDefinedHigh**\n* Sets the high for Pivots calculations when using **HLCCalculationMode.UserDefinedValues**.\n\n---\n\n* **userDefinedLow**\n* Sets the low for Pivots calculations when using **HLCCalculationMode.UserDefinedValues**.\n\n---\n\n* **width**\n* Sets how long the Pivots lines will be drawn\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current R1 pivot value  \ndouble valueR1 = CamarillaPivots(PivotRange.Daily, HLCCalculationMode.CalcFromIntradayData, 0, 0, 0, 20).R1[0];  \nPrint(\"The current Camarilla Pivots' R1 value is \" + valueR1.ToString());  \n// Prints the current S2 pivot value  \ndouble valueS2 = CamarillaPivots(PivotRange.Daily, HLCCalculationMode.CalcFromIntradayData, 0, 0, 0, 20).S2[0];  \nPrint(\"The current Camarilla Pivots' S2 pivot value is \" + valueS2.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.\n\n{% callout type=\"note\" %}\n\n* When using **HLCCalculationMode.DailyBars** it can be expected that a value of 0 is returned when the daily bars have not been loaded yet. Due to the asynchronous nature of this indicator calling daily bars you should only access the pivot values when the indicator has loaded all required Bars objects. To ensure you are accessing accurate values you can use **.[IsValidDataPoint()**](isvaliddatapoint) as a check:\n\n{% /callout %}\n\n```csharp\nif (CamarillaPivots(PivotRange.Daily, HLCCalculationMode.DailyBars, 0, 0, 0, 20).Pp.IsValidDataPoint(0))  \n{  \n    // Prints the current pivot point value  \n    double valuePp = CamarillaPivots(PivotRange.Daily, HLCCalculationMode.DailyBars, 0, 0, 0, 20).Pp[0];  \n    Print(\"The current Camarilla Pivots' pivot value is \" + valuePp.ToString());  \n}\n```"
  },
  {
    "_id": "bf402e437c2834137343ff25e9373e8c503a4c04a8931aaf302fb091b5e4a38e",
    "_type": "desktopSdkDoc",
    "title": "CandleStickPattern",
    "pathName": "candlestickpattern",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDetects the specified candle stick pattern.\n\n## Syntax\n\n**CandleStickPattern(ChartPattern pattern, int trendStrength)**  \n**CandleStickPattern(ISeries`<double>` input, ChartPattern pattern, int trendStrength)**\n\nReturns a value indicating if the specified pattern was detected  \n**CandleStickPattern[ChartPattern pattern, int trendStrength](int barsAgo)**  \n**CandleStickPattern[ISeries`<double>` input, ChartPattern pattern, int trendStrength](int barsAgo)**\n\n## Return Value\n\nA **double** value representing pattern found. Returns a value of 1 if the pattern is found; returns a value of 0 if no pattern was found.\n\nAccessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* pattern\n* Possible values are:\n  * **ChartPattern.BearishBeltHold**\n  * **ChartPattern.BearishEngulfing**\n  * **ChartPattern.BearishHarami**\n  * **ChartPattern.BearishHaramiCross**\n  * **ChartPattern.BullishBeltHold**\n  * **ChartPattern.BullishEngulfing**\n  * **ChartPattern.BullishHarami**\n  * **ChartPattern.BullishHaramiCross**\n  * **ChartPattern.DarkCloudCover**\n  * **ChartPattern.Doji**\n  * **ChartPattern.DownsideTasukiGap**\n  * **ChartPattern.EveningStar**\n  * **ChartPattern.FallingThreeMethods**\n  * **ChartPattern.Hammer**\n  * **ChartPattern.HangingMan**\n  * **ChartPattern.InvertedHammer**\n  * **ChartPattern.MorningStart**\n  * **ChartPattern.PiercingLine**\n  * **ChartPattern.RisingThreeMethods**\n  * **ChartPattern.ShootingStar**\n  * **ChartPattern.StickSandwich**\n  * **ChartPattern.ThreeBlackCrows**\n  * **ChartPattern.ThreeWhiteSoldiers**\n  * **ChartPattern.UpsideGapTwoCrows**\n  * **ChartPattern.UpsideTasukiGap**\n\n---\n\n* trendStrength\n* The number of required bars to the left and right of the swing point used to determine trend. A value of zero will exclude the requirement of a trend and only detect based on the candles themselves.\n{% /table %}\n\n## Examples\n\n```csharp\n// Go long if the current bar is a bullish engulfing pattern\nif (CandleStickPattern(ChartPattern.BullishEngulfing, 4)[0] == 1)\n    EnterLong();\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "aae277c226d20d1eecfad40346ce3e9358928589e3178f262f821dadfcd90714",
    "_type": "desktopSdkDoc",
    "title": "Chaikin Money Flow",
    "pathName": "chaikin_money_flow",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe formula for **Chaikin Money Flow** is the cumulative total of the Accumulation/Distribution Values for 21 periods divided by the cumulative total of volume for 21 periods.\n\n... Courtesy of [StockCharts](stockcharts)\n\n## Syntax\n\n**ChaikinMoneyFlow**(int period)  \n\n**ChaikinMoneyFlow**(ISeries`<double>` input, int period)\n\nReturns default value  \n\n**ChaikinMoneyFlow**[int period](int barsAgo)  \n\n**ChaikinMoneyFlow**[ISeries`<double>` input, int period](int barsAgo)\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period ChaikinMoneyFlow using default price type\ndouble value = ChaikinMoneyFlow[20](0);\nPrint(\"The current **ChaikinMoneyFlow** value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "cafb38167477d103f7cc21c2b1a9c9b1e1b112528d45ef184985dafc12f1db6e",
    "_type": "desktopSdkDoc",
    "title": "Chaikin Oscillator",
    "pathName": "chaikin_oscillator",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Chaikin Oscillator is simply the Moving Average Convergence Divergence indicator (MACD) applied to the Accumulation/Distribution Line. The formula is the difference between the 3-day exponential moving average and the 10-day exponential moving average of the Accumulation/Distribution Line. Just as the MACD-Histogram is an indicator to predict moving average crossovers in MACD, the Chaikin Oscillator is an indicator to predict changes in the Accumulation/Distribution Line.\n\n... Courtesy of [StockCharts](stockcharts)\n\n## Syntax\n\n**ChaikinOscillator**(int fast, int slow)  \n\n**ChaikinOscillator**(ISeries`<double>` input, int fast, int slow)\n\nReturns default value  \n\n**ChaikinOscillator**[int fast, int slow](int barsAgo)  \n\n**ChaikinOscillator**[ISeries`<double>` input, int fast, int slow](int barsAgo)\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* fast\n* input\n* slow\n\n---\n\n* The number of bars to calculate the fast **EMA**\n* Indicator source data ([?](valid_input_data_for_indicator))\n* The number of bars to calculate the slow **EMA**\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a ChaikinOscillator using default price type\ndouble value = ChaikinOscillator(3, 10)[0];\nPrint(\"The current ChaikinOscillator value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "4b874f5094523ebd01a23aee30bb42380af61903833638f78463a2ddd364a583",
    "_type": "desktopSdkDoc",
    "title": "Chaikin Volatility",
    "pathName": "chaikin_volatility",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Chaikin Volatility Indicator is the difference between two moving averages of a volume weighted accumulation-distribution line. By comparing the spread between a security's high and low prices, it quantifies volatility as a widening of the range between the high and the low price.\n\n## Syntax\n\n**ChaikinVolatility(int mAPeriod, int rOCPeriod)**  \n\n**ChaikinVolatility(ISeries`<double>` input, int mAPeriod, int rOCPeriod)**  \n\nReturns default value  \n\n**ChaikinVolatility**[int mAPeriod, int rOCPeriod](int barsAgo)  \n\n**ChaikinVolatility**[ISeries`<double>` input, int mAPeriod, int rOCPeriod](int barsAgo)\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* mAPeriod\n* Number of bars used in the moving average calculation\n\n---\n\n* rOCPeriod\n* Number of bars used in the rate of change calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of the 20 period Chaikin Volatility\ndouble value = ChaikinVolatility(20, 20)[0];\nPrint(\"The current Chaikin Volatility value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "a0ba1704d31771fc9c04ff2f58713ce0e23ef60104cd626bf1d8a02467359a93",
    "_type": "desktopSdkDoc",
    "title": "Chande Momentum Oscillator (CMO)",
    "pathName": "chande_momentum_oscillator_cmo",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Chande Momentum Oscillator was developed by Tushar S. Chande and is described in the 1994 book The New Technical Trader by Tushar S. Chande and Stanley Kroll. This indicator is a modified **RSI**. Where the **RSI** divides the upward movement by the net movement (up / (up + down)), the **CMO** divides the total movement by the net movement ((up - down) / (up + down)). Values under -50 indicate oversold conditions while values over 50 indicate overbought conditions.\n\n## Syntax\n\n**CMO(int period)**  \n\n**CMO(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**CMO[int period](int barsAgo)**  \n\n**CMO[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([**?**](valid_input_data_for_indicator.htm))\n\n---\n\n* period\n* The number of bars to include in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period CMO using default price type\ndouble value = CMO(20)[0];\nPrint(\"The current CMO value is \" + value.ToString());\n```\n\n```csharp\n// Prints the current value of a 20 period CMO using high price type\ndouble value = CMO(High, 20)[0];\nPrint(\"The current CMO value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "007d331354e96d46a5b82b89d78e90206c4c58476eb9de4e2352b59ccf5c1253",
    "_type": "desktopSdkDoc",
    "title": "Choppiness Index",
    "pathName": "choppiness_index",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Choppiness Index is designed to determine if the market is choppy (trading sideways) or not choppy (trading within a trend in either direction).\n\n## Syntax\n\n**ChoppinessIndex(int period)**\n\n**ChoppinessIndex(ISeries`<double>` input, int period)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **int barsAgo** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 14 period Choppiness Index\ndouble value = ChoppinessIndex(14)[0];\nPrint(\"The current Choppiness Index value is \" + value.ToString());\n```"
  },
  {
    "_id": "13c127eb661d9a8a49281f7acfce028bec9242c0d4f90fdb58bb66452b620979",
    "_type": "desktopSdkDoc",
    "title": "Commitment Of Traders (COT)",
    "pathName": "commitment_of_traders_cot",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe COT indicator plots weekly data from the Commitment Of Traders report, indicating holdings of different participants in the U.S. futures market.\n\n{% callout type=\"note\" %}\n\nNotes:  \n\n1. Since the underlying COT reports are a weekly figure updated every Friday, it would not be meaningful to run this study outside **Calculate.OnBarClose**.  \n2. Default values of the 5 hard-coded plots are: 1 - Futures Non Commercial Net, 2 - Futures Commercial Net, 3 - Futures Non Reportable Positions Net, 4 - Futures Open Interest, 5 - Futures Total Net.  \n3. To access other reports and report fields, please see the 2nd example below. All fields available could be seen via **Intelliprompt** in the NinjaScript editor.  \n4. In the **CotReportField** enum, \"Pmpu\" represents: \"Producer/merchant/processor/user\" where **CotReportField.PmpuNet** would represent: \"Producer/merchant/processor/user Net\".  \n5. If a **CotReportField** enum is used that is not supported by the **ReportType**, OpenInterest will be seen.  \n{% /callout %}\n\n## Syntax\n\n**COT(int number)**\n\nReturns **Cot1** value  \n\n**COT(int number).Cot1[int barsAgo]**\n\nReturns **Cot2** value  \n\n**COT(int number).Cot2[int barsAgo]**\n\nReturns **Cot3** value  \n\n**COT(int number).Cot3[int barsAgo]**\n\nReturns **Cot4** value  \n\n**COT(int number).Cot4[int barsAgo]**\n\nReturns **Cot5** value  \n\n**COT(int number).Cot5[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* number\n* Sets the number of plots enabled\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of COT 4th plot (default Futures Open Interest), the COT(4) would allow us to access the Cot1, Cot2, Cot3 and Cot4 plots, but not Cot5 (since not enabled)  \ndouble value = COT(4).Cot4[0];  \nPrint(\"The current COT Futures Open Interest value is \" + value.ToString());\n\n// Advanced example where two plots in total are enabled (COT(2)). Next, the ReportType and Field are custom set per each plot.  \nelse if (State == State.DataLoaded)  \n{  \n    cot1 = COT(2);  \n    cot1.CotReport1.ReportType = CotReportType.Combined;  \n    cot1.CotReport2.ReportType = CotReportType.Combined;  \n    cot1.CotReport1.Field = CotReportField.OpenInterest;  \n    cot1.CotReport2.Field = CotReportField.TotalNet;  \n}  \n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > **NinjaScript Editor** > **Indicators** within the NinjaTrader Control Center window."
  },
  {
    "_id": "d6a7d4b475fea7b0cf8a04b268b2f95406984e6d55f43dc835176f12d10445f1",
    "_type": "desktopSdkDoc",
    "title": "Commodity Channel Index (CCI)",
    "pathName": "commodity_channel_index_cci",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by Donald Lambert, the Commodity Channel Index (CCI) was designed to identify cyclical turns in commodities. The assumption behind the indicator is that commodities (or stocks or bonds) move in cycles, with highs and lows coming at periodic intervals.\n\n... Courtesy of [StockCharts](http://stockcharts.com/education/IndicatorAnalysis/indic_CCI.html)\n\n## Syntax\n\n**CCI(int period)**  \n\n**CCI(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**CCI[int period](int barsAgo)**  \n\n**CCI[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([?](valid_input_data_for_indicator.htm))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Prints the current value of a 20 period CCI using default price type\ndouble value = CCI[20](0);\nPrint(\"The current CCI value is \" + value.ToString());\n\n// Prints the current value of a 20 period CCI using high price type\ndouble value = CCI[High, 20](0);\nPrint(\"The current CCI value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "577bf0c4f4ee4f887ec975d9f5356309244babf9fad24797025228a2092d78fd",
    "_type": "desktopSdkDoc",
    "title": "Correlation",
    "pathName": "correlation",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe correlation indicator will plot the correlation of the data series to a desired instrument. Values close to 1 indicate movement in the same direction. Values close to -1 indicate movement in opposite directions. Values near 0 indicate no correlation.\n\n## Syntax\n\n**Correlation(int period, string correlationSeries)**  \n\n**string correlationSeies(ISeries`<double>` input, int period, string correlationSeies)**\n\n## Return Value\n\n**double**; Accessing this method via an index value **int barsAgo** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n* correlationSeries\n* The data series to compare to\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n\n// The correlation data series must be added to OnStateChange() as this indicator runs off the correlation data series data\nelse if (State == State.Configure)\n{\n   AddDataSeries(\"SPY\");\n}\n\n// Checks the bars in progress and prints the current correlation to the SPY\nif (BarsInProgress == 0)\n{\n   double value = Correlation[20, \"SPY\"](0);\n   Print(\"The current correlation to the SPY is \" + value.ToString());\n}\n```\n\n{% callout type=\"note\" %}\n\nIf the correlation series does not plot during a time the input series plots, a value of zero would plot in the above example. You may consider ignoring zero values.\n\n{% /callout %}\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "24ad0e217c9be8e06a2968eafc44cc490a95171b74b6bb2327e1ff684c6e18e2",
    "_type": "desktopSdkDoc",
    "title": "Current Day OHL",
    "pathName": "current_day_ohl",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe current day (session) open, high and low values.\n\n{% callout type=\"note\" %}\n\nOnly use this indicator on intraday series.\n\n{% /callout %}\n\n## Syntax\n\n**CurrentDayOHL()**  \n\n**CurrentDayOHL(ISeries`<double>` input)**\n\n## Returns current session open value  \n\n**CurrentDayOHL().CurrentOpen[int barsAgo]**  \n\n**CurrentDayOHL(ISeries`<double>` input).CurrentOpen[int barsAgo]**\n\n## Returns current session high value  \n\n**CurrentDayOHL().CurrentHigh[int barsAgo]**  \n\n**CurrentDayOHL(ISeries`<double>` input).CurrentHigh[int barsAgo]**\n\n## Returns current session low value  \n\n**CurrentDayOHL().CurrentLow[int barsAgo]**  \n\n**CurrentDayOHL(ISeries`<double>` input).CurrentLow[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of the session low\ndouble value = CurrentDayOHL().CurrentLow[0];\nPrint(\"The current session low value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "b17ca88bd78f01f4ba473ce1ed73a725db122251209bd2902ac80d4c5407e6d8",
    "_type": "desktopSdkDoc",
    "title": "Darvas",
    "pathName": "darvas",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nA trading strategy that was developed in 1956 by former ballroom dancer Nicolas Darvas. Darvas' trading technique involved buying into stocks that were trading at new 52-week highs with correspondingly high volumes.\n\n... Courtesy of [Investopedia](investopedia)\n\n## Syntax\n\n**Darvas()**\n\n**Darvas(ISeries`<double>` input)**\n\nReturns the upper value\n\n**Darvas().Upper[int barsAgo]**\n\n**Darvas(ISeries`<double>` input).Upper[int barsAgo]**\n\nReturns the lower value\n\n**Darvas().Lower[int barsAgo]**\n\n**Darvas(ISeries`<double>` input).Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n{% /table %}\n\n## Examples\n\n```csharp // Prints the current upper Darvas value\ndouble value = Darvas().Upper[0];\nPrint(\"The current upper Darvas value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "3180e3ec56a094c00b1ec22457d06e29459f3737a93de5b65c9358097e3fc289",
    "_type": "desktopSdkDoc",
    "title": "Directional Movement (DM)",
    "pathName": "directional_movement_dm",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nSame as the **ADX** indicator with the addition of the +DI and -DI values.\n\n... Courtesy of [Investopedia](http://www.investopedia.com/terms/d/dmi.asp)\n\n## Syntax\n\n**DM(int period)**  \n**DM(ISeries`<double>` input, int period)**\n\nReturns default ADX value  \n\n**DM[int period](int barsAgo)**  \n**DM[ISeries`<double>` input, int period](int barsAgo)**\n\nReturns +DI value  \n\n**DM(int period).DiPlus[int barsAgo]**  \n**DM(ISeries`<double>` input, int period).DiPlus[int barsAgo]**\n\nReturns -DI value  \n\n**DM(int period).DiMinus[int barsAgo]**  \n**DM(ISeries`<double>` input, int period).DiMinus[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period +DI using default price type\ndouble value = DM(20).DiPlus[0];\nPrint(\"The current +DI value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "42ab95005925a67caef52bd1dcb9d66702cabc4066a8aab3639369a6b4434fe3",
    "_type": "desktopSdkDoc",
    "title": "Directional Movement Index (DMI)",
    "pathName": "directional_movement_index_dmi",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nAn indicator developed by J. Welles Wilder for identifying when a definable trend is present in an instrument. That is, the DMI tells whether an instrument is trending or not.\n\n...Courtesy of [FMLabs](http://www.fmlabs.com/reference/default.htm?url=DX.htm)\n\n## Syntax\n\n**DMI(int period)**  \n\n**DMI(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**DMI[int period](int barsAgo)**  \n\n**DMI[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp // Prints the current value of a 20 period DMI using default price type\ndouble value = DMI[20](0);\nPrint(\"The current DMI value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "6416d663de23e740bf1116165ebae93fff2ab09ae2c17510e06a81dd86720bbe",
    "_type": "desktopSdkDoc",
    "title": "Disparity Index",
    "pathName": "disparity_index",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Disparity Index that measures the difference between the price and an exponential moving average. A value greater could suggest bullish momentum, while a value less than zero could suggest bearish momentum.\n\n## Syntax\n\n**DisparityIndex(int period)**\n\n**DisparityIndex(ISeries`<double>` input, int period)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **int barsAgo** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 15 period Disparity Index\ndouble value = DisparityIndex(15)[0];\nPrint(\"The current Disparity Index value is \" + value.ToString());\n```"
  },
  {
    "_id": "ade6b3203a6023905ff12be42a0e3f9229bf93d70a019f93314cd31baa923000",
    "_type": "desktopSdkDoc",
    "title": "Donchian Channel",
    "pathName": "donchian_channel",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nA moving average indicator developed by Richard Donchian. It plots the highest high and lowest low over a specific period.\n\n## Syntax\n\n**DonchianChannel(int period)**  \n\n**DonchianChannel(ISeries`<double>` input, int period)**\n\nReturns mean value (middle band) at a specified bar index  \n\n**DonchianChannel[int period](int barsAgo)**  \n\n**DonchianChannel[ISeries`<double>` input, int period](int barsAgo)**\n\nReturns upper band value at a specified bar index  \n\n**DonchianChannel(int period).Upper[int barsAgo]**  \n\n**DonchianChannel(ISeries`<double>` input, int period).Upper[int barsAgo]**\n\nReturns lower band value at a specified bar index  \n\n**DonchianChannel(int period).Lower[int barsAgo]**  \n\n**DonchianChannel(ISeries`<double>` input, int period).Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current upper value of a 20 period DonchianChannel using default price type\ndouble value = DonchianChannel(20).Upper[0];\nPrint(\"The current DonchianChannel upper value is \" + value.ToString());\n\n// Note the above call with a barsAgo of 0 includes the current Upper channel in the value. If we want to check for example for a break of this value, storing the last bar's channel value would be needed.\ndouble value = DonchianChannel(20).Upper[1];\nif (High[0] > value)\n Draw.ArrowUp(this, CurrentBar.ToString(), true, 0, Low[0] - TickSize, Brushes.Blue);\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "4f55be2eec4d6112975cf57fd19bbd087c00e1ef3c656d5b46e46e252af1df39",
    "_type": "desktopSdkDoc",
    "title": "Double Stochastics",
    "pathName": "double_stochastics",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDouble Stochastics is a variation of the **Stochastics** indicator developed by William Blau.\n\n## Syntax\n\n**DoubleStochastics(int period)**  \n\n**DoubleStochastics(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**DoubleStochastics[int period](int barsAgo)**  \n\n**DoubleStochastics[ISeries`<double>` input, int period](int barsAgo)**\n\nReturns %K value  \n\n**DoubleStochastics(int period).K[int barsAgo]**  \n\n**DoubleStochastics(ISeries`<double>` input, int period).K[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value\ndouble value = DoubleStochastics[10](0);\nPrint(\"The current Double Stochastics value is \" + value.ToString());\n\n\n// Prints the current %K value\ndouble value = DoubleStochastics(10).K[0];\nPrint(\"The current Double Stochastics %K value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "1e094fe3a8d58355c02bd09cc59edeb5ec6e96a327ab27c393077336b08fff39",
    "_type": "desktopSdkDoc",
    "title": "Dynamic Momentum Index (DMIndex)",
    "pathName": "dynamic_momentum_index_dmindex",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nAn indicator used in technical analysis that determines overbought and oversold conditions of a particular asset. This indicator is very similar to the relative strength index (**RSI**). The main difference between the two is that the **RSI** uses a fixed number of time periods (usually 14), while the dynamic momentum index uses different time periods as volatility changes.\n\n... Courtesy of [Investopedia](http://www.investopedia.com/terms/d/dynamicmomentumindex.asp)\n\n## Syntax\n\n**DMIndex**(**int smooth**)  \n**DMIndex**(**ISeries`<double>` input**, **int smooth**)\n\nReturns default value  \n**DMIndex**[**int period**](**int barsAgo**)  \n**DMIndex**[**ISeries`<double>` input**, **int smooth**](**int barsAgo**)\n\n## Return Value\n\n**double**; Accessing this method via an index value [**int barsAgo**] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* smooth\n\n---\n\n* Indicator source data ([?](valid_input_data_for_indicator.htm))\n* The number of bars to include in the calculation\n{% /table %}\n\n## Examples\n\n```csharp // Prints the current value of DMIndex using default price type\ndouble value = DMIndex[3](0);\nPrint(\"The current DMIndex value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > **NinjaScript** Editor > Indicators within the **NinjaTrader** Control Center window."
  },
  {
    "_id": "eec2ceb9da20e398dce88e499f57b6f2dd8d87f791d3925f31137946ae1870e7",
    "_type": "desktopSdkDoc",
    "title": "Ease of Movement",
    "pathName": "ease_of_movement",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Ease of Movement indicator was designed to illustrate the relationship between volume and price change. It shows how much volume is required to move prices.\n\nHigh Ease of Movement values occur when prices are moving upward with light volume. Low values occur when prices are moving downward on light volume. If prices are not moving or if heavy volume is required to move prices then the indicator will read near zero. A buy signal is produced when it crosses above zero. A sell signal is produced when the indicator crosses below zero (prices are moving downward more easily).\n\n## Syntax\n\n**EaseOfMovement(int smoothing, int volumeDivisor)**  \n\n**EaseOfMovement(ISeries`<double>` input, int smoothing, int volumeDivisor)**\n\nReturns default value  \n\n**EaseOfMovement[int smoothing, int volumeDivisor](int barsAgo)**  \n\n**EaseOfMovement[ISeries`<double>` input, int smoothing, int volumeDivisor](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* smoothing\n* The number of bars used to smooth the signal\n\n---\n\n* volumeDivisor\n* The value used to calculate the box ratio\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of Ease of Movement using default price type\ndouble value = EaseOfMovement(14, 10000)[0];\nPrint(\"The current Ease of Movement value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "01429afc5b7e01cc4c4da204da144d99b7ae9609d536dfea5965099f5a3a257e",
    "_type": "desktopSdkDoc",
    "title": "IsFalling()",
    "pathName": "isfalling",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nEvaluates a falling condition which is true when the current value is less than the value of 1 bar ago.\n\n## Method Return Value\n\nThis method returns true if a falling condition is present; otherwise, false.\n\n## Syntax  \n\n**IsFalling(ISeries`<double>` series)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, Close, High, Low, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // If the 20 period SMA is falling (in downtrend) go short\n   if (IsFalling(SMA(20)))\n       EnterShort();\n}\n```"
  },
  {
    "_id": "ad9f6a422fc94076289b2c7ec3fcebf02808839e62a42abb845e5c7f8e2f3ce9",
    "_type": "desktopSdkDoc",
    "title": "Fibonacci Pivots",
    "pathName": "fibonacci_pivots",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nFibonacci pivots are a price analysis tool that generates potential support and resistance levels by multiplying the prior range against Fibonacci values then adding or subtracting it from the average of the prior high, low, and close.\n\n## Syntax\n\n**FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)**  \n\n**FibonacciPivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)**\n\nReturns pivot point value  \n\n**FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).Pp[int barsAgo]**  \n\n**FibonacciPivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).PP[int barsAgo]**\n\nReturns R1 value  \n\n**FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]**  \n\n**FibonacciPivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]**\n\nReturns R2 value  \n\n**FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]**  \n\n**FibonacciPivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]**\n\nReturns R3 value  \n\n**FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]**  \n\n**FibonacciPivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]**\n\nReturns S1 value  \n\n**FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]**  \n\n**FibonacciPivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]**\n\nReturns S2 value  \n\n**FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]**  \n\n**FibonacciPivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]**\n\nReturns S3 value  \n\n**FibonacciPivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]**  \n\n**FibonacciPivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* pivotRangeType\n* Sets the range for the type of pivot calculated. Possible values are:  \n\t- PivotRange.Daily  \n\t- PivotRange.Weekly  \n\t- PivotRange.Monthly\n\n---\n\n* priorDayHLC\n* Sets how the prior range High, Low, Close values are calculated. Possible values are:  \n\t- HLCCalculationMode.CalcFromIntradayData  \n\t- HLCCalculationMode.DailyBars  \n\t- HLCCalculationMode.UserDefinedValues\n\n---\n\n* userDefinedClose\n* Sets the close for Pivots calculations when using HLCCalculationMode.UserDefinedValues.\n\n---\n\n* userDefinedHigh\n* Sets the high for Pivots calculations when using HLCCalculationMode.UserDefinedValues.\n\n---\n\n* userDefinedLow\n* Sets the low for Pivots calculations when using HLCCalculationMode.UserDefinedValues.\n\n---\n\n* width\n* Sets how long the Pivots lines will be drawn\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current pivot point value  \ndouble valuePp = FibonacciPivots(PivotRange.Daily, HLCCalculationMode.CalcFromIntradayData, 0, 0, 0, 20).Pp[0];  \nPrint(\"The current Fibonacci Pivots' pivot value is \" + valuePp.ToString());  \n// Prints the current S2 pivot value  \ndouble valueS2 = FibonacciPivots(PivotRange.Daily, HLCCalculationMode.CalcFromIntradayData, 0, 0, 0, 20).S2[0];  \nPrint(\"The current Fibonacci Pivots' S2 pivot value is \" + valueS2.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.\n\n{% callout type=\"note\" %}\n\nTip: When using HLCCalculationMode.DailyBars it can be expected that a value of 0 is returned when the daily bars have not been loaded yet. Due to the asynchronous nature of this indicator calling daily bars you should only access the pivot values when the indicator has loaded all required Bars objects. To ensure you are accessing accurate values you can use **.IsValidDataPoint()** as a check:\n\n{% /callout %}\n\n```csharp\n// Evaluates that this is a valid pivot point value  \nif (FibonacciPivots(PivotRange.Daily, HLCCalculationMode.DailyBars, 0, 0, 0, 20).Pp.IsValidDataPoint(0))  \n{  \n     // Prints the current pivot point value  \n     double valuePp = FibonacciPivots(PivotRange.Daily, HLCCalculationMode.DailyBars, 0, 0, 0, 20).Pp[0];  \n     Print(\"The current Pivots' pivot value is \" + valuePp.ToString());  \n}  \n```"
  },
  {
    "_id": "0b92c7bdb2cff0bdc32cb44d0989aca67299dc78e90cca51f0f3087d98744b15",
    "_type": "desktopSdkDoc",
    "title": "Fisher Transform",
    "pathName": "fisher_transform",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nWith distinct turning points and a rapid response time, the Fisher Transform uses the assumption that while prices do not have a normal or Gaussian probability density function (that familiar bell-shaped curve), you can create a nearly Gaussian probability density function by normalizing price (or an indicator such as **RSI**) and applying the Fisher Transform. Use the resulting peak swings to clearly identify price reversals.\n\n## Syntax\n\n**FisherTransform(int period)**  \n**FisherTransform(ISeries`<double>` input, int period)**\n\nReturns default value  \n**FisherTransform[int period](int barsAgo)**  \n**FisherTransform[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 10 period using default (median) price type\ndouble value = FisherTransform(10)[0];\nPrint(\"The current Fisher Transform value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "b683c26b1065845a68b550bfbb7df514c5b2aa8a6e33fd98842ca9bd7fe9b7e8",
    "_type": "desktopSdkDoc",
    "title": "Forecast Oscillator (FOSC)",
    "pathName": "forecast_oscillator_fosc",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Forecast Oscillator calculates the percentage difference between the actual price and the Time Series Forecast (the endpoint of a linear regression line). When the price and the forecast are equal, the Oscillator is zero. When the price is greater than the forecast, the Oscillator is greater than zero. When the price is less than the forecast, the Oscillator is less than zero.\n\n... Courtesy of [FM Labs](fm-labs)\n\n## Syntax\n\n**FOSC(int period)**  \n**FOSC(ISeries`<double>` input, int period)**\n\nReturns default value  \n**FOSC[int period](int barsAgo)**  \n**FOSC[ISeries`<double>` input, int period**](int barsAgo)\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([?](valid-input-data-for-indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Evaluates if the current bar **FOSC** is above zero\nif (FOSC[14](0) > 0)\n   Print(\"FOSC is above zero indicating prices may rise\");\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "dc08bf4324df69d6f88b727c89233a15b8d751aaa9ca8014c52061c52bb42a3c",
    "_type": "desktopSdkDoc",
    "title": "Keltner Channel",
    "pathName": "keltner_channel",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nKeltner Channel indicator is based on volatility using a pair of values placed as an \"envelope\" around the data field.\n\n## Syntax\n\n**KeltnerChannel(double offsetMultiplier, int period)**  \n**KeltnerChannel(ISeries`<double>` input, double offsetMultiplier, int period)**\n\nReturns midline value  \n**KeltnerChannel[double offsetMultiplier, int period](int barsAgo)**  \n**KeltnerChannel[ISeries`<double>` input, double offsetMultiplier, int period](int barsAgo)**\n\nReturns upper band value  \n**KeltnerChannel(double offsetMultiplier, int period).Upper[int barsAgo]**  \n**KeltnerChannel(ISeries`<double>` input, double offsetMultiplier, int period).Upper[int barsAgo]**\n\nReturns lower band value  \n**KeltnerChannel(double offsetMultiplier, int period).Lower[int barsAgo]**  \n**KeltnerChannel(ISeries`<double>` input, double offsetMultiplier, int period).Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current upper value of a 20 period KeltnerChannel using default price type\ndouble value = KeltnerChannel(1.5, 20).Upper[0];\nPrint(\"The current KeltnerChannel upper value is \" + value.ToString());\n\n// Prints the current lower value of a 20 period KeltnerChannel using high price type\ndouble value = KeltnerChannel(High, 1.5, 20).Lower[0];\nPrint(\"The current KeltnerChannel lower value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "78b0fb8da41dedac926d3f5efaed3b2bdab55e4046b2d02ab77fb0f81b5a466b",
    "_type": "desktopSdkDoc",
    "title": "KeyReversalDown",
    "pathName": "keyreversaldown",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nReturns a value of 1 when the current close is less than the prior close and the current high has penetrated the highest high of the last n bars.\n\n## Syntax\n\n**KeyReversalDown(int period)**  \n\n**KeyReversalDown(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**KeyReversalDown[int period](int barsAgo)**  \n\n**KeyReversalDown[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// If we get a reversal over the past 10 bars go short\nif (KeyReversalDown(10)[0] == 1)\n    EnterShort();\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "9f40e57636d9e4a15ee684fdce499eb6f5603f41414b7d135b89e44653417166",
    "_type": "desktopSdkDoc",
    "title": "KeyReversalUp",
    "pathName": "keyreversalup",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nReturns a value of 1 when the current close is greater than the prior close and the current low has penetrated the lowest low of the last n bars.\n\n## Syntax\n\n**KeyReversalUp(int period)**  \n\n**KeyReversalUp(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**KeyReversalUp[int period](int barsAgo)**  \n\n**KeyReversalUp[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([valid_input_data_for_indicator](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// If we get a reversal over the past 10 bars go long\nif (KeyReversalUp(10)[0] == 1)\n    EnterLong();\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "2c14f57d11df674847996176eaf7a4298dc46a32656150937373b3eb873e3547",
    "_type": "desktopSdkDoc",
    "title": "Linear Regression",
    "pathName": "linear_regression",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Linear Regression Indicator plots the trend of a security's price over time. That trend is determined by calculating a Linear Regression Trendline using the least squares method. This ensures the minimum distance between the data points and a Linear Regression Trendline.\n\n## Syntax\n\n**LinReg(int period)**  \n\n**LinReg(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**LinReg[int period](int barsAgo)**  \n\n**LinReg[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([valid_input_data_for_indicator](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Prints the current value of a 20 period LinReg using default price type\ndouble value = LinReg[20](0);\nPrint(\"The current LinReg value is \" + value.ToString());\n\n// Prints the current value of a 20 period LinReg using high price type\ndouble value = LinReg[High, 20](0);\nPrint(\"The current LinReg value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "f5a04f104f27ae1cdca5ff0b7e9cefbaafcc8d0b26e699b10f5a719ea388f626",
    "_type": "desktopSdkDoc",
    "title": "Linear Regression Intercept",
    "pathName": "linear_regression_intercept",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Linear Regression Intercept provides the intercept value of the **Linear Regression** trendline.\n\n## Syntax\n\n**LinRegIntercept(int period)**  \n\n**LinRegIntercept(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**LinRegIntercept[int period](int barsAgo)**  \n\n**LinRegIntercept[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current intercept value of a 20 period LinReg using default price type\ndouble value = LinRegIntercept(20)[0];\nPrint(\"The current intercept value is \" + value.ToString());\n// Prints the current intercept value of a 20 period LinReg using high price type\ndouble value = LinRegIntercept(High, 20)[0];\nPrint(\"The current intercept value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "a9485ce23f1b102558969459ab7dc676238f75aca629cf70bdf629c818ed7e4a",
    "_type": "desktopSdkDoc",
    "title": "Linear Regression Slope",
    "pathName": "linear_regression_slope",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Linear Regression Slope provides the slope value of the **Linear Regression** trendline.\n\n## Syntax\n\n**LinRegSlope(int period)**  \n\n**LinRegSlope(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**LinRegSlope[int period](int barsAgo)**  \n\n**LinRegSlope[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data (**[?](valid_input_data_for_indicator)**)\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Prints the current slope value of a 20 period LinReg using default price type\ndouble value = LinRegSlope[20](0);\nPrint(\"The current slope value is \" + value.ToString());\n\n// Prints the current slope value of a 20 period LinReg using high price type\ndouble value = LinRegSlope[High, 20](0);\nPrint(\"The current slope value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "feac99b03f66a5dbbbde00966ab8cf1b399b325ca775f8b431603205b0b634b0",
    "_type": "desktopSdkDoc",
    "title": "MA Envelopes",
    "pathName": "ma_envelopes",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Moving Average Envelope consists of moving averages calculated from the underlying price, shifted up and down by a fixed percentage.\n\n## Syntax\n\n**MAEnvelopes(double envelopePercentage, int mAType, int period)**\n\n**MAEnvelopes(ISeries`<double>` input, double envelopePercentage, int mAType, int period)**\n\n## Returns upper band levels\n\n**MAEnvelopes(double envelopePercentage, int mAType, int period).Upper[int barsAgo]**\n\n**MAEnvelopes(ISeries`<double>` input, double envelopePercentage, int mAType, int period).Upper[int barsAgo]**\n\n## Returns moving average value\n\n**MAEnvelopes(double envelopePercentage, int mAType, int period).Middle[int barsAgo]**\n\n**MAEnvelopes(ISeries`<double>` input, double envelopePercentage, int mAType, int period).Middle[int barsAgo]**\n\n## Returns lower band levels\n\n**MAEnvelopes(double envelopePercentage, int mAType, int period).Lower[int barsAgo]**\n\n**MAEnvelopes(ISeries`<double>` input, double envelopePercentage, int mAType, int period).Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* envelopePercentage\n* Percentage around MA that envelopes will be drawn\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* mAType\n* Moving average type:\n\t- 1 = EMA\n\t- 2 = HMA\n\t- 3 = SMA\n\t- 4 = TMA\n\t- 5 = TEMA\n\t- 6 = WMA\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current upper band value of a 20 period SMA envelope using default price type\ndouble upperValue = MAEnvelopes(0.2, 3, 20).Upper[0];\nPrint(\"The current SMA envelope upper value is \" + upperValue.ToString());\n\n// Prints the current lower band value of a 20 period SMA envelope using low price type\ndouble lowerValue = MAEnvelopes(Low, 0.2, 3, 20).Lower[0];\nPrint(\"The current SMA envelope lower value is \" + lowerValue.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "ec85ec6db293acf5004c59104c3174f63a9033e3e88e4afe3be6fabb036b18cc",
    "_type": "desktopSdkDoc",
    "title": "Maximum (MAX)",
    "pathName": "maximum_max",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nReturns the highest value over the specified period.\n\n## Syntax\n\n**MAX(int period)**  \n\n**MAX(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**MAX[int period](int barsAgo)**  \n\n**MAX[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data (**[?](valid_input_data_for_indicator)**)\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the highest high value over the last 20 periods\ndouble value = MAX(High, 20)[0];\nPrint(\"The current MAX value is \" + value.ToString());\n\n// Note the above call with a barsAgo of 0 includes the current MAX of the input high series in the value. If we want to check for example for a break of this value, storing the last bar's MAX would be needed.\ndouble value = MAX(High, 20)[1];\n\nif (High[0] > value)\n    Draw.ArrowUp(this, CurrentBar.ToString(), true, 0, Low[0] - TickSize, Brushes.Blue);\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "a4a5da3951be59b49d895b7fd838255853e3b64168248ea9960dd47e1d9d3525",
    "_type": "desktopSdkDoc",
    "title": "McClellan Oscillator",
    "pathName": "mcclellan_oscillator",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nMcClellan Oscillator is the difference between two exponential moving averages of the NYSE advance decline spread. This indicator requires ADV and DECL index data.\n\n## Syntax\n\n**McClellanOscillator(int fastPeriod, int slowPeriod)**  \n**McClellanOscillator(ISeries`<double>` input, int fastPeriod, int slowPeriod)**\n\n## Return Value\n\n**double**; Accessing this method via an index value **int barsAgo** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* **fastPeriod**\n* Number of bars used in the fast moving average calculation\n\n---\n\n* **slowPeriod**\n* Number of bars used in the slow moving average calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// An ADV and DECL data series must be added to OnStateChange()\nelse if (State == State.Configure)\n{\n    AddDataSeries(\"^ADV\");\n    AddDataSeries(\"^DECL\");\n}\n\n// Prints the current value of the McClellan Oscillator with a 19 fast period moving average & 39 slow period\ndouble value = McClellanOscillator(19, 39)[0];\nPrint(\"The current McClellan Oscillator value is \" + value.ToString());\n```"
  },
  {
    "_id": "4f558382aa9036f97705c6d1fb24b0e5aa6a2dea27ce60f0c80d98a8ae5eb708",
    "_type": "desktopSdkDoc",
    "title": "Minimum (MIN)",
    "pathName": "minimum_min",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nReturns the lowest value over the specified period.\n\n## Syntax\n\n**MIN(int period)**  \n\n**MIN(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**MIN[int period](int barsAgo)**  \n\n**MIN[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the lowest low value over the last 20 periods\ndouble value = MIN[Low, 20](0);\nPrint(\"The current MIN value is \" + value.ToString());\n// Note the above call with a barsAgo of 0 includes the current MIN of the input low series in the value. If we want to check for example for a break of this value, storing the last bar's MIN would be needed.\ndouble value = MIN[Low, 20](1);\nif (Low[0] < value)\n   Draw.ArrowDown(this, CurrentBar.ToString(), true, 0, High[0] + TickSize, Brushes.Red);\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "446be308664e1964b816217ba48334a777837850765f863efbba3c6608da6b90",
    "_type": "desktopSdkDoc",
    "title": "Momentum",
    "pathName": "momentum",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nBy measuring the amount that a security's price has changed over a given time span, the Momentum indicator provides an indication of a market's velocity and to some degree, a measure of the extent to which a trend still holds true. It can also be helpful in spotting likely reversal points.\n\n## Syntax\n\n**Momentum(int period)**  \n\n**Momentum(ISeries`<double>` input, int period)**\n\n**Returns default value**\n\n**Momentum[int period](int barsAgo)**  \n\n**Momentum[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input** | Indicator source data [**?**](valid_input_data_for_indicator)\n* **period** | Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period Momentum using default price type\ndouble value = Momentum[20](0);\nPrint(\"The current Momentum value is \" + value.ToString());\n  \n// Prints the current value of a 20 period Momentum using high price type\ndouble value = Momentum[High, 20](0);\nPrint(\"The current Momentum value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "26c6ff6adb51f8a2a572efd73e62bafc0f901800552adb0cecd6c092ed9c26e6",
    "_type": "desktopSdkDoc",
    "title": "Money Flow Index (MFI)",
    "pathName": "money_flow_index_mfi",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Money Flow Index (MFI) is a momentum indicator that is similar to the Relative Strength Index (RSI) in both interpretation and calculation. However, MFI is a more rigid indicator in that it is volume-weighted, and is therefore a good measure of the strength of money flowing in and out of a security.\n\n... Courtesy of [StockCharts](http://stockcharts.com/education/IndicatorAnalysis/indic_MFI.htm)\n\n## Syntax\n\n**MFI(int period)**  \n\n**MFI(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**MFI[int period](int barsAgo)**  \n\n**MFI[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period MFI using default price type\ndouble value = MFI[20](0);\nPrint(\"The current MFI value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "3b2465cc138dd142dded0750cb29dc5b128c0f7b383c95471d31902eb1ed408d",
    "_type": "desktopSdkDoc",
    "title": "Money Flow Oscillator",
    "pathName": "money_flow_oscillator",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Money Flow Oscillator measures the amount of money flow volume over a specific period. A move into positive territory indicates buying pressure while a move into negative territory indicates selling pressure.\n\n## Syntax\n\n**MoneyFlowOscillator**(int period)\n\n**MoneyFlowOscillator**(**ISeries`<double>`** input, int period)\n\n## Return Value\n\n**double;** Accessing this method via an index value **int barsAgo** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data ([**valid_input_data_for_indicator**](valid_input_data_for_indicator))\n\n---\n\n* period\n\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 10 period Money Flow Oscillator\ndouble value = MoneyFlowOscillator(10)[0];\nPrint(\"The current Money Flow Oscillator value is \" + value.ToString());\n```"
  },
  {
    "_id": "50feefdab65bf7662f7fa2a62089398ddd8a03cf66dad1b89a7866135bddb8d6",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Double Exponential (DEMA)",
    "pathName": "moving_average_double_exponential_dema",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Double Exponential Moving Average (DEMA) is a combination of a single exponential moving average and a double exponential moving average. The advantage is that gives a reduced amount of lag time than either of the two separate moving averages alone.\n\n## Syntax\n\n**DEMA(int period)**  \n\n**DEMA(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**DEMA[int period](int barsAgo)**  \n\n**DEMA[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period DEMA using default price type**\ndouble value = DEMA(20)[0];\nPrint(\"The current DEMA value is \" + value.ToString());\n// Prints the current value of a 20 period DEMA using high price type**\ndouble value = DEMA(High, 20)[0];\nPrint(\"The current DEMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "b7a07e35021d8135c2a307a14c70f9037869fe33718b60142cf2315db45dd8b5",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Exponential (EMA)",
    "pathName": "moving_average_exponential_ema",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe exponential moving average is but one type of a moving average. In a simple moving average, all price data has an equal weight in the computation of the average with the oldest value removed as each new value is added. In the exponential moving average equation the most recent market action is assigned greater importance as the average is calculated. The oldest pricing data in the exponential moving average is however never removed.\n\n## Syntax\n\n**EMA**(int period)  \n\n**EMA**(**ISeries`<double>`** input, int period)\n\nReturns default value  \n\n**EMA**[int period](int barsAgo)  \n\n**EMA**[**ISeries`<double>`** input, int period](int barsAgo)\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period EMA using default price type\ndouble value = EMA(20)[0];\nPrint(\"The current EMA value is \" + value.ToString());\n  \n// Prints the current value of a 20 period EMA using high price type\ndouble value = EMA(High, 20)[0];\nPrint(\"The current EMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "8aec484d4308bbc8a7fed825a4fb566718d0cda20bc8f7a538991efb5ba44f98",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Hull (HMA)",
    "pathName": "moving_average_hull_hma",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe HMA manages to keep up with rapid changes in price activity whilst having superior smoothing over an SMA of the same period. The HMA employs weighted moving averages and dampens the smoothing effect (and resulting lag) by using the square root of the period instead of the actual period itself. Developed by Alan Hull.\n\n## Syntax\n\n**HMA(int period)**  \n\n**HMA(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**HMA[int period](int barsAgo)**  \n\n**HMA[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Prints the current value of a 20 period HMA using default price type\ndouble value = HMA[20](0);\nPrint(\"The current HMA value is \" + value.ToString());\n\n// Prints the current value of a 20 period HMA using high price type\ndouble value = HMA[High, 20](0);\nPrint(\"The current HMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "e4f0476620f799c1cf13d6f1e8a3f24ee1e08e0bb20875e1510bff72773c70ce",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Kaufman's Adaptive (KAMA)",
    "pathName": "moving_average_kaufmans_adaptive",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by Perry Kaufman, this indicator is an EMA using an Efficiency Ratio to modify the smoothing constant, which ranges from a minimum of Fast Length to a maximum of Slow Length.\n\n## Syntax\n\n**KAMA**(int fast, int period, int slow)  \n**KAMA**(ISeries`<double>` input, int fast, int period, int slow)\n\nReturns default value  \n**KAMA**[int fast, int period, int slow](int barsAgo)  \n**KAMA**[ISeries`<double>` input, int fast, int period, int slow](int barsAgo)\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **fast**\n* Fast length\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n\n---\n\n* **slow**\n* Slow length\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period KAMA using default price type\ndouble value = KAMA[2, 20, 30](0);\nPrint(\"The current KAMA value is \" + value.ToString());\n\n// Prints the current value of a 20 period KAMA using high price type\ndouble value = KAMA[High, 2, 20, 30](0);\nPrint(\"The current KAMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "b006195d5003568f4f6e4d66378a8da649f253d3dbe80c615621b643d5bb6e4f",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Mesa Adaptive (MAMA)",
    "pathName": "moving_average_mesa_adaptive",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe MESA Adaptive Moving Average (MAMA) adapts to price movement in an entirely new and unique way. The adaptation is based on the rate change of phase as measured by the Hilbert Transform Discriminator. The advantage of this method of adaptation is that it features a fast attack average and a slow decay average so that composite average rapidly ratchets behind price changes and holds the average value until the next ratchet occurs.\n\n## Syntax\n\n**MAMA(double fastLimit, double slowLimit)**  \n**MAMA(ISeries`<double>` input, double fastLimit, double slowLimit)**\n\nReturns MAMA value  \n\n**MAMA[double fastLimit, double slowLimit](int barsAgo)**  \n**MAMA[ISeries`<double>` input, double fastLimit, double slowLimit](int barsAgo)**\n\nReturns Fama (Following Adaptive Moving Average) value  \n\n**MAMA(double fastLimit, double slowLimit).Fama[int barsAgo]**  \n**MAMA(ISeries`<double>` input, double fastLimit, double slowLimit).Fama[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* fastLimit\n* Upper limit of the alpha value\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* slowLimit\n* Lower limit of the alpha value\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period MAMA using default price type\ndouble value = MAMA(0.5, 0.05).Default[0];\nPrint(\"The current MAMA value is \" + value.ToString());\n\n// Prints the current value of a 20 period Fama using high price type\ndouble value = MAMA(High, 0.5, 0.05).Fama[0];\nPrint(\"The current Fama value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "a17d6b799ce88e39978884f1b4490ca69c160e3819b19fd13ec8bac961e4761f",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Simple (SMA)",
    "pathName": "moving_average_simple_sma",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Simple Moving Average is calculated by summing the closing prices of the security for a period of time and then dividing this total by the number of time periods. Sometimes called an arithmetic moving average, the SMA is basically the average stock price over time.\n\n## Syntax\n\n**SMA(int period)**  \n\n**SMA(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**SMA[int period](int barsAgo)**  \n\n**SMA[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period SMA using default price type\ndouble value = SMA[20](0);\nPrint(\"The current SMA value is \" + value.ToString());\n\n// Prints the current value of a 20 period SMA using high price type**\ndouble value = SMA[High, 20](0);\nPrint(\"The current SMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "3ebc9fe752405f77bd6ad40c0c52b6e6e86d4d700571d35b74861dafd7b94c21",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - T3 (T3)",
    "pathName": "moving_average_t3_t3",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe T3 is a type of moving average, or smoothing function. It is based on the DEMA. The T3 takes the DEMA calculation and adds a vfactor which is between zero and 1. The resultant function is called the GD, or Generalized DEMA. A GD with vfactor of 1 is the same as the DEMA. A GD with a vfactor of zero is the same as an Exponential Moving Average. The T3 typically uses a vfactor of 0.7.\n\n... Courtesy of [FMLabs](http://www.fmlabs.com/reference/default.htm?url=T3.htm)\n\n## Syntax\n\n**T3(int period, int tCount, double vFactor)**\n\n**T3(ISeries`<double>` input, int period, int tCount, double vFactor)**\n\nReturns default value\n\n**T3[int period, int tCount, double vFactor](int barsAgo)**\n\n**T3[ISeries`<double>` input, int period, int tCount, double vFactor](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n* tCount\n* Number of smooth iterations\n\n---\n\n* vFactor\n* A multiplier fudge factor\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period T3 using default price type\ndouble value = T3(20, 3, 0.7)[0];\nPrint(\"The current T3 value is \" + value.ToString());\n\n// Prints the current value of a 20 period T3 using high price type\ndouble value = T3(High, 20, 3, 0.7)[0];\nPrint(\"The current T3 value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "fc32be6ff75880c7d6abd34e9a7874eb6ba26c9065b9741ad1846a9d162197fd",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Triangular (TMA)",
    "pathName": "moving_average_triangular_tma",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Triangular Moving Average is a form of **Weighted Moving Average** wherein the weights are assigned in a triangular pattern. For example, the weights for a 7 period Triangular Moving Average would be 1, 2, 3, 4, 3, 2, 1. This gives more weight to the middle of the time series and less weight to the oldest and newest data.\n\n## Syntax\n\n**TMA(int period)**  \n\n**TMA(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**TMA[int period](int barsAgo)**  \n\n**TMA[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([**valid input data for indicator**](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period TMA using default price type\ndouble value = TMA(20)[0];\nPrint(\"The current TMA value is \" + value.ToString());\n  \n// Prints the current value of a 20 period TMA using high price type\ndouble value = TMA(High, 20)[0];\nPrint(\"The current TMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "d5c56e8faef7d1aa85c62bf32839cf0a913f0332f1023dccf0be1ece0cf13157",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Triple Exponential (TRIX)",
    "pathName": "moving_average_triple_exponential_trix",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe triple exponential average (TRIX) indicator is an oscillator used to identify oversold and overbought markets, and it can also be used as a momentum indicator.\n\n... Courtesy of [Investopedia](http://www.investopedia.com/articles/technical/02/092402.asp)\n\n## Syntax\n\n**TRIX(int period, int signalPeriod)**  \n\n**TRIX(ISeries`<double>` input, int period, int signalPeriod)**\n\nReturns trix value  \n\n**TRIX[int period, int signalPeriod](int barsAgo)**  \n\n**TRIX[ISeries`<double>` input, int period, int signalPeriod](int barsAgo)**\n\nReturns signal value  \n\n**TRIX(int period, int signalPeriod).Signal[int barsAgo]**  \n\n**TRIX(ISeries`<double>` input, int period, int signalPeriod).Signal[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n* signalPeriod\n* Period for signal line\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period TRIX using default price type\ndouble value = TRIX(20, 3).Default[0];\nPrint(\"The current TRIX value is \" + value.ToString());\n\n// Prints the current signal value of a 20 period TRIX using high price type\ndouble value = TRIX(High, 20, 3).Signal[0];\nPrint(\"The current TRIX signal value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "3c49484acdbdbe5752bcda21db7e2f3c69bc443c169b5ca439bc03d115f64a72",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Triple Exponential (TEMA)",
    "pathName": "moving_average_triple_exponential_tema",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe TEMA is a smoothing indicator. It was developed by Patrick Mulloy and is described in his article in the January, 1994 issue of Technical Analysis of Stocks and Commodities magazine.\n\n## Syntax\n\n**TEMA(int period)**  \n\n**TEMA(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**TEMA[int period](int barsAgo)**  \n\n**TEMA[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period TEMA using default price type\ndouble value = TEMA(20)[0];\nPrint(\"The current TEMA value is \" + value.ToString());\n\n// Prints the current value of a 20 period TEMA using high price type\ndouble value = TEMA(High, 20)[0];\nPrint(\"The current TEMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "595792efd0145108083bcaaa64583f3723f745682faa4ac46404b6cd6171be6f",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Variable (VMA)",
    "pathName": "moving_average_variable_vma",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nA Variable Moving Average is an exponential moving average that automatically adjusts its smoothing percentage based on market volatility. Giving more weight to the current data increases sensitivity thus making it a better signal indicator for short and long term markets.\n\n## Syntax\n\n**VMA**(int period, int volatilityPeriod)  \n**VMA**(**ISeries`<double>`** input, int period, int volatilityPeriod)\n\nReturns default value  \n**VMA**[int period, int volatilityPeriod](int barsAgo)  \n**VMA**[**ISeries`<double>`** input, int period, int volatilityPeriod](int barsAgo)\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n* volatilityPeriod\n* The number of bars used to calculate the [CMO](chande_momentum_oscillator_cmo) based volatility index\n{% /table %}\n\n## Examples\n\n```csharp\n// OnBarUpdate method of a strategy\nprotected override void OnBarUpdate()\n{\n   // Print out the VMA value of lows 3 bars ago for fun\n   double value = VMA(Low, 9, 9)[3];\n   Print(\"The value is \" + value.ToString());\n \n   // Go long if price closes above the current VMA value\n   if (Close[0] > VMA(9, 9)[0])\n       EnterLong();\n}\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "6b3ec04c25597086c253f532f4c567fa18584ac4ca37025788a0b95464975594",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Volume Weighted (VWMA)",
    "pathName": "moving_average_volume_weighted_vwma",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Volume Weighted Moving Average is a weighted moving average that uses the volume as the weighting factor, so that higher volume days have more weight. It is a non-cumulative moving average, in that only data within the time period is used in the calculation.\n\n## Syntax\n\n**VWMA(int period)**  \n\n**VWMA(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**VWMA[int period](int barsAgo)**  \n\n**VWMA[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([**valid_input_data_for_indicator**](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// OnBarUpdate method\nprotected override void OnBarUpdate()\n{\n   // Evaluates for a VWMA cross over to the long side\n   if (CrossAbove(VWMA(14), VWMA(40), 1))\n       Print(\"We have a moving average cross over long\");\n\n   // Prints the current 14 period VWMA of high prices to the output window\n   double value = VWMA[High, 14](0);\n   Print(\"The current VWMA value of high prices is \" + value.ToString());\n}\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "55019117077878128cff80cbe78214b91de68c9ac3e7240d38b4d3cfc425817a",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Weighted (WMA)",
    "pathName": "moving_average_weighted_wma",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Weighted Moving Average gives the latest price more weight than prior prices. Each prior price in the period gets progressively less weight as they become older.\n\n## Syntax\n\n**WMA(int period)**  \n\n**WMA(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**WMA[int period](int barsAgo)**  \n\n**WMA[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period WMA using default price type\ndouble value = WMA[20](0);\nPrint(\"The current WMA value is \" + value.ToString());\n\n// Prints the current value of a 20 period WMA using high price type\ndouble value = WMA[High, 20](0);\nPrint(\"The current WMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "8a8111f9ca78af6665493967f41ce66dc27ff7c8becb43e05307911c2aaaeba9",
    "_type": "desktopSdkDoc",
    "title": "Moving Average - Zero Lag Exponential (ZLEMA)",
    "pathName": "moving_average_zero_lag_exponential_zlema",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Zero-Lag Exponential Moving Average is a variation on the Exponential Moving Average. The Zero-Lag keeps the benefit of the heavier weighting of recent values, but attempts to remove lag by subtracting older data to minimize the cumulative effect.\n\n... Courtesy of [FMLabs](http://www.fmlabs.com/reference/default.htm?url=ZeroLagExpMA.htm)\n\n## Syntax\n\n**ZLEMA**(int period)  \n\n**ZLEMA**(ISeries`<double>` input, int period)\n\nReturns default value  \n\n**ZLEMA**[int period](int barsAgo)  \n\n**ZLEMA**[ISeries`<double>` input, int period](int barsAgo)\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([?](valid_input_data_for_indicator.htm))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period ZLEMA using default price type\ndouble value = ZLEMA[20](0);\nPrint(\"The current SMA value is \" + value.ToString());\n\n// Prints the current value of a 20 period ZLEMA using high price type\ndouble value = ZLEMA[High, 20](0);\nPrint(\"The current ZLEMA value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "97f4fcf5686dc562d5569bd8aba5113b5ea71015e68651d63cd093edc79aff24",
    "_type": "desktopSdkDoc",
    "title": "Moving Average Convergence-Divergence (MACD)",
    "pathName": "moving_average_convergence_divergence_macd",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nMACD uses moving averages, which are lagging indicators, to include some trend-following characteristics. These lagging indicators are turned into a momentum oscillator by subtracting the longer moving average from the shorter moving average.\n\n... Courtesy of [StockCharts](http://stockcharts.com/education/IndicatorAnalysis/indic_MACD1.html)\n\n## Syntax\n\n**MACD(int fast, int slow, int smooth)**  \n**MACD(ISeries`<double>` input, int fast, int slow, int smooth)**\n\nReturns MACD value  \n**MACD[int fast, int slow, int smooth](int barsAgo)**  \n**MACD[ISeries`<double>` input, int fast, int slow, int smooth](int barsAgo)**\n\nReturns average value  \n**MACD(int fast, int slow, int smooth).Avg[int barsAgo]**  \n**MACD(ISeries`<double>` input, int fast, int slow, int smooth).Avg[int barsAgo]**\n\nReturns difference value  \n**MACD(int fast, int slow, int smooth).Diff[int barsAgo]**  \n**MACD(ISeries`<double>` input, int fast, int slow, int smooth).Diff[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* fast\n* The number of bars to calculate the fast [**EMA**](moving_average_-_exponential_e)\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* slow\n* The numbers of bars to calculate the slow EMA\n\n---\n\n* smooth\n* The number of bars to calculate the EMA signal line\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current MACD value\ndouble value = MACD(12, 26, 9)[0];\nPrint(\"The current MACD value is \" + value.ToString());\n\n// Prints the current MACD average value\ndouble value = MACD(12, 26, 9).Avg[0];\nPrint(\"The current MACD average value is \" + value.ToString());\n\n// Prints the current MACD difference value\ndouble value = MACD(12, 26, 9).Diff[0];\nPrint(\"The current MACD difference value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > **NinjaScript** Editor > Indicators within the **NinjaTrader** Control Center window."
  },
  {
    "_id": "802f04b3a8c08d22290282875107e5bc53658fa36c690bc6ba1384e1724b9fe3",
    "_type": "desktopSdkDoc",
    "title": "Moving Average Ribbon",
    "pathName": "moving_average_ribbon",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Moving Average Ribbon is a series of incrementing moving averages.\n\n## Syntax\n\n**MovingAverageribbon(RibbonMAType movingAverage, int basePeriod, int incrementalPeriod)**\n\n**MovingAverageribbon(ISeries`<double>` input, RibbonMAType movingAverage, int basePeriod, int incrementalPeriod)**\n\n**Returns the MovingAverage1 value (Replace the 1 with the desired moving average you want the value to return)**\n\n**MovingAverageribbon(RibbonMAType movingAverage, int basePeriod, int incrementalPeriod).MovingAverage1[int barsAgo]**\n\n**MovingAverageribbon(ISeries`<double>` input, RibbonMAType movingAverage, int basePeriod, int incrementalPeriod).MovingAverage1[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* RibbonMAType\n* basePeriod\n* incrementalPeriod\n\n---\n\n* Indicator source data ([**valid_input_data_for_indicator**](valid_input_data_for_indicator))\n* Moving average to use for calculations\n* Number of bars used in the calculation for the fastest moving average\n* Number of bars to increase for the calculation in each additional moving average\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of the 3rd moving average\ndouble value = MovingAverageRibbon(RibbonMAType.Exponential, 10, 10).MovingAverage3[0];\nPrint(\"The current 3rd moving average's value is \" + value.ToString());\n```"
  },
  {
    "_id": "57c55586d8a0b845d9652b6c21d6fc503b4411f9e022f1e65feb69bf1636e132",
    "_type": "desktopSdkDoc",
    "title": "Net Change Display",
    "pathName": "net_change_display",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDisplays net change on the chart.\n\n## Syntax\n\n**NetChangeDisplay(PerformanceUnit, NetChangePosition location)**\n\n**NetChangeDisplay(ISeries`<double>` input, PerformanceUnit, NetChangePosition location)**\n\n## Return Value\n\ndouble\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **PerformanceUnit**\n* Format of the calculation of net change\n\n---\n\n* **NetChangePosition**\n* Location to display net change on the chart\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Runs on realtime since there is no historical data for this indicator\nif (State == State.Historical)\nreturn;\nelse if (State >= State.Realtime)\n{\n// Prints the current tick value of the net change\nvar ncd = NetChangeDisplay(PerformanceUnit.Ticks, NetChangePosition.BottomRight);\nPrint(\"The current Net Change value is \" + ncd.NetChange);\n}\n```\n\n{% callout type=\"note\" %}\n\nThis indicator only plots real-time. Historical values will print as 0.\n\n{% /callout %}"
  },
  {
    "_id": "41c75c6ddd963ff3edd8ac155c2b0879460084fc4469c23798519a4dce4af409",
    "_type": "desktopSdkDoc",
    "title": "n Bars Down",
    "pathName": "n_bars_down",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nEvaluates for n number of consecutive lower closes. Returns a value of 1 when the condition is true or 0 when false.\n\n## Syntax\n\n**NBarsDown(int barCount, bool barDown, bool lowerHigh, bool lowerLow)**  \n\n**NBarsDown(ISeries`<double>` input, int barCount, bool barDown, bool lowerHigh, bool lowerLow)**\n\nReturns default value  \n\n**NBarsDown[int barCount, bool barDown, bool lowerHigh, bool lowerLow](int barsAgo)**  \n\n**NBarsDown[ISeries`<double>` input, bool barCount, int barDown, bool lowerHigh, bool lowerLow](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* barCount\n* The number of required consecutive lower closes\n\n---\n\n* barDown\n* Each bar's open must be less than the close; true or false\n\n---\n\n* lowerHigh\n* Consecutive lower highs required; true or false\n\n---\n\n* lowerLow\n* Consecutive lower lows required; true or false\n{% /table %}\n\n## Examples\n\n```csharp\n// OnBarUpdate method\nprotected override void OnBarUpdate()\n{\n   // Evaluates if we have 3 consecutive lower closes\n   double value = NBarsDown(3, true, true, true)[0];\n \n   if (value == 1)\n       Print(\"We have three consecutive lower closes\");\n}\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "f4967f139e267db59b47da7a9347bdc7ed264c7f6809e154b288275371fbaa50",
    "_type": "desktopSdkDoc",
    "title": "n Bars Up",
    "pathName": "n_bars_up",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nEvaluates for n number of consecutive higher closes. Returns a value of 1 when the condition is true or 0 when false.\n\n## Syntax\n\n**NBarsUp(int barCount, bool barUp, bool higherHigh, bool higherLow)**  \n\n**NBarsUp(ISeries`<double>` input, int barCount, bool barUp, bool higherHigh, bool higherLow)**\n\nReturns default value  \n\n**NBarsUp[int barCount, bool barUp, bool higherHigh, bool higherLow](int barsAgo)**  \n\n**NBarsUp[ISeries`<double>` input, int barCount, bool barUp, bool higherHigh, bool higherLow](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **barCount**\n* The number of required consecutive higher closes\n\n---\n\n* **barUp**\n* Each bar's close must be higher than the open; true or false\n\n---\n\n* **higherHigh**\n* Consecutive higher highs required; true or false\n\n---\n\n* **higherLow**\n* Consecutive higher lows required; true or false\n{% /table %}\n\n## Examples\n\n```csharp\n// OnBarUpdate method\nprotected override void OnBarUpdate()\n{\n   // Evaluates if we have 3 consecutive higher closes\n   double value = NBarsUp(3, true, true, true)[0];\n \n   if (value == 1)\n       Print(\"We have three consecutive higher closes\");\n}\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "fc0ccc3e1a1be75ec0b1d8aef28d7f839d55e9404c8abd62f4465b5bf48665e4",
    "_type": "desktopSdkDoc",
    "title": "On Balance Volume (OBV)",
    "pathName": "on_balance_volume_obv",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nOBV is a simple indicator that adds a period's volume when the close is up and subtracts the period's volume when the close is down. A cumulative total of the volume additions and subtractions forms the OBV line. This line can then be compared with the price chart of the underlying security to look for divergences or confirmation.\n\n... Courtesy of [StockCharts](http://stockcharts.com/education/IndicatorAnalysis/indic-obv.htm)\n\n## Syntax\n\n**OBV()**  \n\n**OBV(ISeries`<double>` input)**\n\nReturns default value  \n\n**OBV()[int barsAgo]**  \n\n**OBV[ISeries`<double>` input](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **input**\n* Indicator source data ([?](valid_input_data_for_indicator.htm))\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of OBV\ndouble value = OBV()[0];\nPrint(\"The current OBV value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "9ac74fb8a474cacb5c0ad7ff52c5e54425038fa0e79496bb86904447be04ec64",
    "_type": "desktopSdkDoc",
    "title": "Order Flow Cumulative Delta",
    "pathName": "order_flow_cumulative_delta",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nAn indicator that accumulates the volume of orders filled at bid and ask prices or up and down ticks throughout the session and compares them to determine buy/sell pressure.\n\n## Syntax\n\n**OrderFlowCumulativeDelta(CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter)**\n\n**OrderFlowCumulativeDelta(ISeries`<double>` input, CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter)**\n\n## Returns Open value\n\n**OrderFlowCumulativeDelta(CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter).DeltaOpen[int barsAgo]**\n\n**OrderFlowCumulativeDelta(ISeries`<double>` input, CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter).DeltaOpen[int barsAgo]**\n\n## Returns High value\n\n**OrderFlowCumulativeDelta(CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter).DeltaHigh[int barsAgo]**\n\n**OrderFlowCumulativeDelta(ISeries`<double>` input, CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter).DeltaHigh[int barsAgo]**\n\n## Returns Low value\n\n**OrderFlowCumulativeDelta(CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter).DeltaLow[int barsAgo]**\n\n**OrderFlowCumulativeDelta(ISeries`<double>` input, CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter).DeltaLow[int barsAgo]**\n\n## Returns Close value\n\n**OrderFlowCumulativeDelta(CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter).DeltaClose[int barsAgo]**\n\n**OrderFlowCumulativeDelta(ISeries`<double>` input, CumulativeDeltaType deltaType, CumulativeDeltaPeriod period, int sizeFilter).DeltaClose[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* deltaType\n* The type of data to delta calculates on:\n  * BidAsk\n  * UpDownTick\n\n---\n\n* period\n* The period in which the delta accumulates:\n  * Session\n  * Bar\n\n---\n\n* sizeFilter\n* Input to exclude volume less than the selected value\n{% /table %}\n\n## Examples\n\n```csharp\n// Calling the OrderFlowCumulativeDelta() method directly\n// A 1 tick data series must be added to the OnStateChange() as this indicator runs off of tick data\nelse if (State == State.Configure)\n{\n   AddDataSeries(Data.BarsPeriodType.Tick, 1);\n}\n\n// OnBarUpdate() logic\nif (BarsInProgress == 0)\n{\n    // Print the close of the cumulative delta bar with a delta type of Bid Ask and with a Session period\n    Print(\"Delta Close: \" + OrderFlowCumulativeDelta(BarsArray[0], CumulativeDeltaType.BidAsk, CumulativeDeltaPeriod.Session, 0).DeltaClose[0]);\n}\nelse if (BarsInProgress == 1)\n{\n    // We have to update the secondary series of the cached indicator to make sure the values we get in BarsInProgress == 0 are in sync\n    OrderFlowCumulativeDelta(BarsArray[0], CumulativeDeltaType.BidAsk, CumulativeDeltaPeriod.Session, 0).Update(OrderFlowCumulativeDelta(BarsArray[0], CumulativeDeltaType.BidAsk, CumulativeDeltaPeriod.Session, 0).BarsArray[1].Count - 1, 1);\n}\n```\n\n```csharp\n// Calling the OrderFlowCumulativeDelta() method by reference\n\n// A 1 tick data series must be added to OnStateChange() as this indicator runs off of tick data\nelse if (State == State.Configure)\n{\n    AddDataSeries(Data.BarsPeriodType.Tick, 1);\n}\nelse if (State == State.DataLoaded)\n{\n    // Instantiate the indicator\n    cumulativeDelta = OrderFlowCumulativeDelta(CumulativeDeltaType.BidAsk, CumulativeDeltaPeriod.Session, 0);\n}\n\nif (BarsInProgress == 0)\n{\n    // Print the close of the cumulative delta bar with a delta type of Bid Ask and with a Session period\n    Print(\"Delta Close: \" + cumulativeDelta.DeltaClose[0]);\n}\nelse if (BarsInProgress == 1)\n{\n    // We have to update the secondary series of the hosted indicator to make sure the values we get in BarsInProgress == 0 are in sync\n    cumulativeDelta.Update(cumulativeDelta.BarsArray[1].Count - 1, 1);\n}\n```"
  },
  {
    "_id": "4d722cd83e1f7ddfbe05d59ff18280f906d68443b699527c3d206f124f00e05c",
    "_type": "desktopSdkDoc",
    "title": "Order Flow Volumetric Bars",
    "pathName": "order_flow_volumetric_bars",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nNinjaTrader Order Flow Volumetric bars provide a detailed ‘x-ray’ view into each price bar’s aggressive buying and selling activity. This technique primarily attempts to answer the question which side was the most aggressive at each price level. This is done by calculating the delta (greek for difference) between buying and selling volume.\n\nMany of the NinjaTrader Order Flow Volumetric Bar and Bar Statistics values could be accessed from your custom NinjaScript objects further leveraging the power of these analysis techniques.\n\n## Methods and Properties the VolumetricBarsType exposes\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* BarDelta\n\n* Gets a long value with the total bar's delta\n\n---\n\n* CumulativeDelta\n\n* Gets a long value with the cumulative delta (Note: the accumulation is reset at the session break)\n\n---\n\n* DeltaSh\n\n* The delta since last time price touched the high of the bar, usually negative\n\n---\n\n* DeltaSl\n\n* The delta since last time price touched the low of the bar, usually positive.\n\n---\n\n* GetAskVolumeForPrice(double price)\n\n* Gets the ask volume (long value) for the passed in price\n\n---\n\n* GetBidVolumeForPrice(double price)\n\n* Gets the sell volume (long value) for the passed in price\n\n---\n\n* GetDeltaForPrice(double price)\n\n* Gets the horizontal delta (long value) for the passed in price\n\n---\n\n* GetDeltaPercent()\n\n* Gets A double value with the delta % of volume for the bar\n\n---\n\n* GetMaximumPositiveDelta()\n\n* Gets the highest positive delta (long value) for the bar (if there is no positive delta in the bar, it will get the lowest negative delta)\n\n---\n\n* GetMaximumNegativeDelta()\n\n* Gets the highest negative delta (long value) for the bar (if there is no negative delta in the bar, it will get the lowest positive delta)\n\n---\n\n* GetMaximumVolume(bool? askVolume, out double price)\n\n* Gets the highest Ask, Bid or combined volume (long value) for the bar and returns the price at which it occurred.\n\n* pass in true for getting the highest Ask volume\n\n* pass in false for getting the highest Bid volume\n\n* pass in null for getting the highest combined volume\n\n* For scenarios where Ticks per level is greater than 1, this method will return the lowest price - with Ticks per level known, the remaining prices in the result cell could be custom calculated if desired.\n\n---\n\n* GetTotalVolumeForPrice(double price)\n\n* Gets the total volume (long value) for the passed in price\n\n---\n\n* MaxSeenDelta\n\n* Gets the highest delta (long value) seen intrabar\n\n---\n\n* MinSeenDelta\n\n* Gets the lowest delta (long value) seen intrabar\n\n---\n\n* TotalBuyingVolume\n\n* Gets the total buying volume (long value) for the bar\n\n---\n\n* TotalSellingVolume\n\n* Gets the total selling volume (long value) for the bar\n\n---\n\n* Trades\n\n* Gets to total number of trades (long value) for the bar\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    if (Bars == null)\n        return;\n\n    // This sample assumes the Volumetric series is the primary DataSeries on the chart, if you would want to add a Volumetric series to a \n    // script, you could call AddVolumetric() in State.Configure and then for example use\n    // NinjaTrader.NinjaScript.BarsTypes.VolumetricBarsType barsType = BarsArray[1].BarsType as \n    // NinjaTrader.NinjaScript.BarsTypes.VolumetricBarsType;\n\n    NinjaTrader.NinjaScript.BarsTypes.VolumetricBarsType barsType = Bars.BarsSeries.BarsType as \n        NinjaTrader.NinjaScript.BarsTypes.VolumetricBarsType;\n\n    if (barsType == null)\n        return;\n\n    try\n    {\n        double price;\n        Print(\"=========================================================================\");\n        Print(\"Bar: \" + CurrentBar);\n        Print(\"Trades: \" + barsType.Volumes[CurrentBar].Trades);\n        Print(\"Total Volume: \" + barsType.Volumes[CurrentBar].TotalVolume);\n        Print(\"Total Buying Volume: \" + barsType.Volumes[CurrentBar].TotalBuyingVolume);\n        Print(\"Total Selling Volume: \" + barsType.Volumes[CurrentBar].TotalSellingVolume);\n        Print(\"Delta for bar: \" + barsType.Volumes[CurrentBar].BarDelta);\n        Print(\"Delta for bar (%): \" + barsType.Volumes[CurrentBar].GetDeltaPercent());\n        Print(\"Delta for Close: \" + barsType.Volumes[CurrentBar].GetDeltaForPrice(Close[0]));\n        Print(\"Ask for Close: \" + barsType.Volumes[CurrentBar].GetAskVolumeForPrice(Close[0]));\n        Print(\"Bid for Close: \" + barsType.Volumes[CurrentBar].GetBidVolumeForPrice(Close[0]));\n        Print(\"Volume for Close: \" + barsType.Volumes[CurrentBar].GetTotalVolumeForPrice(Close[0]));\n        Print(\"Maximum Ask: \" + barsType.Volumes[CurrentBar].GetMaximumVolume(true, out price) + \" at price: \" + price);\n        Print(\"Maximum Bid: \" + barsType.Volumes[CurrentBar].GetMaximumVolume(false, out price) + \" at price: \" + price);\n        Print(\"Maximum Combined: \" + barsType.Volumes[CurrentBar].GetMaximumVolume(null, out price) + \" at price: \" + price);\n        Print(\"Maximum Positive Delta: \" + barsType.Volumes[CurrentBar].GetMaximumPositiveDelta());\n        Print(\"Maximum Negative Delta: \" + barsType.Volumes[CurrentBar].GetMaximumNegativeDelta());\n        Print(\"Max seen delta (bar): \" + barsType.Volumes[CurrentBar].MaxSeenDelta);\n        Print(\"Min seen delta (bar): \" + barsType.Volumes[CurrentBar].MinSeenDelta);\n        Print(\"Cumulative delta (bar): \" + barsType.Volumes[CurrentBar].CumulativeDelta);\n        Print(\"Delta Since High (bar): \" + barsType.Volumes[CurrentBar].DeltaSh);\n        Print(\"Delta Since Low (bar): \" + barsType.Volumes[CurrentBar].DeltaSl);\n    }\n    catch{}\n}\n```\n\n{% callout type=\"note\" %}\n\nPlease note in the example above a **CurrentBar** reference is used as index, and not a BarsAgo reference.\n\n{% /callout %}"
  },
  {
    "_id": "bf0831ba06aa9c943b3fa27147571974b41f61e335a3497f5e05bc80056f246b",
    "_type": "desktopSdkDoc",
    "title": "Order Flow VWAP",
    "pathName": "order_flow_vwap",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nVolume Weighted Average Price. A total of the dollars traded for every transaction (price multiplied by number of shares traded) and then divided by the total shares traded for the day. Also included are standard deviation bands.\n\n## Syntax\n\n**OrderFlowVWAP(VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier)**\n\n**OrderFlowVWAP(ISeries`<double>` input, VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier)**\n\nReturns the VWAP value\n\n**OrderFlowVWAP(VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).VWAP[int barsAgo]**\n\n**OrderFlowVWAP(ISeries`<double>` input, VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).VWAP[int barsAgo]**\n\nReturns the StdDev1Upper value\n\n**OrderFlowVWAP(VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev1Upper[int barsAgo]**\n\n**OrderFlowVWAP(ISeries`<double>` input, VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev1Upper[int barsAgo]**\n\nReturns the StdDev1Lower value\n\n**OrderFlowVWAP(VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev1Lower[int barsAgo]**\n\n**OrderFlowVWAP(ISeries`<double>` input, VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev1Lower[int barsAgo]**\n\nReturns the StdDev2Upper value\n\n**OrderFlowVWAP(VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev2Upper[int barsAgo]**\n\n**OrderFlowVWAP(ISeries`<double>` input, VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev2Upper[int barsAgo]**\n\nReturns the StdDev2Lower value\n\n**OrderFlowVWAP(VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev2Lower[int barsAgo]**\n\n**OrderFlowVWAP(ISeries`<double>` input, VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev2Lower[int barsAgo]**\n\nReturns the StdDev3Upper value\n\n**OrderFlowVWAP(VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev3Upper[int barsAgo]**\n\n**OrderFlowVWAP(ISeries`<double>` input, VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev3Upper[int barsAgo]**\n\nReturns the StdDev3Lower value\n\n**OrderFlowVWAP(VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev3Lower[int barsAgo]**\n\n**OrderFlowVWAP(ISeries`<double>` input, VWAPResolution resolution, TradingHours tradingHoursInstance, VWAPStandardDeviations numStandardDeviations, double sD1Multiplier, double sD2Multiplier, double sD3Multiplier).StdDev3Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* resolution\n* The data the indicator will run off of: Standard, Tick\n\n---\n\n* tradingHoursInstance\n* The trading hour template that will indicate when the VWAP resets\n\n---\n\n* numStandardDeviations\n* The number of standard deviations of the VWAP\n\n---\n\n* sD1Multiplier\n* The multiplier for the first standard deviation\n\n---\n\n* sD2Multiplier\n* The multiplier for the second standard deviation\n\n---\n\n* sD3Multiplier\n* The multiplier for the third standard deviation\n{% /table %}\n\n## Examples\n\n```csharp\n// A 1 tick data series must be added to the OnStateChange() if using a Tick Resolution (our second example call below in OnBarUpdate())\nelse if (State == State.Configure)\n{\n  AddDataSeries(Data.BarsPeriodType.Tick, 1);\n}\n  \n// OnBarUpdate() logic\nif (BarsInProgress == 0)\n{\n  // Prints the VWAP value using a standard resolution off of RTH trading hours\n  double VWAPValue = OrderFlowVWAP(VWAPResolution.Standard, TradingHours.String2TradingHours(\"CME US Index Futures RTH\"), VWAPStandardDeviations.Three, 1, 2, 3).VWAP[0];\n  Print(\"The current VWAP with a standard resolution on CME US Index Futures RTH is \" + VWAPValue.ToString());\n  \n// Prints the first upper standard deviation value using a tick resolution off of trading hours of the Data Series\n  double VWAPStdDevUp1 = OrderFlowVWAP(VWAPResolution.Tick, Bars.TradingHours, VWAPStandardDeviations.Three, 1, 2, 3).StdDev1Upper[0];\n  Print(\"The current VWAP with a tick resolution on \" + Bars.TradingHours.ToString() + \" is \" + VWAPStdDevUp1.ToString());\n}\nelse if (BarsInProgress == 1)\n{\n  // We have to update the secondary tick series of the cached indicator using Tick Resolution to make sure the values we get in BarsInProgress == 0 are in sync\n  OrderFlowVWAP(BarsArray[0], VWAPResolution.Tick, BarsArray[0].TradingHours, VWAPStandardDeviations.Three, 1, 2, 3).Update(OrderFlowVWAP(BarsArray[0], VWAPResolution.Tick, BarsArray[0].TradingHours, VWAPStandardDeviations.Three, 1, 2, 3).BarsArray[1].Count - 1, 1);\n}\n```\n\n{% callout type=\"note\" }\n\n1. Referencing multiple **OrderFlowVWAP**'s with different ResetInterval’s in a single NinjaScript Indicator / Strategy is not supported by default. Please contact [platformsupport@ninjatrader.com](mailto:platformsupport@ninjatrader.com) for a workaround.\n2. Referencing **OrderFlowVWAP** in a NinjaScript indicator or strategy which runs on either **Calcuate.OnEachTick** or **.OnPriceChange**, historical data is needed for accurate calculations.\n{% /table %}"
  },
  {
    "_id": "fc6a5f4bcf016b84cc006fd6c5400f24bb1324c7b89d9af9c8588d88de0658c8",
    "_type": "desktopSdkDoc",
    "title": "Parabolic SAR",
    "pathName": "parabolic_sar",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe parabolic SAR is a technical indicator that is used by many traders to determine the direction of an asset's momentum and the point in time when this momentum has a higher-than-normal probability of switching directions.\n\n... Courtesy of [Investopedia](http://www.investopedia.com/articles/technical/02/042202.asp)\n\n## Syntax\n\n**ParabolicSAR(double acceleration, double accelerationMax, double accelerationStep)**\n\n**ParabolicSAR(ISeries`<double>` input, double acceleration, double accelerationMax, double accelerationStep)**\n\nReturns default value  \n\n**ParabolicSAR[double acceleration, double accelerationMax, double accelerationStep](int barsAgo)**  \n\n**ParabolicSAR[ISeries`<double>` input, double acceleration, double accelerationStep, double accelerationMax](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **acceleration**\n* Acceleration value\n\n---\n\n* **accelerationStep**\n* Step value used to increment acceleration value\n\n---\n\n* **accelerationMax**\n* Max acceleration value\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of ParabolicSAR using default price type\ndouble value = ParabolicSAR(0.02, 0.2, 0.02)[0];\nPrint(\"The current ParabolicSAR value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "15b7fb70983d4e027f790777f162f032246ff79cf4af8bba7dc1e49614eca5a1",
    "_type": "desktopSdkDoc",
    "title": "Percentage Price Oscillator (PPO)",
    "pathName": "percentage_price_oscillator_pp",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Percentage Price Oscillator shows the percentage difference between two **exponential moving averages**.\n\n## Syntax\n\n**PPO(int fast, int slow, int smooth)**  \n\n**PPO(ISeries`<double>` input, int fast, int slow, int smooth)**\n\nReturns default value  \n\n**PPO[int fast, int slow, int smooth](int barsAgo)**  \n\n**PPO[ISeries`<double>` input, int fast, int slow, int smooth](int barsAgo)**\n\nReturns smoothed value  \n\n**PPO(int fast, int slow, int smooth).Smoothed[int barsAgo]**  \n\n**PPO(ISeries`<double>` input, int fast, int slow, int smooth).Smoothed[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* fast\n* The number of bars to calculate the fast EMA\n\n---\n\n* input\n* Indicator source data (**[?](valid_input_data_for_indicator)**)\n\n---\n\n* slow\n* The number of bars to calculate the slow EMA\n\n---\n\n* smooth\n* The number of bars to calculate the EMA signal line\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period Percentage Price Oscillator\ndouble value = PPO(12, 26, 9)[0];\nPrint(\"The current Percentage Price Oscillator value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "dd4f1b19af691d0b9cce69af0404be49085e0be4ad509720a2421dfd0d245e71",
    "_type": "desktopSdkDoc",
    "title": "Pivots",
    "pathName": "pivots",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe pivot point is used as a predictive indicator. If the following day's market price falls below the pivot point, it may be used as a new resistance level. Conversely, if the market price rises above the pivot point, it may act as the new support level.\n\n... Courtesy of [Investopedia](http://www.investopedia.com/articles/technical/04/041404.asp)\n\n## Syntax\n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)**\n\nReturns pivot point value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).Pp[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).PP[int barsAgo]**\n\nReturns R1 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]**\n\nReturns R2 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]**\n\nReturns R3 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]**\n\nReturns S1 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]**\n\nReturns S2 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]**\n\nReturns S3 value  \n\n**Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]**  \n\n**Pivots(ISeries`<double>` input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator.htm))\n\n---\n\n* pivotRangeType\n* Sets the range for the type of pivot calculated. Possible values are: **PivotRange.Daily**, **PivotRange.Weekly**, **PivotRange.Monthly**\n\n---\n\n* priorDayHLC\n* Sets how the prior range High, Low, Close values are calculated. Possible values are: **HLCCalculationMode.CalcFromIntradayData**, **HLCCalculationMode.DailyBars**, **HLCCalculationMode.UserDefinedValues**\n\n---\n\n* userDefinedClose\n* Sets the close for Pivots calculations when using **HLCCalculationMode.UserDefinedValues**.\n\n---\n\n* userDefinedHigh\n* Sets the high for Pivots calculations when using **HLCCalculationMode.UserDefinedValues**.\n\n---\n\n* userDefinedLow\n* Sets the low for Pivots calculations when using **HLCCalculationMode.UserDefinedValues**.\n\n---\n\n* width\n* Sets how long the Pivots lines will be drawn\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current pivot point value\ndouble value = Pivots(PivotRange.Daily, HLCCalculationMode.CalcFromIntradayData, 0, 0, 0, 20).Pp[0];\nPrint(\"The current Pivots' pivot value is \" + value.ToString());\n\n// Prints the current S2 pivot value\ndouble value = Pivots(PivotRange.Daily, HLCCalculationMode.CalcFromIntradayData, 0, 0, 0, 20).S2[0];\nPrint(\"The current Pivots' S2 pivot value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.\n\n{% callout type=\"note\" %}\n\nWhen using **HLCCalculationMode.DailyBars** it can be expected that a value of 0 is returned when the daily bars have not been loaded yet. Due to the asynchronous nature of this indicator calling daily bars you should only access the pivot values when the indicator has loaded all required Bars objects. To ensure you are accessing accurate values you can use **.[IsValidDataPoint()](isvaliddatapoint.htm)** as a check:\n\n{% /callout %}\n\n```csharp\n// Evaluates that this is a valid pivot point value\nif (Pivots(PivotRange.Daily, HLCCalculationMode.DailyBars, 0, 0, 0, 20).Pp.IsValidDataPoint(0))\n{\n     // Prints the current pivot point value\n     double value = Pivots(PivotRange.Daily, HLCCalculationMode.DailyBars, 0, 0, 0, 20).Pp[0];\n     Print(\"The current Pivots' pivot value is \" + value.ToString());\n}\n```"
  },
  {
    "_id": "c3dad76d8a9eb536d7148040eeb5de190cb0754c32fc1064e0c3e306dec86184",
    "_type": "desktopSdkDoc",
    "title": "Polarized Fractal Efficiency (PFE)",
    "pathName": "polarized_fractal_efficiency_pfe",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Polarized Fractal Efficiency indicator uses fractal geometry to determine how efficiently the price is moving. When the **PFE** is zigzagging around zero, then the price is congested and not trending. When the **PFE** is smooth and above/below zero, then the price is in an up/down trend. The higher/lower the **PFE** value, the stronger the trend is.\n\n... Courtesy of [FMLabs](http://www.fmlabs.com/reference/default.htm?url=PFE.htm)\n\n## Syntax\n\n**PFE(int period, int smooth)**  \n\n**PFE(ISeries`<double>` input, int period, int smooth)**\n\nReturns default value  \n\n**PFE[int period, int smooth](int barsAgo)**  \n\n**PFE[ISeries`<double>` input, int period, int smooth](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n* smooth\n* The smoothing factor to be applied\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period PFE using default price type\ndouble value = PFE(20, 2)[0];\nPrint(\"The current PFE value is \" + value.ToString());\n\n// Prints the current value of a 20 period PFE using high price type\ndouble value = PFE(High, 20, 2)[0];\nPrint(\"The current PFE value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "d04e004d075457a688bf1656444218f3b371a1e9b8b6c9488977ebf2cc80f2ad",
    "_type": "desktopSdkDoc",
    "title": "Price Oscillator",
    "pathName": "price_oscillator",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Price Oscillator is an indicator based on the difference between two **moving averages**, and is expressed as either a percentage or in absolute terms.\n\n... Courtesy of [StockCharts](http://stockcharts.com/education/IndicatorAnalysis/indic_priceOscillator.html)\n\n## Syntax\n\n**PriceOscillator(int fast, int slow, int smooth)**  \n**PriceOscillator(ISeries`<double>` input, int fast, int slow, int smooth)**\n\nReturns default value  \n**PriceOscillator[int fast, int slow, int smooth](int barsAgo)**  \n**PriceOscillator[ISeries`<double>` input, int fast, int slow, int smooth](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* fast\n* The number of bars to calculate the fast **EMA**\n\n---\n\n* input\n* Indicator source data (**[?](valid_input_data_for_indicator)**)\n\n---\n\n* slow\n* The number of bars to calculate the slow **EMA**\n\n---\n\n* smooth\n* The number of bars to calculate the **EMA** signal line\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period PriceOscillator using default price type\ndouble value = PriceOscillator(12, 26, 9)[0];\nPrint(\"The current PriceOscillator value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "4cf75a76e2bb4ebd2938ad5baeebd801b0134f17eaf2da7cf3aefcb7d486d865",
    "_type": "desktopSdkDoc",
    "title": "Prior Day OHLC",
    "pathName": "prior_day_ohlc",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe prior day (session) open, high, low and close values.\n\n{% callout type=\"note\" %}\n\nOnly use this indicator on intraday series.\n\n{% /callout %}\n\n## Syntax\n\n**PriorDayOHLC()**  \n\n**PriorDayOHLC(ISeries`<double>` input)**\n\nReturns prior session open value  \n\n**PriorDayOHLC().PriorOpen[int barsAgo]**  \n\n**PriorDayOHLC(ISeries`<double>` input).PriorOpen[int barsAgo]**\n\nReturns prior session high value  \n\n**PriorDayOHLC().PriorHigh[int barsAgo]**  \n\n**PriorDayOHLC(ISeries`<double>` input).PriorHigh[int barsAgo]**\n\nReturns prior session low value  \n\n**PriorDayOHLC().PriorLow[int barsAgo]**  \n\n**PriorDayOHLC(ISeries`<double>` input).PriorLow[int barsAgo]**\n\nReturns prior session close value  \n\n**PriorDayOHLC().PriorClose[int barsAgo]**  \n\n**PriorDayOHLC(ISeries`<double>` input).PriorClose[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the value of the prior session low\ndouble value = PriorDayOHLC().PriorLow[0];\nPrint(\"The prior session low value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "528f571880d513bc6763f516ebea6a5098105a49a912b62c3ee7a59c8ea016a4",
    "_type": "desktopSdkDoc",
    "title": "Psychological Line",
    "pathName": "psychological_line",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Psychological Line is the ratio of the number of rising bars over the specified number of bars.\n\n## Syntax\n\n**PsychologicalLine(int period)**\n\n**PsychologicalLine(ISeries`<double>` input, int period)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **int barsAgo** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data ([**valid_input_data_for_indicator**](valid_input_data_for_indicator))\n\n---\n\n* period\n\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 10 period Psychological Line\ndouble value = PsychologicalLine[10](0);\nPrint(\"The current Psychological Line value is \" + value.ToString());\n```"
  },
  {
    "_id": "2269c0be009b610cfdbb8cfe9253ad37cf95062fb3f5a7560268ff259ea9f087",
    "_type": "desktopSdkDoc",
    "title": "Range",
    "pathName": "range",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nReturns the range of a bar.\n\n## Syntax\n\n**Range()**  \n**Range(ISeries`<double>` input)**\n\nReturns default value  \n**Range()[int barsAgo]**  \n**Range[ISeries`<double>` input](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data (**[?](valid_input_data_for_indicator)**)\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the range of the current bar\ndouble value = Range()[0];\nPrint(\"The current bar's range is \" + value.ToString());\n\n// Prints the 20 period simple moving average of range\ndouble value = SMA(Range(), 20)[0];\nPrint(\"The 20 period average of range is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "ddf0b0deb3a8ce21e786e97454e2baf228117a526818983a2023166e96d83e33",
    "_type": "desktopSdkDoc",
    "title": "Range Indicator (RIND)",
    "pathName": "range_indicator_rind",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Range indicator compares the intraday range (high - low) to the inter-day (close - previous close) range. When the inter-day range is less than the intraday range, the Range Indicator will be a high value. This signals an end to the current trend. When the Range Indicator is at a low level, a new trend is about to start.\n\nThe Range Indicator was developed by Jack Weinberg and was introduced in his article in the June, 1995 issue of Technical Analysis of Stocks & Commodities magazine.\n\n## Syntax\n\n**RIND(int periodQ, int smooth)**  \n**RIND(ISeries`<double>` input, int periodQ, int smooth)**\n\nReturns default value  \n**RIND[int periodQ, int smooth](int barsAgo)**  \n**RIND[ISeries`<double>` input, int periodQ, int smooth](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* input\n* periodQ\n* smooth\n\n---\n\n* Indicator source data ([**valid_input_data_for_indicator**](valid_input_data_for_indicator))\n* The number of bars to include in the calculation for the short term stochastic range lookback\n* The number of bars to include for the EMA smoothing of the indicator\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints out a historical RIND value\ndouble value = RIND[3, 10](5);\nPrint(\"RIND value of 5 bars ago is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "a41abc3a1742ade5ef423f1187e767f15b7c628335d54545ffae2c6b0069d211",
    "_type": "desktopSdkDoc",
    "title": "Rate of Change (ROC)",
    "pathName": "rate_of_change_roc",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Rate of Change (ROC) indicator is a very simple yet effective momentum oscillator that measures the percent change in price from one period to the next. The ROC calculation compares the current price with the price n periods ago.\n\n... Courtesy of [StockCharts](stockcharts)\n\n## Syntax\n\n**ROC(int period)**  \n**ROC(ISeries`<double>` input, int period)**\n\nReturns default value  \n**ROC[int period](int barsAgo)**  \n**ROC[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\nPrints the current value of a 20 period ROC using default price type\ndouble value = ROC[20](0);\nPrint(\"The current ROC value is \" + value.ToString());\n\n// Prints the current value of a 20 period ROC using high price type\ndouble value = ROC[High, 20](0);\nPrint(\"The current ROC value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "78b672507fa45642eec6ae54c3342e660880f619e086ab71695fcf627ae8bfa3",
    "_type": "desktopSdkDoc",
    "title": "Regression Channel",
    "pathName": "regression_channel",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nA Regression Channel is created by drawing parallel lines above and below the **Linear Regression** line.\n\nParallel and equidistant lines are drawn n standard deviations (width parameter) above and below a Linear Regression trendline. The distance between the channel lines and the regression line is the greatest distance that any one closing price is from the regression line. Regression Channels contain price movement, the top channel line provides resistance and the bottom channel line provides support. A reversal in trend may be indicated when prices remain outside the channel for a longer period of time.\n\nA Linear Regression trendline shows where equilibrium exists but Linear Regression Channels show the range prices can be expected to deviate from a trendline.\n\n## Syntax\n\n**RegressionChannel(int period, double width)**  \n\n**RegressionChannel(ISeries`<double>` input, int period, double width)**  \n\n**Returns default midline value**  \n\n**RegressionChannel[int period, double width](int barsAgo)**  \n\n**RegressionChannel[ISeries`<double>` input, int period, double width](int barsAgo)**  \n\n**Returns upper channel value**  \n\n**RegressionChannel(int period, double width).Upper[int barsAgo]**  \n\n**RegressionChannel(ISeries`<double>` input, int period, double width).Upper[int barsAgo]**  \n\n**Returns lower channel value**  \n\n**RegressionChannel(int period, double width).Lower[int barsAgo]**  \n\n**RegressionChannel(ISeries`<double>` input, int period, double width).Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n* width\n* Number of std deviations to calculate the channel lines\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: You should not access historical values of this indicator since the values can change from bar to bar. The values from n bars ago does not reflect what the values of the current bar really are. It is suggested that you only access the current bar value for this indicator.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period channel using default price type\ndouble value = RegressionChannel(20, 2).Upper[0];\nPrint(\"The current upper channel value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "96dadfb2df64baec1eaf55586d96221ea74314cd833626acaa2c8717a405a031",
    "_type": "desktopSdkDoc",
    "title": "Relative Spread Strength (RSS)",
    "pathName": "relative_spread_strength_rss",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by Ian Copsey, **Relative Spread Strength** is a variation to the [Relative Strength Index](relative_strength_index_rsi).\n\n## Syntax\n\n**RSS(int eMA1, int eMA2, int length)**\n\n**RSS(ISeries`<double>` input, int eMA1, int eMA2, int length)**\n\nReturns default value\n\n**RSS[int eMA1, int eMA2, int length](int barsAgo)**\n\n**RSS[ISeries`<double>` input, int eMA1, int eMA2, int length](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* eMA1\n* First EMA's period\n\n---\n\n* eMA2\n* Second EMA's period\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* length\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of the RSS using default price type\ndouble value = RSS[10, 40, 5](0);\nPrint(\"The current RSS value is \" + value.ToString());\n\n// Prints the current value of the RSS using high price type\ndouble value = RSS[High, 10, 40, 5](0);\nPrint(\"The current RSS value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "c2eec4fb4ef0c73f76529e70d6b188e6b906d46be1a6a0578a5288212537c418",
    "_type": "desktopSdkDoc",
    "title": "Relative Strength Index (RSI)",
    "pathName": "relative_strength_index_rsi",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by J. Welles Wilder and introduced in his 1978 book, New Concepts in Technical Trading Systems, the Relative Strength Index (RSI) is an extremely useful and popular momentum oscillator. The RSI compares the magnitude of a stock's recent gains to the magnitude of its recent losses and turns that information into a number that ranges from 0 to 100.\n\n... Courtesy of [StockCharts](http://stockcharts.com/education/IndicatorAnalysis/indic_RSI.html)\n\nThe original Wilder formula for an exponential moving average with a smoothing constant (k = 1/ Period) is used to calculate the RSI.\n\n## Syntax\n\n**RSI(int period, int smooth)**  \n**RSI(ISeries`<double>` input, int period, int smooth)**\n\nReturns default value  \n**RSI[int period, int smooth](int barsAgo)**  \n**RSI[ISeries`<double>` input, int period, int smooth](int barsAgo)**\n\nReturns avg value  \n**RSI(int period, int smooth).Avg[int barsAgo]**  \n**RSI(ISeries`<double>` input, int period, int smooth).Avg[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n* smooth\n* Smoothing period\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period RSI using default price type\ndouble value = RSI[20, 3](0);\nPrint(\"The current RSI value is \" + value.ToString());\n\n// Prints the current value of a 20 period RSI using high price type\ndouble value = RSI[**High**, 20, 3](0);\nPrint(\"The current RSI value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "2349e6389cce7b5d6f25037ab02886375e8ac77dff112e86b712e084cc28ed17",
    "_type": "desktopSdkDoc",
    "title": "Relative Vigor Index",
    "pathName": "relative_vigor_index",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Relative Vigor Index measures the strength of a trend by comparing an instruments closing price to its price range. It's based on the fact that prices tend to close higher than they open in up trends, and closer lower than they open in downtrends.\n\n## Syntax\n\n**RelativeVigorIndex(int period)**\n\n**RelativeVigorIndex(ISeries`<double>` input, int period)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **int barsAgo** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([**valid_input_data_for_indicator**](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 10 period Relative Vigor Index\ndouble value = RelativeVigorIndex(10)[0];\nPrint(\"The current Relative Vigor Index value is \" + value.ToString());\n```"
  },
  {
    "_id": "e1cefe33a9cb7761d3b9d58c5c17af77241eb0a4290430221316370a3287038b",
    "_type": "desktopSdkDoc",
    "title": "Relative Volatility Index (RVI)",
    "pathName": "relative_volatility_index_rvi",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by Donald Dorsey, the Relative Volatility Index is the **RSI** using the standard deviation over the indicator period in place of the daily price change. The RVI measures the direction of volatility on a scale from 0 to 100. Readings below 50 indicate that the direction of volatility is to the downside and that you should be looking to sell, readings above 50 indicate that the direction of volatility is to the upside and that you should be looking to buy.\n\n## Syntax\n\n**RVI(int period)**  \n\n**RVI(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**RVI[int period](int barsAgo)**  \n\n**RVI[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// OnBarUpdate method\nprotected override void OnBarUpdate()\n{\n    // Check for buy condition\n    if (RVI(14)[0] > 50 && CrossAbove(SMA(9), SMA(14), 1))\n    {\n        EnterLong();\n    }\n}\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "4220dcacfeb3f6bd0df9bb90dfd0f3eb6938f67bcf3860677f2a08517b3db9bf",
    "_type": "desktopSdkDoc",
    "title": "R-squared",
    "pathName": "r_squared",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe **r-squared** indicator calculates how well the price approximates a linear regression line. The indicator gets its name from the calculation, which is, the square of the correlation coefficient (referred to in mathematics by the Greek letter rho, or r). The range of the **r-squared** is from zero to one.\n\n... Courtesy of [FMLabs](http://www.fmlabs.com/reference/default.htm?url=rsquared.htm)\n\n## Syntax\n\n**RSquared(int period)**\n\n**RSquared(ISeries`<double>` input, int period)**\n\nReturns default value\n\n**RSquared[int period](int barsAgo)**\n\n**RSquared[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator.htm))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period R-squared using default price type\ndouble value = RSquared[20](0);\nPrint(\"The current R-squared value is \" + value.ToString());\n\n// Prints the current value of a 20 period R-squared using high price type\ndouble value = RSquared[High, 20](0);\nPrint(\"The current R-squared value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "accc07e9a756d276f200529e8ca0360f0396fc7f44c074456b3d9171e668ee61",
    "_type": "desktopSdkDoc",
    "title": "Standard Deviation (StdDev)",
    "pathName": "standard_deviation_stddev",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nIn probability theory and statistics, **standard deviation** is a measure of the variability or dispersion of a population, a data set, or a probability distribution. A low **standard deviation** indicates that the data points tend to be very close to the same value (the mean), while high **standard deviation** indicates that the data are “spread out” over a large range of values.\n\n... Courtesy of [Wikipedia](standard_deviation)\n\n## Syntax\n\n**StdDev(int period)**  \n\n**StdDev(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**StdDev[int period](int barsAgo)**  \n\n**StdDev[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period **StdDev** using default price type\ndouble value = StdDev[20](0);\nPrint(\"The current **StdDev** value is \" + value.ToString());\n\n// Prints the current value of a 20 period **StdDev** using high price type\ndouble value = StdDev[High, 20](0);\nPrint(\"The current **StdDev** value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > **NinjaScript** Editor > Indicators within the **NinjaTrader** Control Center window."
  },
  {
    "_id": "17a06f6b187dd6f2489ed6fde08175450a0ae1aac9fdffd338cf0bd7149419fc",
    "_type": "desktopSdkDoc",
    "title": "Standard Error (StdError)",
    "pathName": "standard_error_stderror",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe standard error of a method of measurement or estimation is the standard deviation of the sampling distribution associated with the estimation method. The term may also be used to refer to an estimate of that standard deviation, derived from a particular sample used to compute the estimate.\n\n... Courtesy of [Wikipedia](http://en.wikipedia.org/wiki/Standard_error_(statistics))\n\n## Syntax\n\n**StdError(int period)**  \n**StdError(ISeries`<double>` input, int period)**\n\nReturns default value which is the mid line (also known as linear regression)  \n**StdError[int period](int barsAgo)**  \n**StdError[ISeries`<double>` input, int period](int barsAgo)**\n\nReturns upper value  \n**StdError(int period).Upper[int barsAgo]**  \n**StdError(ISeries`<double>` input, int period).Upper[int barsAgo]**\n\nReturns lower value  \n**StdError(int period).Lower[int barsAgo]**  \n**StdError(ISeries`<double>` input, int period).Lower[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current upper value of a 20 period **StdError** using default price type\ndouble value = StdError(20).Upper[0];\nPrint(\"The current upper Standard Error value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "2d65f7f329c9d2f948e335b8d26b96572dfd4cd8395a7dd8acde234aa9e76c22",
    "_type": "desktopSdkDoc",
    "title": "Stochastics",
    "pathName": "stochastics",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by George C. Lane in the late 1950s, the Stochastic Oscillator is a momentum indicator that shows the location of the current close relative to the high/low range over a set number of periods. Closing levels that are consistently near the top of the range indicate accumulation (buying pressure) and those near the bottom of the range indicate distribution (selling pressure).\n\n... Courtesy of [StockCharts](stockcharts)\n\n## Syntax\n\n**Stochastics(int periodD, int periodK, int smooth)**  \n**Stochastics(ISeries`<double>` input, int periodD, int periodK, int smooth)**\n\n**Returns %D value**  \n**Stochastics(int periodD, int periodK, int smooth).D[int barsAgo]**  \n**Stochastics(ISeries`<double>` input, int periodD, int periodK, int smooth).D[int barsAgo]**\n\n**Returns %K value**  \n**Stochastics(int periodD, int periodK, int smooth).K[int barsAgo]**  \n**Stochastics(ISeries`<double>` input, int periodD, int periodK, int smooth).K[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **input**\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* **periodD**\n* The period for the moving average of periodD\n\n---\n\n* **periodK**\n* The period for the moving average of periodK\n\n---\n\n* **smooth**\n* The smoothing value to be used\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current %D value\ndouble value = Stochastics(7, 14, 3).D[0];\nPrint(\"The current Stochastics %D value is \" + value.ToString());\n\n// Prints the current %K value\ndouble value = Stochastics(7, 14, 3).K[0];\nPrint(\"The current Stochastics %K value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "9563e18b5b8acf3db090689324ad3190f27acd03fcb2ab8ae77bca46901bd1d2",
    "_type": "desktopSdkDoc",
    "title": "Stochastics Fast",
    "pathName": "stochastics_fast",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by George C. Lane in the late 1950s, the Stochastic Oscillator is a momentum indicator that shows the location of the current close relative to the high/low range over a set number of periods. Closing levels that are consistently near the top of the range indicate accumulation (buying pressure) and those near the bottom of the range indicate distribution (selling pressure).\n\n... Courtesy of [StockCharts](stockcharts)\n\n## Syntax\n\n**StochasticsFast(int periodD, int periodK)**  \n\n**StochasticsFast(ISeries`<double>` input, int periodD, int periodK)**\n\nReturns %D value  \n\n**StochasticsFast(int periodD, int periodK).D[int barsAgo]**  \n\n**StochasticsFast(ISeries`<double>` input, int periodD, int periodK).D[int barsAgo]**\n\nReturns %K value  \n\n**StochasticsFast(int periodD, int periodK).K[int barsAgo]**  \n\n**StochasticsFast(ISeries`<double>` input, int periodD, int periodK).K[int barsAgo]**\n\n## Return Value\n\n**double;** Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* periodD\n* The period for the moving average of periodD\n\n---\n\n* periodK\n* The period for the moving average of periodK\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current %D value\ndouble value = StochasticsFast(3, 14).D[0];\nPrint(\"The current StochasticsFast %D value is \" + value.ToString());\n\n// Prints the current %K value\ndouble value = StochasticsFast(3, 14).K[0];\nPrint(\"The current StochasticsFast %K value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "67b6770bf8678ee21db9f695d660ecf87e00d2e62818d6eb8cae028cfd48198f",
    "_type": "desktopSdkDoc",
    "title": "Stochastics RSI (StochRSI)",
    "pathName": "stochastics_rsi_stochrsi",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThis is an indicator on indicator implementation. It is simply a **[Stochastics](stochastics)** indicator applied on **[RSI](relative_strength_index_rsi)**.\n\n## Syntax\n\n**StochRSI(int period)**  \n\n**StochRSI(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**StochRSI[int period](int barsAgo)**  \n\n**StochRSI[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data (**[?](valid_input_data_for_indicator)**)\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n## Examples\n\n```csharp\n// Evaluates if the current bar StochRSI value is greater than the value one bar ago\nif (StochRSI[14](0) > StochRSI[14](1))\n   Print(\"Stochastics RSI is rising\");\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "d54ad1becd3a42772043d0b20c83ec9903619f5f986243a165cc137c3ca47b6e",
    "_type": "desktopSdkDoc",
    "title": "Summation (SUM)",
    "pathName": "summation_sum",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nReturns the sum of the values taken over a specified period.\n\n## Syntax\n\n**SUM(int period)**  \n\n**SUM(ISeries`<double>` input, int period)**\n\nReturns default value  \n\n**SUM[int period](int barsAgo)**  \n\n**SUM[ISeries`<double>` input, int period](int barsAgo)**\n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* input\n* Indicator source data ([**valid_input_data_for_indicator**](valid_input_data_for_indicator))\n\n---\n\n* period\n* Number of bars used in the calculation\n\n---\n\n{% /table %}sed in the calculation\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period SUM using default price type\ndouble value = SUM[20](0);\nPrint(\"The current SUM value is \" + value.ToString());\n\n// Prints the current value of a 20 period SUM using high price type\ndouble value = SUM[High, 20](0);\nPrint(\"The current SUM value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "2da977e917bcbc5ef3b51217c7882607dd49d8afdc04a2f90790f562ef287393",
    "_type": "desktopSdkDoc",
    "title": "Swing",
    "pathName": "swing",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe **Swing** indicator will plot lines that represent the swing points based on the strength (number of bars to the left and right of the swing point) parameter provided, it's mostly a visual tool and not meant to be predictive in nature. Only after the strength number of bars has passed since the extreme point, the swing return value could be definitely set, thus the indicator updates its calculations as new incoming data warrants so.\n\nYou can access methods within this indicator to determine the number of bars ago a swing point occurred or the current swing value.\n\n{% callout type=\"note\" %}\n\nTip: To workaround the situation, where the indicator has to recalculate - you could only access the **SwingHigh** / **Low** values the number of swing strength bars ago - those values are calculated in their final state.\n\n{% /callout %}\n\n## Syntax - Bars Ago\n\n**High Bar**  \n**Swing(int strength).SwingHighBar(int barsAgo, int instance, int lookBackPeriod**  \n**Swing(ISeries`<double>` input, int strength).SwingHighBar(int barsAgo, int instance, int lookBackPeriod)**  \n\n**Low Bar**  \n**Swing(int strength).SwingLowBar(int barsAgo, int instance, int lookBackPeriod**  \n**Swing(ISeries`<double>` input, int strength).SwingLowBar(int barsAgo, int instance, int lookBackPeriod)**  \n\n## Return Value\n\nAn **int** value representing the number of bars ago. Returns a value of -1 if a swing point is not found within the look back period.\n\n## Syntax - Value\n\n**High Value**  \n**Swing(int strength).SwingHigh[int barsAgo]**  \n**Swing(ISeries`<double>` input, int strength).SwingHigh[int barsAgo]**  \n\n**Low Value**  \n**Swing(int strength).SwingLow[int barsAgo]**  \n**Swing(ISeries`<double>` input, int strength).SwingLow[int barsAgo]**  \n\n## Return Value\n\n**double;** Accessing this method via an index value **[int barsAgo]** returns the indicator value of the referenced bar.\n\n* A return value of 0 (zero) will be returned if the CurrentBar number is less than the \"strength\" value, or a swing pivot has not yet been found.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* barsAgo\n\n* The number of bars ago that serves as the starting bar from which to work backwards\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* instance\n\n* The occurrence to check for (1 is the most recent, 2 is the 2nd most recent, etc...)\n\n---\n\n* lookBackPeriod\n\n* Number of bars to look back to check for the test condition, which is evaluated on the current bar and the bars in the look back period.\n\n---\n\n* strength\n\n* The number of required bars to the left and right of the swing point\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the high price of the most recent swing high\nPrint(\"The high of the swing bar is \" + High[Math.Max(0, Swing(5).SwingHighBar(0, 1, 10))]);\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "8a3bd3b1fd16d021159b9e29746a1dec6294564bbfa4e04355ef4cb9efe662b0",
    "_type": "desktopSdkDoc",
    "title": "Time Series Forecast (TSF)",
    "pathName": "time_series_forecast_tsf",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Time Series Forecast function displays the statistical trend of a security's price over a specified time period based on linear regression analysis. Instead of a straight linear regression trendline, the Time Series Forecast plots the last point of multiple linear regression trendlines. This is why this indicator may sometimes be referred to as the \"moving linear regression\" indicator or the \"regression oscillator.\"\n\n## Syntax\n\n**TSF(int forecast, int period)**  \n\n**TSF(ISeries`<double>` input, int forecast, int period)**\n\nReturns default value  \n\n**TSF[int forecast, int period](int barsAgo)**  \n\n**TSF[ISeries`<double>` input, int forecast, int period](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **forecast**\n* Forecast period\n\n---\n\n* **input**\n* Indicator source data ([valid input data for indicator](valid_input_data_for_indicator))\n\n---\n\n* **period**\n* Number of bars used in the calculation\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period TSF using default price type\ndouble value = TSF(3, 20)[0];\nPrint(\"The current TSF value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "17c30eabf6e74886e708e67489df6281d46a2c9244205b973ee91267c659725f",
    "_type": "desktopSdkDoc",
    "title": "AtmStrategy",
    "pathName": "atmstrategy",
    "parent": "add_on",
    "order": 0,
    "section": "references",
    "markdown": "AtmStrategy contains properties and methods used to manage [ATM Strategies](advanced_trade_management_atm). When working with an [AtmStrategySelector](atmstrategyselector), selected objects can be case to AtmStrategy to obtain or change their properties.\n\n{% callout type=\"note\" %}\n\n1. For a complete, working example of this class in use, download framework example located on our [Developing AddOns Overview](developing_add_ons)\n2. For more information on working with the ATM strategies programmatically in general, please see the [Using ATM Strategies](using_atm_strategies) section.\n{% /callout %}\n\n## Example\n\n```csharp\n// Using AtmStrategy to handle user selections in an ATM Strategy Selector\nmyAtmStrategySelector.SelectionChanged += (o, args) =>\n{\n   if (myAtmStrategySelector.SelectedItem == null)\n       return;\n   if (args.AddedItems.Count > 0)\n   {\n       // Change the selected TIF in a TIF selector based on what is selected in the ATM Strategy Selector\n       NinjaTrader.NinjaScript.AtmStrategy selectedAtmStrategy = args.AddedItems[0] as NinjaTrader.NinjaScript.AtmStrategy;\n       if (selectedAtmStrategy != null)\n       {\n           myTifSelector.SelectedTif = selectedAtmStrategy.TimeInForce;\n       }\n   }\n};\n```"
  },
  {
    "_id": "68075ee59bb3f05f3fabd56bf69082e061a0ca6dd295da8d4595f86e48ecd4ae",
    "_type": "desktopSdkDoc",
    "title": "CreateAnchor()",
    "pathName": "createanchor",
    "parent": "language_reference",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nUsed to create a new chart anchor at a specified mouse point.\n\n## Method Return Value\n\nA new **ChartAnchor** at a specified point in device pixels.\n\n## Syntax\n\n**CreateAnchor(Point point, ChartControl chartControl, ChartScale chartScale)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **point**\n* A Point in device pixels representing the current mouse cursor position\n\n---\n\n* **chartControl**\n* A ChartControl representing the x-axis\n\n---\n\n* **chartScale**\n* A ChartScale representing the y-axis\n{% /table %}\n\n## Examples\n\n```csharp\npublic override void OnMouseDown(ChartControl chartControl, ChartPanel chartPanel, ChartScale chartScale, ChartAnchor dataPoint)**\n{\n   // get the point where the mouse was clicked\n   Point myPoint = dataPoint.GetPoint(chartControl, chartPanel, chartScale);\n\n   // create an anchor at that point\n   ChartAnchor MyAnchor = CreateAnchor(myPoint, chartControl, chartScale);\n\n   Print(MyAnchor.Time); // 3/16/2015 8:18:48 AM\n}\n```"
  }
]