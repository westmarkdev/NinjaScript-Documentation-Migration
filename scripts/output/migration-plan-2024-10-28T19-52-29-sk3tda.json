[
  {
    "_id": "0611995407b28f708e05ae1516c431ad4c2bd02b9b32fa9196eaf87b613d0dd5",
    "_type": "desktopSdkDoc",
    "title": "AtmStrategyCreate()",
    "pathName": "atmstrategycreate",
    "parent": "atm_strategy_methods",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nSubmits an entry order that will execute a specified ATM Strategy.\n\n{% callout type=\"note\" %}\n\nPlease review the section on using [ATM Strategies](using_atm_strategies). This method is NOT backtestable and will NOT execute on historical data. See the [AtmStrategyCancelEntryOrder()](atmstrategycancelentryorder) to cancel an entry order. See the [AtmStrategyChangeEntryOrder()](atmstrategychangeentryorder) to change the price of the entry order. The ATM Strategy will be created asyncronous on the hosting NinjaScripts UI Thread, a callback is provided solely to check when the ATM Strategy is started on that thread - accessing for example price data in that outside OnBarUpdate() context is not possible. Please see the SampleATMStrategy build into NinjaTrader for example usage.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value\n\n## Syntax\n\n**AtmStrategyCreate(OrderAction action, OrderType orderType, double limitPrice, double stopPrice, TimeInForce timeInForce, string orderId, string strategyTemplateName, string atmStrategyId, Action<ErrorCode, string> callback)**\n\n## Parameters\n\n{% table %}\n\n* action\n* orderType\n* limitPrice\n* stopPrice\n* timeInForce\n* orderId\n* strategyTemplateName\n* atmStrategyId\n* callback\n\n---\n\n* Sets if the entry order is a buy or sell order. Possible values are: OrderAction.Buy, OrderAction.Sell\n* Sets the order type of the entry order. Possible values are: OrderType.Limit, OrderType.Market, OrderType.MIT, OrderType.StopMarket, OrderType.StopLimit\n* The limit price of the order\n* The stop price of the order\n* Sets the time in force of the entry order. Possible values are: TimeInForce.Day, TimeInForce.Gtc\n* The unique identifier for the entry order\n* Specifies which strategy template will be used\n* The unique identifier for the ATM strategy\n* The callback action is used to check that the ATM Strategy is successfully started\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: Unlike NinjaScript Strategy orders (both [managed](managed_approach.md) and [unmanaged](unmanaged_approach)), ATM strategies generated by the AtmStrategyCreate() method can then be managed manually by any order entry window such as the SuperDOM or within your NinjaScript strategy.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprivate string atmStrategyId;\nprivate string atmStrategyOrderId;\nprivate bool   isAtmStrategyCreated = false;\n\nprotected override void OnBarUpdate()\n{\n   if (State < State.Realtime)\n       return;\n\n   if (Close[0] > SMA(20)[0])\n   {\n       atmStrategyId = GetAtmStrategyUniqueId();\n       atmStrategyOrderId = GetAtmStrategyUniqueId();\n\n       AtmStrategyCreate(OrderAction.Buy, OrderType.Market, 0, 0, TimeInForce.Day,\n           atmStrategyOrderId, \"MyTemplate\", atmStrategyId, (atmCallbackErrorCode, atmCallbackId) => {\n\n           // checks that the call back is returned for the current atmStrategyId stored\n           if (atmCallbackId == atmStrategyId)\n           {\n               // check the atm call back for any error codes\n               if (atmCallbackErrorCode == ErrorCode.NoError)\n               {\n                   // if no error, set private bool to true to indicate the atm strategy is created\n                   isAtmStrategyCreated = true;\n               }\n           }\n       });\n   }\n\n   if(isAtmStrategyCreated)\n   {\n       // atm logic\n   }\n\n   else if(!isAtmStrategyCreated)\n   {\n       // custom handling for a failed atm Strategy\n   }\n}\n```"
  },
  {
    "_id": "5dd81f4378860509b8d15276116b0ba02ac55bc39af965b69c507cdc6ff0b66d",
    "_type": "desktopSdkDoc",
    "title": "OnExecutionUpdate()",
    "pathName": "onexecutionupdate",
    "parent": "strategy",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn event driven method which is called on an incoming execution of an order managed by a strategy. An execution is another name for a fill of an order.\n\n* An order can generate multiple executions (partial fills)\n* **OnExecutionUpdate** is typically called after [**OnOrderUpdate()**](onorderupdate)\n* Only orders which have been submitted and managed by the strategy will call **OnExecutionUpdate()**\n* Executions drive the strategy [**Position**](position) object, which is updated when this method is called\n\n{% callout type=\"note\" %}\n\n* Programming in this environment is reserved for the more [advanced user](advanced_order_handling). If you are for example looking to protect a strategy managed position with a basic stop and target, then the [**Set() methods**](managed_approach.md) would be more convenient.\n* When connected to the Playback connection, it is possible for **OnExecutionUpdate()** to trigger in the middle of a call to **OnBarUpdate()**. The Sim101 account adds a simulated random delay for processing execution events, but the Playback connection triggers executions immediately, for the sake of consistency in backtesting. Because of this, **OnExecutionUpdate()** can appear to be triggered earlier than it would in live trading, or when simulation trading on a live connection.\n* Please also review [**Multi-Thread Considerations for NinjaScript**](multi-threading).\n* Its best practice to only work with the passed by value parameters and not reference parameters. This insures that you process each change of the underlying state.\n* Rithmic and Interactive Brokers Users: When using a NinjaScript strategy it is best practice to only work with passed by value data from **OnExecutionUpdate()**. Instances of multiple fills at the same time for the same instrument might result in an incorrect **OnPositionUpdate**, as sequence of events are not guaranteed due to provider API design.\n{% /table %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\nYou must override the method in your strategy with the following syntax:\n\n**protected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity, MarketPosition marketPosition, string orderId, DateTime time)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **execution**\n* An [**Execution**](execution) object passed by reference representing the execution\n\n---\n\n* **executionId**\n* A **string** value representing the execution id\n\n---\n\n* **price**\n* A **double** value representing the execution price\n\n---\n\n* **quantity**\n* An **int** value representing the execution quantity\n\n---\n\n* **marketPosition**\n* A [**MarketPosition**](position_marketposition) object representing the position of the execution. Possible values are:\n  * **MarketPosition.Long**\n  * **MarketPosition.Short**\n\n---\n\n* **orderId**\n* A string representing the order id\n\n---\n\n* **time**\n* A [**DateTime**](http://msdn.microsoft.com/en-us/library/system.datetime.aspx) value representing the time of the execution\n\n{% /table %}\n\n## Examples\n\n{% callout type=\"note\" %}\n\n**OnExecutionUpdate** Example (See [**SampleOnOrderUpdate**](using_onorderupdate_and_onexec) for complete example)\n{% /callout %}\n\n```csharp\nprivate Order entryOrder = null; // This variable holds an object representing our entry order\nprivate Order stopOrder = null; // This variable holds an object representing our stop loss order\nprivate Order targetOrder = null; // This variable holds an object representing our profit target order\nprivate int sumFilled = 0; // This variable tracks the quantities of each execution making up the entry order\n\nprotected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity, MarketPosition marketPosition, string orderId, DateTime time)\n{\n    /* We advise monitoring OnExecutionUpdate() to trigger submission of stop/target orders instead of OnOrderUpdate() since OnExecution() is called after OnOrderUpdate()\n    which ensures your strategy has received the execution which is used for internal signal tracking. */\n    if (entryOrder != null && entryOrder == execution.Order)\n    {\n        if (execution.Order.OrderState == OrderState.Filled || execution.Order.OrderState == OrderState.PartFilled || (execution.Order.OrderState == OrderState.Cancelled && execution.Order.Filled > 0))\n        {\n            // We sum the quantities of each execution making up the entry order\n            sumFilled += execution.Quantity;\n\n            // Submit exit orders for partial fills\n            if (execution.Order.OrderState == OrderState.PartFilled)\n            {\n                stopOrder = ExitLongStopMarket(0, true, execution.Order.Filled, execution.Order.AverageFillPrice - 4 * TickSize, \"MyStop\", \"MyEntry\");\n                targetOrder = ExitLongLimit(0, true, execution.Order.Filled, execution.Order.AverageFillPrice + 8 * TickSize, \"MyTarget\", \"MyEntry\");\n            }\n            // Update our exit order quantities once orderstate turns to filled and we have seen execution quantities match order quantities\n            else if (execution.Order.OrderState == OrderState.Filled && sumFilled == execution.Order.Filled)\n            {\n                // Stop-Loss order for OrderState.Filled\n                stopOrder = ExitLongStopMarket(0, true, execution.Order.Filled, execution.Order.AverageFillPrice - 4 * TickSize, \"MyStop\", \"MyEntry\");\n                targetOrder = ExitLongLimit(0, true, execution.Order.Filled, execution.Order.AverageFillPrice + 8 * TickSize, \"MyTarget\", \"MyEntry\");\n            }\n\n            // Resets the entryOrder object and the sumFilled counter to null / 0 after the order has been filled\n            if (execution.Order.OrderState != OrderState.PartFilled && sumFilled == execution.Order.Filled)\n            {\n                entryOrder = null;\n                sumFilled = 0;\n            }\n        }\n    }\n\n    // Reset our stop order and target orders' Order objects after our position is closed. (1st Entry)\n    if ((stopOrder != null && stopOrder == execution.Order) || (targetOrder != null && targetOrder == execution.Order))\n    {\n        if (execution.Order.OrderState == OrderState.Filled || execution.Order.OrderState == OrderState.PartFilled)\n        {\n            stopOrder = null;\n            targetOrder = null;\n        }\n    }\n}\n```\n\n## Additional Reference Samples\n\nAdditional reference code samples are available in the NinjaScript Educational Resources section of our support forum."
  },
  {
    "_id": "15531df6faad272f6f42911ad532ead5a1f38c661583908404b2eee553a9a21d",
    "_type": "desktopSdkDoc",
    "title": "ExitLong()",
    "pathName": "exitlong",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a sell market order to exit a long position.\n\n## Method Return Value\n\nAn **Order** read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the [Advanced Order Handling](advanced_order_handling) section.\n\n## Syntax  \n\n**ExitLong()**\n\n**ExitLong(int quantity)**\n\n**ExitLong(string fromEntrySignal)**\n\n**ExitLong(string signalName, string fromEntrySignal)**\n\n**ExitLong(int quantity, string signalName, string fromEntrySignal)**\n\nThe following method variation is for experienced programmers who fully understand [Advanced Order Handling](advanced_order_handling) concepts:\n\n**ExitLong(int barsInProgressIndex, int quantity, string signalName, string fromEntrySignal)**\n\n## Parameters\n\n{% table %}\n\n* signalName\n* fromEntrySignal\n* quantity\n* barsInProgressIndex\n\n---\n\n* User defined signal name identifying the order generated. Max 50 characters.\n* The entry signal name. This ties the exit to the entry and exits the position quantity represented by the actual entry. Note: Using an empty string will attach the exit order to all entries.\n* Entry order quantity.\n* The index of the Bars object the order is to be submitted against. Used to determines what instrument the order is submitted for. See the [BarsInProgress](barsinprogress) property.\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     if (CurrentBar < 20)\n         return;\n\n     // Only enter if at least 10 bars has passed since our last entry\n     if ((BarsSinceEntryExecution() > 10 || BarsSinceEntryExecution() == -1) && CrossAbove(SMA(10), SMA(20), 1))\n         EnterLong(\"SMA Cross Entry\");\n\n     // Exits position\n     if (CrossBelow(SMA(10), SMA(20), 1))\n         ExitLong();\n}\n```\n\n## Tips (also see [Overview](managed_approach.md))\n\n* This method is ignored if a long position does not exist.\n* It is helpful to provide a signal name if your strategy has multiple exit points to help identify your exits on a chart.\n* You can tie an exit to an entry by providing the entry signal name in the parameter \"fromEntrySignal\".\n* If you do not specify a quantity the entire position is exited rendering your strategy flat.\n* If you do not specify a \"fromEntrySignal\" parameter the entire position is exited rendering your strategy flat."
  },
  {
    "_id": "0e09f03516d12701cccaf585eb2503e7d379097641ea871c90289b7de1fb77ec",
    "_type": "desktopSdkDoc",
    "title": "ExitShortMIT()",
    "pathName": "exitshortmit",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a buy to cover MIT order to exit a short position.\n\n## Method Return Value\n\nAn **Order** read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the [Advanced Order Handling](advanced_order_handling) section.\n\n## Syntax  \n\n**ExitShortMIT(double stopPrice)**\n\n**ExitShortMIT(int quantity, double stopPrice)**\n\n**ExitShortMIT(double stopPrice, string fromEntrySignal)**\n\n**ExitShortMIT(double stopPrice, string signalName, string fromEntrySignal)**\n\n**ExitShortMIT(int quantity, double stopPrice, string signalName, string fromEntrySignal)**\n\nThe following method variation is for experienced programmers who fully understand [Advanced Order Handling](advanced_order_handling) concepts:\n\n**ExitShortMIT(int barsInProgressIndex, bool isLiveUntilCancelled, int quantity, double stopPrice, string signalName, string fromEntrySignal)**\n\n## Parameters\n\n{% table %}\n\n* signalName\n* User defined signal name identifying the order generated. Max 50 characters.\n\n---\n\n* fromEntrySignal\n* The entry signal name. This ties the exit to the entry and exits the position quantity represented by the actual entry. Note: Using an empty string will attach the exit order to all entries.\n\n---\n\n* stopPrice\n* The stop price of the order.\n\n---\n\n* quantity\n* Entry order quantity.\n\n---\n\n* isLiveUntilCancelled\n* The order will NOT expire at the end of a bar but instead remain live until the **CancelOrder()** method is called or its time in force is reached.\n\n---\n\n* barsInProgressIndex\n* The index of the Bars object the order is to be submitted against. Used to determine what instrument the order is submitted for. See the **BarsInProgress** property.\n{% /table %}\n\n## Examples\n\n```csharp\nprivate double stopPrice = 0;\n\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 20)\n        return;\n\n    // Only enter if at least 10 bars has passed since our last entry\n    if ((BarsSinceEntryExecution() > 10 || BarsSinceEntryExecution() == -1) && CrossBelow(SMA(10), SMA(20), 1))\n    {\n        EnterShort(\"SMA Cross Entry\");\n        stopPrice = Low[0];\n    }\n\n    // Exits position\n    ExitShortMIT(stopPrice);\n}\n```\n\n## Tips (also see [Overview](managed_approach.md))\n\n* This method is ignored if a short position does not exist.\n* It is helpful to provide a signal name if your strategy has multiple exit points to help identify your exits on a chart.\n* You can tie an exit to an entry by providing the entry signal name in the parameter \"fromEntrySignal\".\n* If you do not specify a quantity the entire position is exited rendering your strategy flat.\n* If you do not specify a \"fromEntrySignal\" parameter the entire position is exited rendering your strategy flat."
  },
  {
    "_id": "26703207491dcaae46516dd695ca2270ec917193e2daf7d0bba620d1b8342124",
    "_type": "desktopSdkDoc",
    "title": "ExitShortStopLimit()",
    "pathName": "exitshortstoplimit",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a buy to cover stop limit order to exit a short position.\n\n## Method Return Value\n\nAn **Order** read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the [Advanced Order Handling](advanced_order_handling) section.\n\n## Syntax  \n\n**ExitShortStopLimit(double limitPrice, double stopPrice)**  \n**ExitShortStopLimit(int quantity, double limitPrice, double stopPrice)**  \n**ExitShortStopLimit(double limitPrice, double stopPrice, string fromEntrySignal)**  \n**ExitShortStopLimit(double limitPrice, double stopPrice, string signalName, string fromEntrySignal)**  \n**ExitShortStopLimit(int quantity, double limitPrice, double stopPrice, string signalName, string fromEntrySignal)**  \n\nThe following method variation is for experienced programmers who fully understand [Advanced Order Handling](advanced_order_handling) concepts:\n\n**ExitShortStopLimit**(int barsInProgressIndex, bool isLiveUntilCancelled, int quantity, double limitPrice, double stopPrice, string signalName, string fromEntrySignal)\n\n## Parameters\n\n{% table %}\n\n* signalName\n* fromEntrySignal\n* limitPrice\n* stopPrice\n* quantity\n* isLiveUntilCancelled\n* barsInProgressIndex\n\n---\n\n* User defined signal name identifying the order generated. Max 50 characters.\n* The entry signal name. This ties the exit to the entry and exits the position quantity represented by the actual entry. Note: Using an empty string will attach the exit order to all entries.\n* The limit price of the order\n* The stop price of the order.\n* Entry order quantity.\n* The order will NOT expire at the end of a bar but instead remain live until the **CancelOrder()** method is called or its time in force is reached.\n* The index of the Bars object the order is to be submitted against. Used to determines what instrument the order is submitted for. See the [BarsInProgress](barsinprogress) property.\n{% /table %}\n\n## Examples\n\n```csharp\nprivate double stopPrice = 0;\n\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 20)\n        return;\n\n    // Only enter if at least 10 bars has passed since our last entry\n    if ((BarsSinceEntryExecution() > 10 || BarsSinceEntryExecution() == -1) && CrossBelow(SMA(10), SMA(20), 1))\n    {\n        EnterShort(\"SMA Cross Entry\");\n        stopPrice = Low[0] + 5 * TickSize;\n    }\n\n    // Exits position\n    ExitShortStopLimit(stopPrice + (10 * TickSize), stopPrice);\n}\n```\n\n## Tips (also see [Overview](managed_approach.md))\n\n* This method is ignored if a short position does not exist.\n* It is helpful to provide a signal name if your strategy has multiple exit points to help identify your exits on a chart.\n* You can tie an exit to an entry by providing the entry signal name in the parameter \"fromEntrySignal\".\n* If you do not specify a quantity the entire position is exited rendering your strategy flat.\n* If you do not specify a \"fromEntrySignal\" parameter the entire position is exited rendering your strategy flat."
  },
  {
    "_id": "dd4d0b10f71ae127e40e4b669b6622d439d3dd3916057d338de13951eabd6eaf",
    "_type": "desktopSdkDoc",
    "title": "SetParabolicStop()",
    "pathName": "setparabolicstop",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a parabolic type trail stop order with the signal name **Parabolic stop** to exit a position. Parabolic stops are amended on a bar update basis, so dependent upon the [Calculate](calculate) setting of the parent strategy. Parabolic stop orders are real working orders (unless simulated is specified in which case the stop order is locally simulated and submitted as market once triggered) submitted immediately to the market upon receiving an execution from an entry order.\n\nAlthough logic wise very similar, this technique works different from the [ParablicSAR](parabolic_sar) indicator. The indicator will provide trailing stop levels 'always in the market' assuming a constant market position switch, either long or short (reversing). The **SetParabolicStop()** method in contrast will apply the same parabolic trailing technique sensitive to price acceleration to the custom strategy entry signal / position it is associated with.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* The **SetParabolicStop()** method can NOT be used concurrently with the [SetStopLoss()](setstoploss) or [SetTrailStop()](settrailstop) method for the same position, if any of methods are called for the same position (fromEntrySignal) the [SetStopLoss()](setstoploss) will always take precedence. You can however, use all three methods in the same strategy if they reference different signal names.\n* Parabolic stop orders are submitted in real-time on incoming executions from entry orders.\n* Since they are submitted upon receiving an execution, the **Set** method should be called prior to submitting the associated entry order to ensure an initial level is set.\n* A strategy will either generate a trail stop order for each partial fill of an entry order or one order for all fills. See additional information under the [Strategies](options_strategies) tab of the Options dialog window.\n* If a [profit target](setprofittarget) order is generated in addition to a trail stop order, they are submitted as OCO (one cancels other).\n* Parabolic stop orders are submitted as stop-market orders.\n* A parabolic stop order is automatically canceled if the managing position is closed by another strategy generated exit order.\n* Should you have multiple Bars objects of the same instrument while using **SetParabolicStop()** in your strategy, you should only submit orders for this instrument to the first Bars context of that instrument. This is to ensure your order logic is processed correctly and any necessary order amendments are done properly.\n* Parabolic stop orders are modified based on the strategies 'Calculate' settings. In the case of 'Calculate' on bar close, when the bar closes the parabolic stop order modification will occur using the closing price of the bar as the reference price to apply the trail offset. Subsequently if the open price of the next bar is significantly higher or lower than the current close price then there is a possibility that the calculated parabolic stop price is now an invalid stop price. This is a risk with modifying any stop order closer to the current market price since any modification above/below the current price would be rejected.\n{% /callout %}\n\n## Syntax\n\n**SetParabolicStop**(CalculationMode mode, double value)\n\n**SetParabolicStop**(string fromEntrySignal, CalculationMode mode, double value, bool isSimulatedStop, double acceleration, double accelerationMax, double accelerationStep)\n\n{% callout type=\"warning\" %}\n\nWarnings:\n\n* This method CANNOT be called from the [OnStateChange()](onstatechange) method during State.SetDefaults.\n* CalculationMode.Price is irrelevant for trail stops. Attempting to use this mode will log a message and the stop order be ignored. Please use [SetStopLoss()](setstoploss) for this mode instead.\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **mode**\n* Determines the manner in which the value parameter is calculated. Possible values are:\n  * **CalculationMode.Currency**: Initial PnL away from average entry. Calculated by the dollar per tick value for the order quantity used. When this mode is used, [StopTargetHandling](stoptargethandling) will automatically be set to ByStrategyPosition. The Stop loss will then continue to update following each parabolic step.\n  * **CalculationMode.Percent**: Percentage away from the average entry, based on the average entry price.\n  * **CalculationMode.Pips**: Pips away from average entry.\n  * **CalculationMode.Ticks**: Ticks away from entry average entry.\n  * Please note in percentage calculation mode a value of 1 is equal to 100%, a value of 0.1 is equal to 10%, and a value of 0.01 will be 1%.\n\n---\n\n* **isSimulatedStop**\n* If true, will simulate the stop order and submit as market once triggered.\n\n---\n\n* **value**\n* The value the trail stop order is offset from the position entry price.\n\n---\n\n* **fromEntrySignal**\n* The entry signal name. This ties the trail stop exit to the entry and exits the position quantity represented by the actual entry. Using an empty string will attach the exit order to all entries.\n\n---\n\n* **acceleration**\n* Sets the acceleration value.\n\n---\n\n* **accelerationMax**\n* Sets the maximum acceleration value.\n\n---\n\n* **accelerationStep**\n* Sets the step value used to increment acceleration value.\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips (also see [Overview](managed_approach.md)):\n\n* It is suggested to call this method from within the strategy [OnStateChange()](onstatechange) method if your stop loss price/offset is static.\n* You may call this method from within the strategy [OnBarUpdate()](onbarupdate) method should you wish to dynamically change the stop loss price while in an open position.\n* Should you call this method to dynamically change the stop loss price in the strategy [OnBarUpdate()](onbarupdate) method, you should always reset the stop loss price / offset value when your strategy is flat otherwise, the last price/offset value set will be used to generate your stop loss order on your next open position.\n* The signal name generated internally by this method is **Parabolic stop** which can be used with various methods such as [BarsSinceExitExecution()](barssinceexitexecution), or other order concepts which rely on identifying a signal name.\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Sets a parabolic stop using default acceleration (0.02), accelerationMax (0.2), accelerationStep (0.02) settings and a floor value of 12 ticks\n         **SetParabolicStop**(CalculationMode.Ticks, 12);\n\n         // Sets a parabolic stop of with a currency floor of 500 \n         **SetParabolicStop**(\"MyLongEntry\", CalculationMode.Currency, 500, false, 0.03, 0.3, 0.01);\n     }\n}\n```"
  },
  {
    "_id": "85681d2cc4f92a7660f5a2fecbc54aad5d220757849ee9162db3e6fe5492ba92",
    "_type": "desktopSdkDoc",
    "title": "SetProfitTarget()",
    "pathName": "setprofittarget",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a profit target order with the signal name **Profit target** to exit a position. Profit target orders are real working orders submitted immediately to the market upon receiving an execution from an entry order.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* Profit target orders are submitted in real-time on incoming executions from entry orders.\n* Since they are submitted upon receiving an execution, the Set method should be called prior to submitting the associated entry order to ensure an initial level is set.\n* A strategy will either generate a target order for each partial fill of an entry order or one order for all fills. See additional information under the [Strategies](options_strategies) tab of the Options dialog window.\n* If a **stop loss** or **trail stop** order is generated in addition to a profit target order, they are submitted as OCO (one cancels other).\n* A profit target order is automatically cancelled if the managing position is closed by another strategy generated exit order.\n* Should you have multiple Bars objects of the same instrument while using **SetProfitTarget()** in your strategy, you should only submit orders for this instrument to the first Bars context of that instrument. This is to ensure your order logic is processed correctly and any necessary order amendments are done properly.\n{% /callout %}\n\n## Syntax\n\n**SetProfitTarget(CalculationMode mode, double value)**\n\n**SetProfitTarget(CalculationMode mode, double value, bool isMIT)**\n\n**SetProfitTarget(string fromEntrySignal, CalculationMode mode, double value)**\n\n**SetProfitTarget(string fromEntrySignal, CalculationMode mode, double value, bool isMIT)**\n\n{% callout type=\"warning\" %}\n\nWarning: This method CANNOT be called from the **OnStateChange()** method during State.SetDefaults.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **currency**\n* Sets the profit target amount in currency ($500 profit for example)\n\n---\n\n* **isMIT**\n* Sets the profit target as a market-if-touched order\n\n---\n\n* **mode**\n* Determines the manner in which the value parameter is calculated. Possible values are:\n  * **CalculationMode.Currency**: PnL away from average entry. Calculated by the dollar per tick value for the order quantity used. When this mode is used, **StopTargetHandling** will automatically be set to ByStrategyPosition.\n  * **CalculationMode.Percent**: Percentage away from the average entry, based on the average entry price.\n  * **CalculationMode.Pips**: Pips away from average entry.\n  * **CalculationMode.Price**: The absolute price point specified.\n  * **CalculationMode.Ticks**: Ticks away from entry average entry.\n\n---\n\n* **value**\n* The value the profit target order is offset from the position entry price (exception is using .Price mode where 'value' will represent the actual price).\n\n---\n\n* **fromEntrySignal**\n* The entry signal name. This ties the profit target exit to the entry and exits the position quantity represented by the actual entry. Using an empty string will attach the exit order to all entries.\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips (also see [Overview](managed_approach.md)):\n\n* It is suggested to call this method from within the strategy **OnStateChange()** method if your profit target price/offset is static.\n* You may call this method from within the strategy **OnBarUpdate()** method should you wish to dynamically change the target price while in an open position.\n* Should you call this method to dynamically change the target price in the strategy **OnBarUpdate()** method, you should always reset the target price / offset value when your strategy is flat otherwise, the last price/offset value set will be used to generate your profit target order on your next open position.\n* The signal name generated internally by this method is **Profit target** which can be used with various methods such as **BarsSinceExitExecution()**, or other order concepts which rely on identifying a signal name.\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        // Submits a profit target order 10 ticks away from the avg entry price\n        SetProfitTarget(CalculationMode.Ticks, 10);\n    }\n}\n```"
  },
  {
    "_id": "0c04d099e1a85e0b357c11209e8999cfacb347883e6aa34c5625c7777f62ab86",
    "_type": "desktopSdkDoc",
    "title": "SetStopLoss()",
    "pathName": "setstoploss",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a stop loss order with the signal name **Stop loss** used to exit a position. Stop loss orders are real working orders (unless simulated is specified in which case the stop order is locally simulated and submitted as market once triggered) submitted immediately to the market upon receiving an execution from an entry order.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* Stop loss orders are submitted in real-time on incoming executions from entry orders.\n* Since they are submitted upon receiving an execution, the Set method should be called prior to submitting the associated entry order to ensure an initial level is set.\n* A strategy will either generate a stop loss order for each partial fill of an entry order or one order for all fills. See additional information under the [Strategies](options_strategies) tab of the Options dialog window.\n* If a [profit target](setprofittarget) order is generated in addition to a stop loss order, they are submitted as OCO (one cancels other).\n* Stop loss orders are submitted as stop-market orders.\n* A stop loss order is automatically canceled if the managing position is closed by another strategy generated exit order.\n* Should you have multiple Bars objects of the same instrument while using **SetStopLoss()** in your strategy, you should only submit orders for this instrument to the first Bars context of that instrument. This is to ensure your order logic is processed correctly and any necessary order amendments are done properly.\n* The **SetStopLoss()** method can NOT be used concurrently with the [SetTrailStop()](settrailstop) or [SetParabolicStop()](setparabolicstop) method for the same position; if any methods are called for the same position (fromEntrySignal), the **SetStopLoss()** will always take precedence. You can however, use all three methods in the same strategy if they reference different signal names.\n{% /callout %}\n\n## Syntax\n\n**SetStopLoss(CalculationMode mode, double value)**\n\n**SetStopLoss(string fromEntrySignal, CalculationMode mode, double value, bool isSimulatedStop)**\n\n{% callout type=\"warning\" %}\n\nWarning: This method CANNOT be called from the [OnStateChange()](onstatechange) method during State.SetDefaults.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **mode**\n* Determines the manner in which the value parameter is calculated. Possible values are:\n  * **CalculationMode.Currency**: PnL away from average entry. Calculated by the dollar per tick value for the order quantity used. When this mode is used, [StopTargetHandling](stoptargethandling) will automatically be set to ByStrategyPosition.\n  * **CalculationMode.Percent**: Percentage away from the average entry, based on the average entry price.\n  * **CalculationMode.Pips**: Pips away from average entry.\n  * **CalculationMode.Price**: The absolute price point specified.\n  * **CalculationMode.Ticks**: Ticks away from entry average entry. Please note in percentage calculation mode a value of 1 is equal to 100%, a value of 0.1 is equal to 10%, and a value of 0.01 will be 1%.\n\n---\n\n* **isSimulatedStop**\n* If true, will simulate the stop order and submit as market once triggered.\n\n---\n\n* **value**\n* The value the stop loss order is offset from the position entry price (exception is using .Price mode where 'value' will represent the actual price).\n\n---\n\n* **fromEntrySignal**\n* The entry signal name. This ties the stop loss exit to the entry and exits the position quantity represented by the actual entry. Using an empty string will attach the exit order to all entries.\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips (also see [Overview](managed_approach.md)):\n\n* It is suggested to call this method from within the strategy [OnStateChange()](onstatechange) method if your stop loss price/offset is static.\n* You may call this method from within the strategy [OnBarUpdate()](onbarupdate) method should you wish to dynamically change the stop loss price while in an open position.\n* Should you call this method to dynamically change the stop loss price in the strategy [OnBarUpdate()](onbarupdate) method, you should always reset the stop loss price / offset value when your strategy is flat; otherwise, the last price/offset value set will be used to generate your stop loss order on your next open position.\n* The signal name generated internally by this method is **Stop loss** which can be used with various methods such as [BarsSinceExitExecution()](barssinceexitexecution), or other order concepts which rely on identifying a signal name.\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        // Submits a stop loss of $500\n        SetStopLoss(CalculationMode.Currency, 500);\n    }\n}\n```"
  },
  {
    "_id": "ef764a1e1ef44636983d73ac82037da94905a474cf1dc8cf6a0d494112a83bb3",
    "_type": "desktopSdkDoc",
    "title": "SetTrailStop()",
    "pathName": "settrailstop",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a trail stop order with the signal name **Trail stop** to exit a position. Trail stops are amended on a bar update basis, so dependent upon the [Calculate](calculate) setting of the parent strategy. Trail stop orders are real working orders (unless simulated is specified in which case the stop order is locally simulated and submitted as market once triggered) submitted immediately to the market upon receiving an execution from an entry order.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* The **SetTrailStop()** method can NOT be used concurrently with the [SetStopLoss()](setstoploss) or [SetParabolicStop()](setparabolicstop) method for the same position. If any of these methods are called for the same position (**fromEntrySignal**), the [SetStopLoss()](setstoploss) will always take precedence. You can, however, use all three methods in the same strategy if they reference different signal names.\n* Trail stop orders are submitted in real-time on incoming executions from entry orders.\n* Since they are submitted upon receiving an execution, the **Set** method should be called prior to submitting the associated entry order to ensure an initial level is set.\n* A strategy will either generate a trail stop order for each partial fill of an entry order or one order for all fills. See additional information under the [Strategies](options_strategies) tab of the Options dialog window.\n* If a [profit target](setprofittarget) order is generated in addition to a trail stop order, they are submitted as OCO (one cancels other).\n* Trail stop orders are submitted as stop-market orders.\n* A trail stop order is automatically canceled if the managing position is closed by another strategy-generated exit order.\n* Should you have multiple **Bars** objects of the same instrument while using **SetTrailStop()** in your strategy, you should only submit orders for this instrument to the first **Bars** context of that instrument. This is to ensure your order logic is processed correctly and any necessary order amendments are done properly.\n* Trail stop orders are modified based on the strategy's **Calculate** settings. In the case of **Calculate** on bar close, when the bar closes the trail stop order modification will occur using the lowest/highest price of the bar as the reference price to apply the trail offset. Subsequently, if the open price of the next bar is significantly higher or lower than this price, then there is a possibility that the calculated trail stop price is now an invalid stop price. This is a risk with modifying any stop order closer to the current market price since any modification above/below the current price would be rejected.\n{% /callout %}\n\n## Syntax\n\n**SetTrailStop(CalculationMode mode, double value)**\n\n**SetTrailStop(string fromEntrySignal, CalculationMode mode, double value, bool isSimulatedStop)**\n\n{% callout type=\"warning\" %}\n\nWarnings:\n\n* This method CANNOT be called from the [OnStateChange()](onstatechange) method during **State.SetDefaults**.\n* **CalculationMode.Price** and **CalculationMode.Currency** are irrelevant for trail stops. Attempting to use one of these modes will log a message and the stop order will be ignored. Please use [SetStopLoss()](setstoploss) for these modes instead.\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **mode**\n* Determines the manner in which the value parameter is calculated. Possible values are:\n  * **CalculationMode.Percent**: Percentage away from the average entry, based on the average entry price.\n  * **CalculationMode.Pips**: Pips away from average entry.\n  * **CalculationMode.Ticks**: Ticks away from entry average entry.\n  * Please note in percentage calculation mode a value of 1 is equal to 100%, a value of 0.1 is equal to 10%, and a value of 0.01 will be 1%.\n\n---\n\n* **isSimulatedStop**\n* If true, will simulate the stop order and submit as market once triggered.\n\n---\n\n* **value**\n* The value the trail stop order is offset from the position entry price (exception is using **.Price** mode where 'value' will represent the actual price).\n\n---\n\n* **fromEntrySignal**\n* The entry signal name. This ties the trail stop exit to the entry and exits the position quantity represented by the actual entry. Using an empty string will attach the exit order to all entries.\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        // Sets a trail stop of 12 ticks\n        SetTrailStop(CalculationMode.Ticks, 12);\n    }\n}\n```\n\n{% callout type=\"note\" %}\n\nTips (also see [Overview](managed_approach.md)):\n\n* It is suggested to call this method from within the strategy [OnStateChange()](onstatechange) method if your trail stop price/offset is static.\n* You may call this method from within the strategy [OnBarUpdate()](onbarupdate) method should you wish to dynamically change the trail stop price while in an open position.\n* Should you call this method to dynamically change the trail stop price in the strategy [OnBarUpdate()](onbarupdate) method, you should always reset the trail stop price/offset value when your strategy is flat; otherwise, the last price/offset value set will be used to generate your trail stop order on your next open position.\n* The signal name generated internally by this method is **Trail stop**, which can be used with various methods such as [BarsSinceExitExecution()](barssinceexitexecution), or other order concepts which rely on identifying a signal name.\n{% /callout %}"
  },
  {
    "_id": "9a59c55341cb39d5d1b9ae786bbb00871ce61e200e192278f7a32187927e769d",
    "_type": "desktopSdkDoc",
    "title": "Managed Approach",
    "pathName": "order_methods",
    "parent": "managed_approach",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The Managed approach in **NinjaScript** is designed to offer the greatest ease of use for beginner to intermediate programmers. The order methods are wrapped in a convenience layer that allows you to focus on your system's trading rules, leaving the underlying mechanics of order management and the relationships between entry orders, exit orders, and positions to **NinjaTrader**. This approach is best suited for simple to moderate order complexity, and can be further broken down into a Basic/Common Managed approach and a more [Advanced](advanced_order_handling) Managed approach. The following section will discuss the use of the Basic/Common approach.\n\nA few key points to keep in mind:\n\n* Orders are submitted as live and working when a strategy is running in real-time\n* Profit target, stop loss and trail stop orders are submitted immediately when an entry order is filled, and are tied together via OCO (One Cancels Other)\n* Order changes and cancellations are queued in the event that the order is in a state where it can't be cancelled or modified\n* By default, orders submitted via **Entry()** and **Exit()** methods automatically cancel at the end of a bar if not re-submitted\n* **Entry()** methods will reverse the position automatically. For example if you are in a 1 contract long position and now call **EnterShort()** -> you will see 2 executions, one to close the prior long position and the other to get you into the desired 1 contract short position.\n\n* Via the [SetProfitTarget()](setprofittarget) , [SetStopLoss()](setstoploss) , [SetTrailStop()](settrailstop) and [SetParabolicStop](setparabolicstop) methods\n\n## Order submission for entry and exit methods - basic operation\n\n{% callout type=\"note\" %}\n\n* Orders are primarily submitted from within the **OnBarUpdate()** method when a specific order method is called. By default, orders are kept alive, provided they are re-submitted on each call of the **OnBarUpdate()** method. If an order is not re-submitted, it is then canceled. Orders can be modified by re-submitting them with changed parameters (a new limit price, for example).\nIn the example below, a Buy Limit order is working at the bid price, provided that the Close price of the current bar is greater than the current value of the 20 period Simple Moving Average. If the entry condition is no longer true and the order is still active, it will be immediately canceled.\n{% callout %}\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Entry condition\n     if (Close[0] > SMA[20](0))\n         EnterLongLimit(GetCurrentBid());\n}\n```\n\nThis technique allows you the quickest and easiest order submission method suitable for programmers of all levels. Should you want to submit an order and not have to keep re-submitting it to keep it alive you can use an [advanced approach](advanced_order_handling) reserved for experienced programmers, which includes an option to keep orders alive until specifically canceled in code.\n\n## Order Entry Methods\n\n{% callout type=\"note\" %}\n\n* Order Entry Methods\nOrder entry methods are used to submit orders of different types. Methods exist to submit Market, Market-if-Touched, Limit, Stop Market, and Stop Limit orders. See the order-entry method pages listed in the help guide table of contents under this page for more information on a specific method.\nSignal Names on Entry Methods\nYou can optionally tag an entry order with a signal name. Signal names are used to identify executions resulting from the order on a chart and in performance reports. Market positions created from a tagged entry method are marked with the signal name which serves two purposes:\n* Used to tie an exit method to a specific position\n* Used to identify unique entries in a strategy\nBelow is an example of placing a Market entry order and an associated Limit exit order, tied together by the signal name of the entry order.\n\n{ /callout }\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   if (CurrentBar < 1) return;\n\n   if (Close[0] > Close[1])\n   {\n       // Place a Market order to enter long\n       EnterLong(\"longEntry\");\n\n       // Manually place a Profit Target 10 ticks above the current price, tied to the entry order's SignalName\n       ExitLongLimit(Close[0] + (10 * TickSize), \"longEntry\");\n   }\n}\n```\n\nDefining how Entry Methods are Processed in a Strategy\n\nYou can limit how many entry methods are processed by determining the maximum number of entries in a single direction across all entry methods, or across unique signal names. The following properties can be set in the Strategies window when adding a strategy to a chart or to the Strategies tab of the Control Center window.\n\n* [EntriesPerDirection](entriesperdirection) property - Sets the maximum number of entries in a single direction\n* [EntryHandling](entryhandling) property - Determines if EntriesPerDirection applies across all entries or for entries with specified signal names\n\nThe example code below illustrates how the above properties control the processing of entry methods. The code contains two entry conditions and two **EnterLong** methods, each tagged with unique signal names.\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n       EntriesPerDirection = 1;\n       EntryHandling = EntryHandling.AllEntries;\n   }\n}\n\nprotected override void OnBarUpdate()\n{\n   // Entry condition 1\n   if (CrossAbove(SMA(10), SMA(20), 1))\n       EnterLong(\"Condition 1 Entry\");\n\n   // Entry condition 2\n   if (CrossAbove(RSI(14, 3), 30, 1))\n       EnterLong(\"Condition 2 Entry\");\n}\n\n```\n\nEntry Methods on Multi-Instrument Strategies\n\nWhen running strategies that submit orders to multiple instruments, entry methods will submit orders to the instrument referenced by the [BarsInProgress](barsinprogress). The following example assumes that the strategy is running on a 1 minute E-Mini S&P 500 chart. It adds an NQ data series, then enters a position on both instruments.\n\n```csharp\nprotected override void OnStateChange()\n{\n     AddDataSeries(\"NQ 09-14\", BarsPeriodType.Minute, 1);\n}\n\nprotected override void OnBarUpdate()\n{\n     if (BarsInProgress == 0)\n         EnterLong(\"ES Trade\");\n     else if (BarsInProgress == 1)\n         EnterLong(\"NQ Trade\");\n}\n```\n\nMore information on using BarsInProgress to filter instruments can be found in the [Advanced Order Handling](advanced_order_handling) page.\n\n## Quantity Type and TIF\n\n{% table %}\n\n* You can set the entry order quantity and order type directly in code via the following properties:\n* QuantityType - Sets the order quantity is taken from the entry method quantity property or the default strategy quantity size\n* [TimeInForce](timeinforce) property - Sets the time in force of the order\n{% /table %}\n\n## How to close a position\n\n{% table %}\n\n* Closing a Position using a Stop Loss, Trailing Stop and/or Profit Target\nYou can predefine a stop loss, trailing stop and/or profit target in a strategy by calling the [SetStopLoss()](setstoploss), [SetTrailStop()](settrailstop) and/or [SetProfitTarget()](setprofittarget) methods from inside the **OnStateChange()** event handler. When these methods are called, they submit live working orders in real-time as executions are reported as a result of calling an entry method. These orders are also tied via OCO (One Cancels Other).\nStop losses and profit target can be generated for each fill or each position. This is determined by the \"Stop & target submission\" property which is set in the Strategies window. Possible values are listed below:\n* ByStrategyPosition - When this is selected, only one stop loss, trail stop and/or profit target order is submitted. As entry executions come in, the order size is amended. The downside of this approach is that if you receive partial fills, the orders are re-inserted into the exchange order queue. The upside is that if you broker charges you commission per order (not per quantity), you will not incur additional commission expenses.\n* PerEntryExecution - When this is selected, a stop loss, trail stop and/or profit target order is submitted for each partial fill received. The downside is that if your broker charges commission per order, you can incur very expensive commission costs if you receive partial fills. The upside is that orders are submitted as soon as possible, giving you the advantage of getting into the order queue immediately.\nClosing a Position using an Exit Method\nExit methods submit orders to close out a position in whole or in part. When closing a position with Exit orders, the order quantity will be reduced as the strategy position reduces - for example, if we use [ExitLongStopMarket()](exitlongstopmarket) and [ExitLongStopLimit()](exitlongstoplimit) to protect a position and one of those orders gets filled, the other order associated with exiting that position will reduce their quantity.\nAs with entry methods, more information about specific exit methods can be found in this Help Guide's table of contents, beneath this page.\nClosing a Partial Position using an Exit Method\nYou can close out a partial position by specifying the exit quantity. The following example first enters long for three contracts. Then, each subsequent bar update submits a market order to exit one contract until the position is completely closed. \"ExitLong(1)\" will be ignored if a long market position does not exist.\n{% /table %}\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     if (CrossAbove(SMA(10), SMA(20), 1))\n         EnterLong(3);\n\n     ExitLong(1);\n}\n```\n\nFromEntrySignal -- Using Signal Names in Exit Methods\n\nIdentifying entries with a signal name allows you to place multiple unique entries within a single strategy and call exit methods with specified signal names, so that only a position created with the specified signal name is closed. In the example below, there are two entry conditions which create positions, and two exit conditions specifying which position to close based on the signal name.\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Entry condition 1\n     if (CrossAbove(SMA(10), SMA(20), 1))\n         EnterLong(\"Condition 1 Entry\");\n\n     // Entry condition 2\n     if (CrossAbove(RSI(14, 3), 30, 1))\n         EnterLong(\"Condition 2 Entry\");\n\n     // Closes the position created by entry condition 1\n     if (CrossBelow(SMA(10), SMA(20), 1))\n         ExitLong(\"Condition 1 Entry\");\n\n     // Closes the position created by entry condition 2\n     if (CrossBelow(RSI(14, 3), 70, 1))\n         ExitLong(\"Condition 2 Entry\");\n```\n\n{% callout type=\"note\" %}\n\nIf you do not specify a \"fromEntrySignal\" parameter the entire position is exited rendering your strategy flat.\n\n{% /callout %}\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   if (Position.MarketPosition == MarketPosition.Flat)\n   {\n       // Entry condition 1\n       if (CrossAbove(SMA(10), SMA(20), 1))\n           EnterLong(\"Condition 1 Entry\");\n   }\n\n   if (Position.MarketPosition != MarketPosition.Flat)\n   {\n       // Scale in condition 2 for position management\n       if (CrossAbove(RSI(14, 3), 30, 1))\n           EnterLong(\"Condition 2 Entry\");\n\n       // Exit all positions using an empty string (could also use string.Empty)\n       if (CrossBelow(SMA(10), SMA(20), 1))\n           ExitLong(\"Exit All\", \"\");\n   }\n}\n```\n\n## Understanding core order objects\n\n{% table %}\n\n* When using order methods such as [EnterLong()](enterlong), [ExitShortLimit()](exitshortlimit), etc, a direct [order object](order) is returned for the **NinjaTrader** Core. These objects can be used throughout the lifetime of your strategy to provide additional metadata concerning your strategy, as well as apply advanced concepts such as [CancelOrder()](managed_cancelorder) and [ChangeOrder()](managed_changeorder). More information about this advanced concept which is discussed under the [Advanced Order Handling](advanced_order_handling) section.\n{% /table %}\n\n## Internal Order Handling Rules that Reduce Unwanted Positions\n\n{% table %}\n\n* To prevent situations in real-time in which you may have multiple orders working to accomplish the same task, there are some \"under the hood\" rules that a **NinjaScript** strategy follows when Managed order methods are called. For example, if your strategy had a limit order for 1 contract working as a Profit Target, but then your strategy was also programmed to reverse the position at the price very close to the target limit order, then submitting both orders can be risky, since it could lead to a larger position than the strategy is designed to enter if both orders got filled in quick succession by the exchange.\n  * Note: These rules do not apply to market orders, such as **ExitLong()** or **ExitShort()**. For the most part, you do not need to be intimately familiar with these rules as you develop your strategies. It is all taken care of for you internally within a strategy. If a rule is violated, you will be notified through an error log in the Control Center Log tab.\n  * Note: To prevent excessive logging which could degrade performance, you will only be notified of the very first order which has violated an order handling rule. Subsequent orders which violate a rule will not be notified through the error log.\nThe following rules are true per unique signal name:\nMethods that generate orders to enter a position will be ignored if:\n* A position is open and an order submitted by a non market order exit method ([ExitLongLimit()](exitlonglimit) for example) is active and the order is used to open a position in the opposite direction\n* A position is open and an order submitted by a set method ([SetStopLoss()](setstoploss) for example) is active and the order is used to open a position in the opposite direction\n* A position is open and two or more Entry methods to reverse the position are entered together. In this case the second Entry order will be ignored.\n* The strategy position is flat and an order submitted by an enter method ([EnterLongLimit()](enterlonglimit) for example) is active and the order is used to open a position in the opposite direction\n* The entry signal name is not unique\nMethods that generate orders to exit a position will be ignored if:\n* A position is open and an order submitted by an enter method ([EnterLongLimit()](enterlonglimit) for example) is active and the order is used to open a position in the opposite direction\n* A position is open and an order submitted by a set method ([SetStopLoss()](setstoploss) for example) is active\nSet() methods that generate orders to exit a position will be ignored if:\n* A position is open and an order submitted by an enter method ([EnterLongLimit()](enterlonglimit) for example) is active and the order is used to open a position in the opposite direction\n* A position is open and an order submitted by a non market order exit method ([ExitLongLimit()](exitlonglimit) for example) is active\n{% /table %}"
  },
  {
    "_id": "3eeb7e96e59ce40f9cb1a089daba079fd699f6867a30f6634af8570967b2375a",
    "_type": "desktopSdkDoc",
    "title": "Order",
    "pathName": "order",
    "parent": "strategy",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents a read only interface that exposes information regarding an order.\n\n* An Order object returned from calling an order method is dynamic in that its properties will always reflect the current state of an order.\n* The property **<`order`>.OrderId** is NOT a unique value, since it can change throughout an order's lifetime. Please see the [Advance Order Handling](advanced_order_handling) section on \"Transitioning order references from historical to live\" for details on how to handle.\n* The property **<`order`>.Oco** WILL be appended with a suffix when the strategy transitions from historical to real-time to ensure the OCO id is unique across multiple strategies for live orders.\n* To check for equality you can compare Order objects directly.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* Account\n* The [Account](account_class) the order resides\n\n---\n\n* AverageFillPrice\n* A double value representing the average fill price of an order\n\n---\n\n* Filled\n* An int value representing the filled amount of an order\n\n---\n\n* FromEntrySignal\n* A string representing the user defined fromEntrySignal parameter on an order\n\n---\n\n* Gtd\n* A [DateTime](http://msdn2.microsoft.com/en-us/library/system.datetime.aspx) structure representing when the order will be canceled\n\n---\n\n* HasOverfill\n* A bool value representing if the order is an overfill. For use when using [Unmanaged orders](unmanaged_approach) and [IgnoreOverFill](ignoreoverfill)\n\n---\n\n* Instrument\n* An [Instrument](instrument) value representing the instrument of an order\n\n---\n\n* IsBacktestOrder\n* A bool that indicates if the order was generated while processing historical data. For use with [GetRealtimeOrder()](getrealtimeorder) when transitioning historical order objects to live order objects when strategies transition to from State.Historical to State.Realtime.\n\n---\n\n* IsLiveUntilCancelled\n* A bool that when true, indicates the order will be canceled by [managed order handling](managed_approach.md) at expiration\n\n---\n\n* IsTerminalState()\n* A static method used to determine if the an order's OrderState is in considered terminal and no longer active\n\n---\n\n* LimitPrice\n* A double value representing the limit price of an order\n\n---\n\n* LimitPriceChanged\n* A double value representing the new limit price of an order. Used with [Account.Change()](change)\n\n---\n\n* Name\n* A string representing the name of an order which can be provided by the entry or exit signal name\n\n---\n\n* Oco\n* A string representing the OCO (one cancels other) id of an order\n\n---\n\n* OrderAction\n* Represents the action of the order. Possible values are:\n  * OrderAction.Buy\n  * OrderAction.BuyToCover\n  * OrderAction.Sell\n  * OrderAction.SellShort\n\n---\n\n* OrderId\n* A string representing the broker issued order id value (this value can change)\n\n---\n\n* OrderState\n* The current state of the order. See the order state values table below\n\n---\n\n* OrderType\n* The type of order submitted. Possible values are:\n  * OrderType.Limit\n  * OrderType.Market\n  * OrderType.MIT\n  * OrderType.StopMarket\n  * OrderType.StopLimit\n\n---\n\n* Quantity\n* An int value representing the quantity of an order\n\n---\n\n* QuantityChanged\n* An int value representing the new quantity of an order. Used with [Account.Change()](change)\n\n---\n\n* StopPrice\n* A double value representing the stop price of an order\n\n---\n\n* StopPriceChanged\n* A double value representing the new stop price of an order. Used with [Account.Change()](change)\n\n---\n\n* Time\n* A [DateTime](http://msdn2.microsoft.com/en-us/library/system.datetime.aspx) structure representing the last time the order changed state\n\n---\n\n* TimeInForce\n* Determines the life of the order. Possible values are:\n  * TimeInForce.Day\n  * TimeInForce.Gtc\n\n---\n\n* ToString()\n* A string representation of an order\n\n---\n\n{% /table %}\n\n## OrderState Values\n\n{% table %}\n\n* Order State\n* Description\n\n---\n\n* OrderState.Initialized\n* Order is initialized in NinjaTrader\n\n---\n\n* OrderState.Submitted\n* Order is submitted to the broker\n\n---\n\n* OrderState.Accepted\n* Order is accepted by the broker or exchange\n\n---\n\n* OrderState.TriggerPending\n* Order is pending submission\n\n---\n\n* OrderState.Working\n* Order is working in the exchange queue\n\n---\n\n* OrderState.ChangePending\n* Order change is pending in NinjaTrader\n\n---\n\n* OrderState.ChangeSubmitted\n* Order change is submitted to the broker\n\n---\n\n* OrderState.CancelPending\n* Order cancellation is pending in NinjaTrader\n\n---\n\n* OrderState.CancelSubmitted\n* Order cancellation is submitted to the broker\n\n---\n\n* OrderState.Cancelled\n* Order cancellation is confirmed by the exchange\n\n---\n\n* OrderState.Rejected\n* Order is rejected\n\n---\n\n* OrderState.PartFilled\n* Order is partially filled\n\n---\n\n* OrderState.Filled\n* Order is completely filled\n\n---\n\n* OrderState.Unknown\n* An unknown order state. Default if broker does not report current order state.\n\n---\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nCritical: In a historical backtest, orders will always reach a \"Working\" state. In real-time, some stop orders may only reach \"Accepted\" state if they are simulated/held on a brokers server.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprivate Order entryOrder = null;\n  \nprotected override void OnBarUpdate()\n{\n   if (entryOrder == null && Close[0] > Open[0])\n       EnterLong(\"myEntryOrder\");\n}\n  \nprotected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string nativeError)\n{\n   // Assign entryOrder in OnOrderUpdate() to ensure the assignment occurs when expected.\n   // This is more reliable than assigning Order objects in OnBarUpdate, as the assignment is not guaranteed to be complete if it is referenced immediately after submitting\n   if (order.Name == \"myEntryOrder\")\n      entryOrder = order;\n  \n   if (entryOrder != null && entryOrder == order)\n   {\n       Print(order.ToString());\n       if (order.OrderState == OrderState.Filled)\n           entryOrder = null;\n   }\n}\n```"
  },
  {
    "_id": "9a59c55341cb39d5d1b9ae786bbb00871ce61e200e192278f7a32187927e769d",
    "_type": "desktopSdkDoc",
    "title": "Order Methods",
    "pathName": "order_methods",
    "parent": "strategy",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Order Methods Overview\n\nNinjaScript provides several approaches you can use for order placement within your NinjaScript strategy. The main approaches can be categorized as a Managed approach and an Unmanaged approach.\n\n{% callout type=\"note\" %}\n\nYou will not be able to mix and match the two approaches. If you decide to go with the Managed approach you will only be able to use the Managed order methods. If you decide to go with the Unmanaged approach you will only be able to use the Unmanaged order methods.\n\n{% /callout %}\n\n{% table %}\n\n* Managed\n* Unmanaged\n\n---\n\n* The Managed approach offers you order methods that are wrapped with an invisible convenience layer that allows you to focus on your system's trading rules leaving the underlying mechanics of order management and the relationships between entry and exit orders and positions to NinjaTrader. The cost for having the convenience layer is that there are **[order handling rules](managed_approach.md)** that must be followed to prevent order errors.  \n  * **[Understanding the Managed approach](managed_approach.md)**  \n  * **[Advanced Order Handling](advanced_order_handling)**  \n  * **[CancelOrder()](managed_cancelorder)**  \n  * **[EnterLong()](enterlong)**  \n  * **[EnterLongLimit()](enterlonglimit)**  \n  * **[EnterLongMIT()](enterlongmit)**  \n  * **[EnterLongStopMarket()](enterlongstopmarket)**  \n  * **[EnterLongStopLimit()](enterlongstoplimit)**  \n  * **[EnterShort()](entershort)**  \n  * **[EnterShortLimit()](entershortlimit)**  \n  * **[EnterShortMIT()](entershortmit)**  \n  * **[EnterShortStopMarket()](entershortstopmarket)**  \n  * **[EnterShortStopLimit()](entershortstoplimit)**  \n  * **[ExitLong()](exitlong)**  \n  * **[ExitLongLimit()](exitlonglimit)**  \n  * **[ExitLongMIT()](exitlongmit)**  \n  * **[ExitLongStopMarket()](exitlongstopmarket)**  \n  * **[ExitLongStopLimit()](exitlongstoplimit)**  \n  * **[ExitShort()](exitshort)**  \n  * **[ExitShortLimit()](exitshortlimit)**  \n  * **[ExitShortMIT()](exitshortmit)**  \n  * **[ExitShortStopMarket()](exitshortstopmarket)**  \n  * **[ExitShortStopLimit()](exitshortstoplimit)**  \n  * **[GetRealtimeOrder()](getrealtimeorder)**  \n  * **[SetProfitTarget()](setprofittarget)**  \n  * **[SetStopLoss()](setstoploss)**  \n  * **[SetTrailStop()](settrailstop)**  \n  * **[SetParabolicStop()](setparabolicstop)**\n\n---\n\n* The Unmanaged approach offers you more flexible order methods without the convenience layer. This means you are not restricted to any order handling rules besides those imposed by the brokerage/exchange. With such flexibility though, you will have to ensure to program your strategy to handle any and all issues that may arise with placing orders.  \n  * **[Understanding the Unmanaged approach](unmanaged_approach)**  \n  * **[CancelOrder()](unmanaged_cancelorder.md)**  \n  * **[ChangeOrder()](managed_changeorder)**  \n  * **[GetRealtimeOrder()](getrealtimeorder)**  \n  * **[IgnoreOverfill](ignoreoverfill)**  \n  * **[IsUnmanaged](isunmanaged)**  \n  * **[SubmitOrderUnmanaged()](submitorderunmanaged)**\n{% /table %}"
  },
  {
    "_id": "da8b3a0269d0b4b977d6cad62bbf259cd80ec0d1c07207c1872c0fcf84c4eabc",
    "_type": "desktopSdkDoc",
    "title": "AddDataSeries()",
    "pathName": "adddataseries",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAdds a Bars object for developing a multi-series (multi-time frame or multi-instrument) NinjaScript.\n\n## Related Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [AddHeikenAshi()](addheikenashi)\n* This method adds a Heiken Ashi Bars object for multi-series NinjaScript.\n* [AddKagi()](addkagi)\n* This method adds a Kagi Bars object for multi-series NinjaScript.\n* [AddLineBreak()](addlinebreak)\n* This method adds a Line Break Bars object for multi-series NinjaScript.\n* [AddPointAndFigure()](addpointandfigure)\n* This method adds a Point-and-Figure Bars object for multi-series NinjaScript.\n* [AddRenko()](addrenko)\n* This method adds a Renko Bars object for multi-series NinjaScript.\n* [AddVolumetric()](addvolumetric)\n* This method adds a Order Flow Volumetric Bars object for multi-series NinjaScript.\n* [BarsArray](barsarray)\n* An array holding Bars objects that are added via the AddDataSeries() method.\n* [BarsInProgress](barsinprogress)\n* An index value of the current Bars object that has called the OnBarUpdate() method.\n* [BarsPeriods](barsperiods)\n* Holds an array of BarsPeriod objects synchronized to the number of unique Bars objects held within the parent NinjaScript object.\n* [CurrentBars](currentbars)\n* Holds an array of int values representing the number of the current bar in a Bars object.\n{% /table %}\n\n## Syntax\n\nThe following syntax will add another Bars object for the primary instrument of the script.\n\n```csharp\nAddDataSeries(BarsPeriod barsPeriod)\nAddDataSeries(BarsPeriodType periodType, int period)\n```\n\nThe following syntax allows you to add another Bars object for a different instrument to the script:\n\n```csharp\nAddDataSeries(string instrumentName, BarsPeriodType periodType, int period)\nAddDataSeries(string instrumentName, BarsPeriodType periodType, int period, MarketDataType marketDataType)\nAddDataSeries(string instrumentName, BarsPeriod barsPeriod)\nAddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName)\nAddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName, bool? isResetOnNewTradingDay)\nAddDataSeries(string instrumentName, BarsPeriod barsPeriod, int barsToLoad, string tradingHoursName, bool? isResetOnNewTradingDay)\nAddDataSeries(string instrumentName) //only for R15 and higher\n```\n\n{% callout type=\"warning\" %}\n\n* This method should ONLY be called from the OnStateChange() method during State.Configure.\n* Should your script be the host for other scripts that are creating indicators and series dependent resources in State.DataLoaded, please make sure that the host is doing the same AddDataSeries() calls as those hosted scripts would. For further reference, please also review the 2nd example below and the 'Adding additional Bars Objects to NinjaScript' section in Multi-Time Frame & Instruments.\n* Arguments supplied to AddDataSeries() should be hardcoded and NOT dependent on run-time variables which cannot be reliably obtained during State.Configure (e.g., Instrument, Bars, or user input). Attempting to add a data series dynamically is NOT guaranteed and therefore should be avoided. Trying to load bars dynamically may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.\n* When adding multiple Data Series of the same instrument and the same Bar Type, the 'barsToLoad' property will only be effective on the first added series. Subsequent series with a different barsToLoad setting will not load a different number of bars than the first series.\n* The AddDataSeries(string instrumentName) overload allows loading a different instrument yet using the same BarsPeriod. This could not be supported for Strategy Analyzer use with the 'Optimize Data Series' option enabled, doing so may result in an error similar to: Unable to load bars series. Your NinjaScript may be trying to use an additional data series dynamically in an unsupported manner.\n* If your NinjaScript object is using AddDataSeries() allowing to specify a tradingHoursName, please keep in mind that: An indicator / strategy with multiple DataSeries of the same instrument will only process realtime OnBarUpdate() calls when a tick occurs in session of the trading hour template of all added series. Any ticks not processed will be queued and processed as a tick comes in for all subsequent DataSeries.\n* When instantiating indicators in a Multi-Series script in OnStateChange, the input any hosted indicator is running on should be explicitly stated.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* instrumentName\n\n* A string determining instrument name such as \"MSFT\"\n\n---\n\n* barsPeriod\n\n* The BarsPeriod object (period type and interval)\n\n---\n\n* periodType\n\n* The BarsType used for the bars period. Possible values are: BarsPeriodType.Tick, BarsPeriodType.Volume, BarsPeriodType.Range, BarsPeriodType.Second, BarsPeriodType.Minute, BarsPeriodType.Day, BarsPeriodType.Week, BarsPeriodType.Month, BarsPeriodType.Year\n\n---\n\n* period\n\n* An int determining the period interval such as \"3\" for 3 minute bars\n\n---\n\n* marketDataType\n\n* The MarketDataType used for the bars object (last, bid, ask). Possible values are: MarketDataType.Ask, MarketDataType.Bid, MarketDataType.Last. Note: Please see the article [here](using_historical_bid_ask_serie) on using Bid/Ask series.\n\n---\n\n* tradingHoursName\n\n* A string determining the trading hours template for the instrument\n\n---\n\n* isResetOnNewTradingDay\n\n* A nullable bool determining if the Bars object should Break at EOD. Will accept true, false or null as the input. If null is used, the data series will use the settings of the primary data series.\n\n---\n\n* barsToLoad\n\n* An int determining the number of historical bars to load\n\n---\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\n1. You can optionally add the exchange name as a suffix to the symbol name. This is only advised if the instrument has multiple possible exchanges that it can trade on and it is configured within the Instruments window. For example: AddDataSeries(\"MSFT Arca\", BarsPeriodType.Minute, 5);\n2. You can add a custom BarsType which is installed on your system by casting the registered enum value for that BarsPeriodType. For example: AddDataSeries((BarsPeriodType)14, 10);\n3. You can specify optional BarsPeriod values (such as Value2) of a custom BarsType in the BarsPeriod object initializer. For example: AddDataSeries(new BarsPeriod() { BarsPeriodType = (BarsPeriodType)14, Value = 10, Value2 = 20 });\n4. For the instrument name parameter null could be passed in, resulting in the primary data series instrument being used.\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        // Add a 5 minute Bars object - BarsInProgress index = 1 \n        AddDataSeries(BarsPeriodType.Minute, 5);\n\n        // Add a 100 tick Bars object for the ES 09-16 contract - BarsInProgress index = 2 \n        AddDataSeries(\"ES 09-16\", BarsPeriodType.Tick, 100); \n    }\n} \n\nprotected override void OnBarUpdate() \n{ \n    // Ignore bar update events for the supplementary - Bars object added above \n    if (BarsInProgress == 1 || BarsInProgress == 2)\n        return; \n\n    // Go long if we have three up bars on all bars objects \n    if (Close[0] > Open[0] && Closes[1][0] > Opens[1][0] && Closes[2][0] > Opens[2][0]) \n        EnterLong();\n}\n```\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        // Our hosting script needs to have the AddDataSeries call included as well, which the Pivots indicator we call in the 2nd statement below \n        // also has per default in it's own State.Configure method. This is required since our Pivots indicator below is created in State.DataLoaded\n        // (which is happening after State.Configure and it depends on the AddDataSeries call to have the bars available to properly calculate in \n        // daily bars mode.\n        AddDataSeries(BarsPeriodType.Day, 1);\n    }\n    else if (State == State.DataLoaded)\n    {\n        //In this state, we pass the 1 day series to the Pivots indicator (as BarsArray[1]) and create its instance \n        pivots = Pivots(BarsArray[1], PivotRange.Weekly, HLCCalculationMode.DailyBars, 0, 0, 0, 20);\n    }\n}\n```"
  },
  {
    "_id": "3e6507ee75350c8890c37e995dde785dd035124bf81771a31f9864ea06938a47",
    "_type": "desktopSdkDoc",
    "title": "ClearOutputWindow()",
    "pathName": "clearoutputwindow",
    "parent": "alert_debug_share",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nClears all data from the NinjaTrader **Output Window**.\n\n{% callout type=\"note\" %}\n\nThe ClearOutputWindow() method only targets the Output tab most recently determined by set **PrintTo** property.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**ClearOutputWindow()**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{       \n   if (State == State.SetDefaults)\n   {\n     Name = \"Examples Indicator\";   \n     Description = @\"An indicator used to demonstrate various NinjaScript methods and properties\";                    \n   }\n   else if (State == State.Configure)\n   {                \n     AddDataSeries(BarsPeriodType.Minute, 5);                \n   }   \n   \n   else if(State == State.DataLoaded)\n   {\n     //clear the output window as soon as the bars data is loaded\n     ClearOutputWindow();         \n   }\n}\n```"
  },
  {
    "_id": "836ff184e7b41b1e13cb5fd89fa1de98dbbab99e9d2918913ff43b86a5c7c213",
    "_type": "desktopSdkDoc",
    "title": "Log()",
    "pathName": "log",
    "parent": "alert_debug_share",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nGenerates a NinjaScript category log event record and associated time stamp which is output to the **Log** tab of the NinjaTrader Control Center / Account Data windows. The **Log()** method also writes records to the NinjaTrader log file which can be useful for supporting 3rd party code.\n\n{% callout type=\"note\" %}\n\n1. Log events do NOT process to the NinjaScript output window. For temporary logging, please see the **Print()** method and **Output window**.\n2. The Log event time stamp represents the user configured Time zone from the Tools > Options > General category. This setting could be different from the computer system's time zone.\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**Log(string message, LogLevel logLevel)**\n\n{% callout type=\"warning\" %}\n\nEach call to this method creates a log entry which takes memory to keep loaded in the Log tab of the Control Center. Excessive logging can result in huge portions of memory being allocated to display the log messages. Please see the NinjaScript section of the **Performance Tips** article for more information.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n---\n\n* **message**\n* A **string** value representing the message to be logged\n\n---\n\n* **logLevel**\n* Sets the message level for the log event. Different levels are color coded in the NinjaTrader log.\n  * **LogLevel.Alert** (also generates a pop-up notification window with log message)\n  * **LogLevel.Error**\n  * **LogLevel.Information**\n  * **LogLevel.Warning**\n{% /table %}\n\n## Examples\n\n```csharp\n// Generates a log message\nLog(\"This is a log message\", LogLevel.Information);\n\n// Generates a log message with a notification window\nLog(\"This will generate a pop-up notification window as well\", LogLevel.Alert);\n```"
  },
  {
    "_id": "82faf3684b1688e0300a116bcd8ee3a9aa0f50cc816871154f6409d7a04d8f4d",
    "_type": "desktopSdkDoc",
    "title": "PlaySound()",
    "pathName": "playsound",
    "parent": "alert_debug_share",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nPlays a .wav file while running on real-time data.\n\n{% callout type=\"note\" %}\n\n1. This method will only execute once the **State** has reached **State.Realtime**. Calls to this method during **State.Historical** will be ignored (in contrast to the implementation for **AddOns**).\n2. The default behavior is to play the .wav file in an asynchronous manner, which can result in calls to **PlaySound()** to play over one another. Sound files can optionally be configured to execute in a synchronous manner by enabling the Tools > Options > Sounds > \"Play consecutively\" property.\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**PlaySound(string fileName)**\n\n{% callout type=\"warning\" %}\n\nThe underlying framework used to play the sound requires the audio file to be in PCM .wav format. Using another file format will generate an error at runtime.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **fileName**\n* The absolute file path of the .wav file to play\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nYou can obtain the default NinjaTrader installation directory to access the sounds folder by using **NinjaTrader.Core.Globals.InstallDir** property. Please see the example below for usage.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Plays the wav file mySound.wav\nPlaySound(@\"C:\\mySound.wav\");\n\n// Plays the default Alert1 sound that comes packaged with NinjaTrader\nPlaySound(NinjaTrader.Core.Globals.InstallDir + @\"\\sounds\\Alert1.wav\");\n```"
  },
  {
    "_id": "ce953a0eb08246617b7f849486c4b26a7af37e9d2e8f0e13b3ae1bf0da8a70a2",
    "_type": "desktopSdkDoc",
    "title": "Print()",
    "pathName": "print",
    "parent": "alert_debug_share",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nConverts object data to a string format and appends the specified value as text to the NinjaScript **Output window**. Printing data to the NinjaScript Output window is a useful debugging technique to verify values while developing your custom NinjaScript object.\n\n{% callout type=\"note\" %}\n\nNotes: The Print() method only targets the Output tab recently specified by set **PrintTo** property.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**Print(object value)**\n\n{% callout type=\"warning\" %}\n\nWarning: High frequency of Print() method calls can represent a performance hit on your PC. Please see the NinjaScript section of the [Performance Tips](performance_tips2) article for more information.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **value**\n* The object to print to the output window\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips:\n\n1. You can format prices aligned for easier debugging by using the **ToString()** method. E.g., **Low[0].ToString(\"0.00\")** forces the format from 12.5 to 12.50. **Low[0].ToString(\"0.000\")** forces 12.500.\n2. You can format one or more objects in a specified string with the text equivalent of a corresponding object's value for better maintainability using the .NET **string.Format()** method. Please see the examples below.\n{% /callout %}\n\n## Examples\n\n### Passing objects directly to Print() method\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Generates a message\n   Print(\"This is a message\");\n   //Output:  This is a message\n   Print(\"The high of the current bar is : \" + High[0]);\n   //Output:  The high of the current bar is : 2112.75\n   // Prints the current bar SMA value to the output window\n   Print(SMA(Close, 20)[0]);\n   //Output: 2110.5;\n}\n```\n\n### Passing string.Format() directly to Print() method\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   //Format and Print each bar value to the output window\n   Print(string.Format(\"{0};{1};{2};{3};{4};{5}\", Time[0], Open[0], High[0], Low[0], Close[0], Volume[0]));\n   //Output:  2/24/2015 11:01:00 AM;2110.5;2110.5;2109.75;2110;1702\n}\n```\n\n### Storing and reusing variables in Print() method\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   //store the Close[0] value in a variable which can be printed later\n   double myValue = Close[0];\n   //create and store a custom error message\n   string myError = string.Format(\"Error on Bar {0}, value {1} was not expected\", CurrentBar, myValue);\n   //our first test case, if true print our error\n   if(myValue > High[0])\n     Print(myError);\n   //Output: Error on Bar 233, value 1588.25 was not expected\n   //reassign myValue\n   myValue = Low[0];\n   //our second test case (now uses Low[0]), if true print our error\n   if(myValue > Close[0])\n     Print(myError);\n   //Output: Error on Bar 57, value 1585.5 was not expected\n}\n```"
  },
  {
    "_id": "4ac4386a8fc3e620080313311f45344d702471117dad5949f1db23f3f3d0d78e",
    "_type": "desktopSdkDoc",
    "title": "PrintTo",
    "pathName": "printto",
    "parent": "alert_debug_share",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines either tab of the NinjaScript **Output window** the **Print()** and **ClearOutputWindow()** method targets.\n\n## Property Value\n\nAn enum value representing the target Output Tab. The default value is **PrintTo.OutputTab1**.\n\nPossible values are:\n\n{% table %}\n\n---\n\n* **PrintTo.OutputTab1**\n* Output Windows tab named \"Output 1\"\n\n---\n\n* **PrintTo.OutputTab2**\n* Output Windows tab named \"Output 2\"  \n{% /table %}\n\n## Syntax\n\n**PrintTo**\n\n## Examples\n\n### Setting the default PrintTo in separate scripts (#1)\n\n```csharp\nprotected override void OnStateChange()\n{      \n   if (State == State.SetDefaults)\n   {\n     Name = \"Sample PrintTo Indicator #1\";\n     Description = @\"Used to Print updates to Output 1\";\n \n     //Set this scripts Print() calls to the first output tab\n     PrintTo = PrintTo.OutputTab1;\n   }      \n}\n \nprotected override void OnBarUpdate() \n{                  \n   Print(\"This script will print messages to Output Tab 1\");      \n}\n```\n\n### Setting the default PrintTo in separate scripts (#2)\n\n```csharp\nprotected override void OnStateChange()\n{      \n   if (State == State.SetDefaults)\n   {\n     Name = \"Sample PrintTo Indicator #2\";\n    Description = \"@Used to Print updates to Output 2\";\n \n     //Set this scripts Print() calls to the second output tab\n     PrintTo = PrintTo.OutputTab2;\n   }      \n}\n \nprotected override void OnBarUpdate() \n{                  \n   Print(\"This script will print messages to Output Tab 2\");      \n}\n```\n\n### Setting PrintTo conditionally in a single script\n\n```csharp\nprotected override void OnMarketData(MarketDataEventArgs marketDataUpdate)\n{\n   if(marketDataUpdate.MarketDataType == MarketDataType.Ask)\n   {\n     //Print Ask updates to Output 1\n     PrintTo = PrintTo.OutputTab1;\n     Print(\"Ask: \" + marketDataUpdate.Price);\n   }\n   \n   else if (marketDataUpdate.MarketDataType == MarketDataType.Bid)\n   {\n     //Print Bid updates to Output 2\n     PrintTo = PrintTo.OutputTab2;\n     Print(\"Bid: \" + marketDataUpdate.Price);\n   }\n}\n```"
  },
  {
    "_id": "a3566c58b007711477fb98202d0cb2c25a0fdf5012bbe857c520843a672bfcaa",
    "_type": "desktopSdkDoc",
    "title": "RearmAlert()",
    "pathName": "rearmalert",
    "parent": "alert_debug_share",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRearms an alert created via the **Alert()** method.\n\n{% callout type=\"note\" %}\n\nA NinjaScript generated alert may need to be rearmed after the alert is triggered depending on the **Alert()** method's **rearmSeconds** parameter.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**RearmAlert(string id)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* id\n* A unique string id representing an alert id to rearm\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   //rearms \"myAlert\" on each new trading session\n   if(Bars.IsFirstBarOfSession)\n     RearmAlert(\"myAlert\");\n}\n```"
  },
  {
    "_id": "3d51e989e47681ab3affc2fb5f890a8bc7e61305fffe3d920d41a25b0af18976",
    "_type": "desktopSdkDoc",
    "title": "SendMail()",
    "pathName": "sendmail",
    "parent": "alert_debug_share",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nSends an email message through the default email sharing service.\n\n{% callout type=\"note\" %}\n\nNotes:  \n\n1. This method can only be called once the **State** has reached **State.Realtime**. Calls to this method in any other State will be silently ignored (in contrast to the implementation for **AddOns**).\n2. You MUST configure an email account as a default \"Mail\" Share Service from the **General Options**.\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**SendMail(string to, string subject, string text)**\n\n{% callout type=\"warning\" %}\n\nIf mail is not received, please check the **Log** tab of the control center for any specific errors which could be related to delivering the message.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **to**\n* The email recipient\n\n---\n\n* **subject**\n* Subject line of email\n\n---\n\n* **text**\n* Message body of email\n{% /table %}\n\n## Examples\n\n```csharp\n// Generates an email message\nSendMail(\"customer@winners.com\", \"Trade Alert\", \"Buy ES\");\n```"
  },
  {
    "_id": "c3bc45ac352fe43ff8f0a1cc26d6cc29f71f536dc417906f8513ea44ed4bb161",
    "_type": "desktopSdkDoc",
    "title": "Share",
    "pathName": "share",
    "parent": "alert_debug_share",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nSends a message or screen shot to a social network or Share Service.\n\n{% callout type=\"note\" %}\n\n1. This method can only be called once the **State** has reached **State.Realtime**. Calls to this method in any other State will be silently ignored.\n2. You MUST configure an account with a Share Service provider from the **General Options**.\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**Share(string serviceName, string message)**  \n**Share(string serviceName, string message, object[] args)**  \n**Share(string serviceName, string message, string screenshotPath)**  \n**Share(string serviceName, string message, string screenshotPath, object[] args)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **serviceName**\n* A **string** value representing the share service to be used\n\n---\n\n* **message**\n* A **string** value representing the text body sent to the social network or other Share providers. Note: The message is what appears in the text box of the Share window\n\n---\n\n* **screenshotPath**\n* Optional string path to screenshot or other images sent to the social network or other Share providers\n\n---\n\n* **args**\n* A generic object[] array used to designate additional information sent to the share service\n{% /table %}\n\n{% callout type=\"note\" %}\n\n1. The \"args\" parameter differs for each share service used. If you are using a custom developed share adapter, you need to work with the developer of that adapter to understand what the \"args\" parameter represents for that adapter.\n2. For the default NinjaTrader share adapters, the \"args\" array represents the following:\n   * Mail share service:\n     * args[0] = A string representing the email \"To\" field,\n     * args[1] = A string representing the email \"Subject\" field\n   * StockTwits share service:\n     * args[0] = An enum representing the \"StockTwitsSentiment\" parameter\n{% /callout %}\n\n## Examples\n\n```csharp\n// using \"args\" as the Mail \"To\" and \"Subject\" parameters\nShare(\"Gmail\", \"Test Message\", new object[]{ \"example@test.com\", \"Test Subject Line\" });\n```"
  },
  {
    "_id": "7702e06e89b8d8355a5cd1e82eb80825e8743be9e730165100e36a4b5b951321",
    "_type": "desktopSdkDoc",
    "title": "Alert, Debug, Share",
    "pathName": "alert_debug_share",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The following section documents properties and methods used to trigger alerts from a NinjaScript object, send debug messages to the NinjaScript Output Window, or utilize Share Services to send emails or post to social-media networks.\n\n{% table %}\n\n* Method\n* Description\n\n---\n\n* [Alert()](alert)\n* Generates a visual/audible alert for the [Alerts Log](alerts_log) window\n\n---\n\n* [ClearOutputWindow()](clearoutputwindow)\n* Clears all data from the NinjaTrader [Output Window](output)\n\n---\n\n* [Log()](log)\n* Generates a NinjaScript category log event record which is output to the [Log](log_tab2) tab of the NinjaTrader Control Center / Account Data windows\n\n---\n\n* [PlaySound()](playsound)\n* Plays a .wav file while running on real-time data\n\n---\n\n* [Print()](print)\n* Converts object data to a string format and appends the specified value as text to the NinjaScript [Output window](output)\n\n---\n\n* [PrintTo](printto)\n* Determines either tab of NinjaScript [Output window](output) the [Print()](print) and [ClearOutputWindow()](clearoutputwindow) method targets\n\n---\n\n* [RearmAlert()](rearmalert)\n* Rearms an alert created via the [Alert()](alert) method\n\n---\n\n* [SendMail()](sendmail)\n* Sends an email message through the default email sharing service.\n\n---\n\n* [Share()](share)\n* Sends a message or screen shot to a social network or Share Service.\n{% /table %}"
  },
  {
    "_id": "4be5a6425f8678a5f28554294043d98f0b93edecfbc642976ace11edcf2999bf",
    "_type": "desktopSdkDoc",
    "title": "CountIf()",
    "pathName": "countif",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nCounts the number of instances the test condition occurs over the look-back period expressed in bars.\n\n{% callout type=\"note\" %}\n\nThis method does NOT work on **multi-series** strategies and indicators.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing the number of occurrences found.\n\n## Syntax\n\nCountIf(**Func<`bool`>** condition, **int** period)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **condition**\n* A true/false expression\n\n---\n\n* **period**\n* Number of bars to check for the test condition\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: The syntax for the \"condition\" parameter uses [lambda expression](http://msdn.microsoft.com/en-us/library/bb397687.aspx) syntax.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// If in the last 10 bars we have had 8 up bars then go long\nif (CountIf(() => Close[0] > Open[0], 10) > 8)\n     EnterLong();\n```"
  },
  {
    "_id": "42a9894f996aa095a2f9c0d89290d6a7b580514a82322a839a987b172f6e23c9",
    "_type": "desktopSdkDoc",
    "title": "CrossAbove()",
    "pathName": "crossabove",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nEvaluates a cross above condition over the specified bar look-back period.\n\n{% callout type=\"note\" %}\n\nThis method does not return true if both series being compared have equal values on the current or previous bar with a lookbackPeriod of 1.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method returns true if a cross above condition occurred; otherwise, false.\n\n## Syntax\n\n**CrossAbove**(**ISeries`<double>`** series1, **ISeries`<double>`** series2, **int** lookBackPeriod)  \n**CrossAbove**(**ISeries`<double>`** series1, **double** value, **int** lookBackPeriod)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **lookBackPeriod**\n* Number of bars back to check the cross above condition\n\n---\n\n* **series1** & **series2**\n* Any **Series<`double`>** type object such as an indicator, Close, High, Low, etc...\n\n---\n\n* **value**\n* Any **double** value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Go short if CCI crossed above 250 within the last bar\n   if (CrossAbove(CCI(14), 250, 1))\n       EnterShort();\n\n   // Go long if 10 EMA crosses above 20 EMA within the last bar\n   if (CrossAbove(EMA(10), EMA(20), 1))\n       EnterLong();\n\n   // Go long we have an up bar and the 10 EMA crosses above 20 EMA within the last 5 bars\n   if (Close[0] > Open[0] && CrossAbove(EMA(10), EMA(20), 5))\n       EnterLong();\n}\n```"
  },
  {
    "_id": "deec2be417d9269fba88bb9ecd140435319900fd005b1c0d70c8b949586f1f63",
    "_type": "desktopSdkDoc",
    "title": "CrossBelow()",
    "pathName": "crossbelow",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nEvaluates a cross below condition over the specified bar look-back period.\n\n{% callout type=\"note\" %}\n\nThis method does not return true if both series being compared have equal values on the current or previous bar with a lookbackPeriod of 1.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method returns true if a cross below condition occurred; otherwise, false.\n\n## Syntax\n\n**CrossBelow**(**ISeries`<double>`** series1, **ISeries`<double>`** series2, **int** lookBackPeriod)  \n\n**CrossBelow**(**ISeries`<double>`** series1, **double** value, **int** lookBackPeriod)\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **lookBackPeriod**\n* Number of bars back to check the cross below condition\n\n---\n\n* **series1** & **series2**\n* Any **Series<`double`>** type object such as an indicator, Close, High, Low, etc...\n\n---\n\n* **value**\n* Any **double** value\n\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Go long if CCI crossed below -250 within the last bar\n   if (CrossBelow(CCI(14), -250, 1))\n       EnterLong();\n\n   // Go short if 10 EMA crosses below 20 EMA within the last bar\n   if (CrossBelow(EMA(10), EMA(20), 1))\n       EnterShort();\n\n   // Go short we have a down bar and the 10 EMA crosses below 20 EMA within the last 5 bars\n   if (Close[0] < Open[0] && CrossBelow(EMA(10), EMA(20), 5))\n       EnterShort();\n}\n```"
  },
  {
    "_id": "c836d4b1ec1f66d08f6fa00450403b3d372d5066b740e3282ad55b18143f7c93",
    "_type": "desktopSdkDoc",
    "title": "GetCurrentAsk()",
    "pathName": "getcurrentask",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the current real-time ask price.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n1. When accessed during **State.Historical**, the **Close** price of the evaluated bar is substituted. To access historical Ask prices, please see **Developing for Tick Replay**.\n2. The **GetCurrentAsk()** method runs on the bar series currently updating determined by the **BarsInProgress** property. For **multi-instrument** scripts, an additional int **barsSeriesIndex** parameter can be supplied which forces the method to run on an supplementary bar series.\n{% /callout %}\n\n## Method Return Value\n\nA **double** value representing the current ask price.\n\n## Syntax  \n\n**GetCurrentAsk()**  \n**GetCurrentAsk(int barsSeriesIndex)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **barsSeriesIndex**\n* An **int** value determining the bar series the method runs. Note: This optional parameter is reserved for multi-instrument scripts\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Ensure we do not call GetCurrentAsk() on historical data\n   if (State == State.Historical)\n     return;\n\n   double currentAsk = GetCurrentAsk();\n\n   Print(\"The Current Ask price is: \" + currentAsk);\n\n   // The Current Ask price is: 1924.75\n```\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Example's Indicator\";\n   }\n   if (State == State.Configure)\n   {\n     //Add MSFT as our additional data series\n     AddDataSeries(\"MSFT\", BarsPeriodType.Minute, 1);\n   }\n}\n\nprotected override void OnBarUpdate()\n{\n   // Ensure we do not call GetCurrentBid() on historical data\n   if (State == State.Historical)\n     return;\n\n   if (BarsInProgress == 0)\n   {\n     double primaryAsk = GetCurrentAsk(0);\n     Print(\"The Primary Ask price is: \" + primaryAsk);\n     // The Primary Ask price is: 1924.75\n   }\n\n   if (BarsInProgress == 1)\n   {\n     double msftAsk = GetCurrentAsk(1);\n     Print(\"MSFT's Current Ask price is: \" + msftAsk);\n     // MSFT's Current Ask is: 43.63\n   }\n```"
  },
  {
    "_id": "ffc4950c2959b6959da9b0108d8bcab8cc7f3a297ccc894bd57b2dff79a262d8",
    "_type": "desktopSdkDoc",
    "title": "GetCurrentAskVolume()",
    "pathName": "getcurrentaskvolume",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the current real-time ask volume.\n\n{% callout type=\"note\" %}\n\n1. When accessed during **State.Historical**, the [Volume](volume.md) of the evaluated bar series is substituted. To access historical Ask Volumes, please see [Developing for Tick Replay](developing_for__tick_replay).\n2. The **GetCurrentAskVolume()** method runs on the bar series currently updating determined by the **BarsInProgress** property. For [multi-instrument](multi-time_frame__instruments) scripts, an additional int \"barsSeriesIndex\" parameter can be supplied which forces the method to run on a supplementary bar series.\n{% /callout %}\n\n## Method Return Value\n\nA long value representing the current ask volume.\n\n## Syntax  \n\n**GetCurrentAskVolume()**  \n\n**GetCurrentAskVolume(int barsSeriesIndex)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* barsSeriesIndex\n* An **int** value determining the bar series the method runs. Note: This optional parameter is reserved for multi-instrument scripts\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   long currentAskVolume = GetCurrentAskVolume();\n   Print(\"The Current Ask volume is: \" + currentAskVolume);\n   //The Current Ask volume is: 158\n}\n\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Examples Indicator\";\n   }\n   if (State == State.Configure)\n   {\n     //Add MSFT as our additional data series\n     AddDataSeries(\"MSFT\", BarsPeriodType.Minute, 1);\n   }\n}\nprotected override void OnBarUpdate()\n{\n   if(BarsInProgress == 0)\n   {\n     long currentAskVolume = GetCurrentAskVolume(0);\n     Print(\"The Current Ask volume is: \" + currentAskVolume);\n     //The Current Ask volume is: 346\n   }\n\n   if(BarsInProgress == 1)\n\n   {\n\n     long msftAskVolume = GetCurrentAskVolume(1);\n\n     Print(\"MSFT's Current Ask volume is: \" + msftAskVolume);\n\n     //MSFT's Current Ask volume is: 1548\n\n   }\n```"
  },
  {
    "_id": "6dbd0dcd25fbcb21b61d27445fef6554a00bfb61159009e185d338efec52160e",
    "_type": "desktopSdkDoc",
    "title": "GetCurrentBid()",
    "pathName": "getcurrentbid",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the current real-time bid price.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n1. When accessed during **State.Historical**, the [Close](close) price of the evaluated bar is substituted. To access historical bid prices, please see [Developing for Tick Replay](developing_for__tick_replay).\n2. The **GetCurrentBid()** method runs on the bar series currently updating determined by the **BarsInProgress** property. For [multi-instrument](multi-time_frame__instruments) scripts, an additional int \"barsSeriesIndex\" parameter can be supplied which forces the method to run on an supplementary bar series.\n{% /callout %}\n\n## Method Return Value\n\nA **double** value representing the current bid price.\n\n## Syntax  \n\n**GetCurrentBid()**  \n**GetCurrentBid(int barsSeriesIndex)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **barsSeriesIndex**\n* An **int** value determining the bar series the method runs. Note: This optional parameter is reserved for multi-instrument scripts\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Ensure we do not call GetCurrentBid() on historical data\n   if (State == State.Historical)\n     return;\n\n   double currentBid = GetCurrentBid();\n   Print(\"The Current Bid price is: \" + currentBid);\n   // The Current Bid price is: 1924.75\n}\n\n```csharp\n\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Example's Indicator\";\n   }\n   if (State == State.Configure)\n   {\n     //Add MSFT as our additional data series\n     AddDataSeries(\"MSFT\", BarsPeriodType.Minute, 1);\n   }\n}\n\nprotected override void OnBarUpdate()\n{\n   // Ensure we do not call GetCurrentBid() on historical data\n   if (State == State.Historical)\n     return;\n\n   if (BarsInProgress == 0)\n   {\n     double primaryBid = GetCurrentBid(0);\n     Print(\"The Primary Bid price is: \" + primaryBid);\n     // The Primary Bid price is: 1924.75\n   }\n\n   if (BarsInProgress == 1)\n   {\n     double msftBid = GetCurrentBid(1);\n     Print(\"MSFT's Current Bid price is: \" + msftBid);\n     // MSFT's Current Bid is: 43.63\n   }\n}\n```"
  },
  {
    "_id": "760773d21fa33e3a9b0cdbb9b73929899944f97408d5118aae70a5f6416ad985",
    "_type": "desktopSdkDoc",
    "title": "GetCurrentBidVolume()",
    "pathName": "getcurrentbidvolume",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the current real-time bid volume.\n\n{% callout type=\"note\" %}\n\n1. When accessed during **State.Historical**, the [Volume](volume.md) of the evaluated bar series is substituted. To access historical Bid Volumes, please see [Developing for Tick Replay](developing_for__tick_replay).\n2. The **GetCurrentBidVolume()** method runs on the bar series currently updating determined by the **BarsInProgress** property. For [multi-instrument](multi-time_frame__instruments) scripts, an additional int \"barsSeriesIndex\" parameter can be supplied which forces the method to run on a supplementary bar series.\n{% /callout %}\n\n## MethoReturn Value\n\nA long value representing the current bid volume.\n\n## Syntax  \n\n**GetCurrentBidVolume()**  \n\n**GetCurrentBidVolume(int barsSeriesIndex)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **barsSeriesIndex**\n* An **int** value determining the bar series the method runs. Note: This optional parameter is reserved for multi-instrument scripts\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   long currentBidVolume = GetCurrentBidVolume();\n   Print(\"The Current Bid volume is: \" + currentBidVolume);\n   //The Current Bid volume is: 158\n}\n\n```\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Examples Indicator\";\n   }\n   if (State == State.Configure)\n   {\n     //Add MSFT as our additional data series\n     AddDataSeries(\"MSFT\", BarsPeriodType.Minute, 1);\n   }\n}\n```\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   if(BarsInProgress == 0)\n   {\n     long currentBidVolume = GetCurrentBidVolume(0);\n     Print(\"The Current Bid volume is: \" + currentBidVolume);\n     //The Current Bid volume is: 346\n   }\n\n   if(BarsInProgress == 1)\n\n   {\n\n     long msftBidVolume = GetCurrentBidVolume(1);\n\n     Print(\"MSFT's Current Bid volume is: \" + msftBidVolume);\n\n     //MSFT's Current Bid volume is: 1548\n\n   }\n```"
  },
  {
    "_id": "be6df13306a21c86f3098150dbcc366b06834c88cb66ae0b599dd68e4cdb1027",
    "_type": "desktopSdkDoc",
    "title": "GetMedian()",
    "pathName": "getmedian",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the statistical median value of the specified series over the specified look-back period. This method sorts the values of the specified look back period in ascending order and returns the middle value.\n\n{% callout type=\"note\" %}\n\n1. This method should NOT be confused with **Median** prices defined as (**High** + **Low**) / 2. This method returns the statistical median of a series.\n2. If an even number is passed as the look-back period, the average of the two middle values in the sorted values will be returned.\n{% /callout %}\n\n## Method Return Value\n\nA **double** value representing the median value of the series.\n\n## Syntax\n\n**GetMedian**(**ISeries`<double>`** series, **int** lookBackPeriod)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **lookBackPeriod**\n* Number of bars back to include in the calculation\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, **Close**, **High**, **Low**, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{   \n   // Print the median price of the last 10 open prices \n   //(current open price + look back period's 9 open prices before that)\n   double openMedian = GetMedian(Open, 9);         \n   Print(\"The median of the last 10 open prices is: \" + openMedian);      \n}\n```"
  },
  {
    "_id": "7e092a03821c8ad7abce91c11d39240f3a3dafb12da42dfc8eb5fadd044fbe7a",
    "_type": "desktopSdkDoc",
    "title": "Least Recent Occurrence (LRO)",
    "pathName": "least_recent_occurrence_lro",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars. The **LRO()** method starts from the furthest bar away and works toward the current bar.\n\n{% callout type=\"note\" %}\n\nThis method does NOT work on [multi-series](multi-time_frame__instruments) strategies and indicators.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.\n\n## Syntax\n\n**LRO(Func<`bool`> condition, int instance, int lookBackPeriod)**\n\n{% callout type=\"warning\" %}\n\n1. The \"instance\" parameter MUST be greater than 0.\n2. The \"lookBackPeriod\" parameter MUST be greater than 0.\n3. Please check the Log tab for any other exceptions that may be thrown by the condition function parameter.\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **condition**\n* A true/false expression\n\n---\n\n* **instance**\n* The occurrence to check for (1 is the least recent, 2 is the 2nd least recent, etc...)\n\n---\n\n* **lookBackPeriod**\n* The number of bars to look back to check for the test condition. The test evaluates on the current bar and the bars within the look-back period.\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nThe syntax for the \"condition\" parameter uses [lambda expression](http://msdn.microsoft.com/en-us/library/bb397687.aspx) syntax.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Prints the high price of the least recent up bar over the last 10 bars (current bar + look back period's 9 bars before that)\n    int barsAgo = LRO(() => Close[0] > Open[0], 1, 9);\n    if (barsAgo > -1)\n        Print(\"The bar high was \" + High[barsAgo]);         \n}\n```\n\n## See Also  \n\n[Most Recent Occurrence(MRO)](most_recent_occurence_mro)"
  },
  {
    "_id": "afe450a85175d1c708da0129de8519a330919cc7a9d97bf1ef51c11ececd02bf",
    "_type": "desktopSdkDoc",
    "title": "Most Recent Occurrence (MRO)",
    "pathName": "most_recent_occurrence_mro",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars. The **MRO()** method starts from the current bar works away (backward) from it.\n\n{% callout type=\"note\" %}\n\nThis method does NOT work on [multi-series](multi-time_frame__instruments) strategies and indicators.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.\n\n## Syntax\n\n**MRO(Func<`bool`> condition, int instance, int lookBackPeriod)**\n\n{% callout type=\"warning\" %}\n\n1. The \"instance\" parameter MUST be greater than 0.\n2. The \"lookBackPeriod\" parameter MUST be greater than 0.\n3. Please check the Log tab for any other exceptions that may be thrown by the condition function parameter.\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **condition**\n* A true/false expression\n\n---\n\n* **instance**\n* The occurrence to check for (1 is the most recent, 2 is the 2nd most recent, etc...)\n\n---\n\n* **lookBackPeriod**\n* The number of bars to look back to check for the test condition. The test evaluates on the current bar and the bars within the look-back period.\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nThe syntax for the \"condition\" parameter uses [lambda expression](http://msdn.microsoft.com/en-us/library/bb397687.aspx) syntax.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Prints the high price of the most recent up bar over the last 10 bars (current bar + look back period's 9 bars before that)\n    int barsAgo = MRO(() => Close[0] > Open[0], 1, 9);\n    if (barsAgo > -1)\n        Print(\"The bar high was \" + High[barsAgo]);   \n}\n```\n\n## See Also  \n\n[Least Recent Occurrence(LRO)](least_recent_occurence_lro)"
  },
  {
    "_id": "9d75c66a7958ac218fd23d837a72d9d475d50579417a3b4710f63ff6efe528a1",
    "_type": "desktopSdkDoc",
    "title": "IsRising()",
    "pathName": "isrising",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nEvaluates a rising condition which is true when the current value is greater than the value of 1 bar ago.\n\n## Method Return Value\n\nThis method returns true if a rising condition is present; otherwise, false.\n\n## Syntax\n\n**IsRising(ISeries`<double>` series)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, Close, High, Low, etc...\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // If the 20 period SMA is rising (in uptrend) go long\n   if (IsRising(SMA(20)))\n       EnterLong();\n}\n```"
  },
  {
    "_id": "fb1acd44962209a65826621210c03c0a72e392169f52c2f208efbf3f272f09a2",
    "_type": "desktopSdkDoc",
    "title": "Slope()",
    "pathName": "slope",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a measurement of the steepness of a price series (y value) measured by the change over time (x value). The return value can also be thought of as the ratio between the **startBarsAgo** and **endBarsAgo** parameters passed to the method.\n\nThe formula which is returned from the parameters passed is:\n\n(series[**endBarsAgo**] - series[**startBarsAgo**]) / (**startBarsAgo** - **endBarsAgo**)\n\n{% callout type=\"note\" %}\n\nThe return value should NOT be confused with the angle (or radians) of a line that displays on the chart.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method returns A **double** value indicating the slope of a line; A value of 0 returns if either the **startBars** or **endBars** parameters are less than 0 or both parameters are of equal value.\n\n## Syntax\n\n**Slope**(**ISeries`<double>`** series, **int** startBarsAgo, **int** endBarsAgo)\n\n{% callout type=\"warning\" %}\n\nThe \"**startBarsAgo**\" parameter MUST be greater than the \"**endBarsAgo**\" parameter.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **series**\n* Any **Series<`double`>** type object such as an indicator, Close, High, Low, etc...\n\n---\n\n* **startBarsAgo**\n* The starting point of a series to be evaluated\n\n---\n\n* **endBarsAgo**\n* The ending point of a series to be evaluated\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nThinking in degrees, for example a 1 to -1 return range would translate to 45 to -45. To convert you could look into working with this formula - **Math.Atan(Slope)** * 180 / **Math.PI**.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{ \n    // Prints the slope of the 20 period simple moving average of the last 10 bars\n    Print(Slope(SMA(20), 10, 0)); \n}\n```"
  },
  {
    "_id": "4d3c1be0b4f2fa41aa176eb5c2ba129f148fcbf5eed9f5624bd818ad486a318d",
    "_type": "desktopSdkDoc",
    "title": "TickSize",
    "pathName": "ticksize",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe minimum fluctuation value which is always a value of 1-tick for the corresponding master instrument.\n\n## Property Value\n\nA **double** value that represents the minimum fluctuation of an instrument.\n\n## Syntax\n\n**TickSize**\n\n## Warning\n\n{% callout type=\"note\" %}\n\nThis property should NOT be accessed during State.SetDefaults from within the **OnStateChange()** method, all bars series would be guaranteed to have loaded in **State.DataLoaded**.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Prints the ticksize to the output window\nPrint(\"The ticksize of this instrument is \" + TickSize);\n// Prints the value of the current bar low less one tick size\ndouble value = Low[0] - TickSize;\nPrint(value);\n```"
  },
  {
    "_id": "e0f4f767ac88a9303e7317843ac20be980665a36f52397e5b26d4cc2bf54011d",
    "_type": "desktopSdkDoc",
    "title": "ToDay()",
    "pathName": "today",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nCalculates an integer value representing a date.\n\n{% callout type=\"note\" %}\n\nNote: Integer representation of day is format as yyyyMMdd where January 8, 2015 would be 20150108.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing date structure.\n\n## Syntax\n\n**ToDay(DateTime time)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **time**\n* A DateTime structure to calculate. Note: See also the [Time](time) property.\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: NinjaScript uses the .NET [DateTime](http://msdn2.microsoft.com/en-us/library/system.datetime.aspx) structures which can be complicated for novice programmers. If you are familiar with **C#** you can directly use DateTime structure properties and methods for date and time comparisons otherwise use this method and the [ToTime()](totime) method.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{   \n    // Compare the date of the current bar to September 15, 2014\n    if (ToDay(Time[0]) > 20140915)\n    {\n        // Do something       \n    }\n}\n```"
  },
  {
    "_id": "12bfb9b5b0fe4d08337155cbead8bb573a4cb19b01fe7f8ef47a05a9b8e1fda1",
    "_type": "desktopSdkDoc",
    "title": "ToTime()",
    "pathName": "totime",
    "parent": "analytical",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nCalculates an integer value representing a time.\n\n{% callout type=\"note\" %}\n\nInteger representation of time is in the format Hmmss where 7:30 AM would be 73000 and 2:15:12 PM would be 141512.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing a time structure.\n\n## Syntax\n\n**ToTime(DateTime time)**  \n**ToTime(int hour, int minute, int second)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **time**\n* A DateTime structure to calculate. Note: See also the [Time](time) property.\n\n---\n\n* **hour**\n* An **int** value representing the hour used for the input.\n\n---\n\n* **minute**\n* An **int** value representing the minute used for the input.\n\n---\n\n* **second**\n* An **int** value representing the second used for the input.\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nNinjaScript uses the .NET DateTime structure which can be complicated for novice programmers. If you are familiar with **C#** you can directly use DateTime structure properties and methods for date and time comparisons; otherwise, use this method and the [ToDay()](today) method.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Only trade between 7:45 AM and 1:45 PM\nif (ToTime(Time[0]) >= 74500 && ToTime(Time[0]) <= 134500)\n{\n    // Strategy logic goes here\n}\n```\n\n```csharp\n// Store start time as an int variable to be compared\nint startTime = ToTime(9, 30, 00); // 93000\n\n// Only trade after 9:30 AM\nif (ToTime(Time[0]) >= startTime)\n{\n    // Strategy logic goes here\n}\n```"
  },
  {
    "_id": "05aa6659dbc4d45231c447b876866c889f9ebc7863ccecc79e38b049a204e4a0",
    "_type": "desktopSdkDoc",
    "title": "Analytical",
    "pathName": "analytical",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "NinjaScript provides a number of methods and properties useful for analyzing and identifying specific conditions within **Series`<t>`** collections. Some of these methods test a condition and return true or false, while others return an int-based bar index or other numerical value. A list of analytical methods can be found below:\n\n{% table %}\n\n* Methods and Properties\n* Description\n\n---\n\n* [CountIf()](countif)\n* Counts the number of occurrences of the test condition\n\n---\n\n* [CrossAbove()](crossabove)\n* Evaluates a cross above condition\n\n---\n\n* [CrossBelow()](crossbelow)\n* Evaluates a cross below condition\n\n---\n\n* [GetCurrentAsk()](getcurrentask)\n* Returns the current Ask price\n\n---\n\n* [GetCurrentAskVolume()](getcurrentaskvolume)\n* Returns the current Ask volume\n\n---\n\n* [GetCurrentBid()](getcurrentbid)\n* Returns the current Bid price\n\n---\n\n* [GetCurrentBidVolume()](getcurrentbidvolume)\n* Returns the current Bid volume\n\n---\n\n* [GetMedian()](getmedian)\n* Returns the median value of the specified series\n\n---\n\n* [HighestBar()](highestbar)\n* Returns the number of bars ago the highest price value occurred\n\n---\n\n* [IsFalling()](falling)\n* Evaluates a falling condition\n\n---\n\n* [IsRising()](rising)\n* Evaluates a rising condition\n\n---\n\n* [Least Recent Occurrence (LRO)](least_recent_occurence_lro)\n* Returns the number of bars ago that the least recent occurrence of a test condition evaluated to true\n\n---\n\n* [LowestBar()](lowestbar)\n* Returns the number of bars ago the lowest price value occurred\n\n---\n\n* [Most Recent Occurrence (MRO)](most_recent_occurence_mro)\n* Returns the number of bars ago that the most recent occurrence of a test condition evaluated to true\n\n---\n\n* [Slope()](slope)\n* Returns a measurement of the steepness of a price series measured by the change over time\n\n---\n\n* [TickSize](ticksize)\n* The value of 1 tick for the corresponding instrument\n\n---\n\n* [ToDay()](today)\n* Calculates an integer value representing a date\n\n---\n\n* [ToTime()](totime)\n* Calculates an integer value representing a time\n{% /table %}"
  },
  {
    "_id": "f1b4db36f908e557e2321176b6d345f5a700d4fba979381605327fdc1c8adbf7",
    "_type": "desktopSdkDoc",
    "title": "Attributes",
    "pathName": "attributes",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The following section documents both .NET native and NinjaScript custom [attributes](https://msdn.microsoft.com/en-us/library/5x6cd29c(v=vs.110).aspx) which are commonly used to define the behavior of a NinjaScript property or object. The attributes outlined in the section are primarily used to customize how properties display on the UI, but may also control or how the object is compiled and executed at run time.\n\n{% callout type=\"note\" %}\n\n1. The .NET Framework supplies many other pre-defined [system attributes](https://msdn.microsoft.com/en-us/library/2e39z096.aspx) which can technically be used for custom NinjaScript programming, but are NOT covered in this section and therefore are considered unsupported. 3rd party developers are encourage to explore additional usage, but the resulting behavior CANNOT be guaranteed.\n2. Not all attributes can be applied to all object types. For example, applying an attribute that is defined to target an class will NOT compile should you attempt to apply this attribute to a type of property.\n{% /callout %}\n\n## Common Attributes\n\n{% table %}\n\n* BrowsableAttribute\n* Determines if a property should be displays in the NinjaTrader UI's property grid\n\n---\n\n* CategoryOrderAttribute\n* Determines the sequence in which a NinjaScript object's Display.GroupName categories are arranged in relation to other categories in the UI.\n\n---\n\n* DisplayAttribute\n* Determines how a property is displays on the NinjaTrader UI's property grid.\n\n---\n\n* NinjaScriptPropertyAttribute\n* Determines if a property should be included in the NinjaScript object's constructor as a parameter\n\n---\n\n* RangeAttribute\n* Determines if the value of a property is valid within a specified range\n\n---\n\n* XmlIgnoreAttribute\n* Determines if a property participates in the XML serialization routines (saving workspaces or templates)\n{% /table %}\n\n## Applying Attributes\n\nAttributes are applied directly before the property, method, or class, and are identified by wrapping brackets:\n\n```csharp\n[AnExampleAttribute] // a pseudo-attribute demonstrating how to target an object\npublic object AnExampleProperty // the property that is being targeted\n{ get; set; }\n```\n\n{% callout type=\"note\" %}\n\nConventionally, the suffix \"attribute\" is provided to the object's name to help determine that is an attribute, however C# does not require you to specify the full name of an attribute. For example DisplayAttribute() will compile the same as Display().\n\n{% /callout %}"
  },
  {
    "_id": "717b62f4ad825f501f928a8dd02f9a9dca56ecc8be746388af00d7c92583f716",
    "_type": "desktopSdkDoc",
    "title": "BarsSinceNewTradingDay",
    "pathName": "barssincenewtradingday",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the number of bars elapsed since the start of the trading day relative to the current bar processing.\n\n## Property Value\n\nAn **int** value representing the number of bars elapsed. This property cannot be set.\n\n## Syntax\n\n**Bars.BarsSinceNewTradingDay**\n\n## Examples\n\n```csharp\n\n// Only process strategy logic after five bars have posted since the start of the trading day\nprotected override void OnBarUpdate()\n{\n   if (Bars.BarsSinceNewTradingDay >= 5)\n   {\n     //Strategy logic here\n   }\n}\n```"
  },
  {
    "_id": "4ef4fb87ba514d7693015d5787fff1862ae01a27b31897ddb1f39379d339bf8e",
    "_type": "desktopSdkDoc",
    "title": "GetAsk()",
    "pathName": "getask",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the ask price value at a selected absolute bar index value.\n\n{% callout type=\"note\" %}\n\n* This method does NOT return the current real-time asking price, but rather the historical / real-time asking price at the desired index. For obtaining the current real-time asking price, please use **GetCurrentAsk**().\n* This method returns expected values when 1 tick bid / ask stamped data is used and available from **your provider**.\n{% /callout %}\n\n## Method Return Value\n\nA **double** value that represents the asking price at the desired bar index.\n\n## Syntax\n\n**Bars.GetAsk(int index)**\n\n## Parameters\n\n{% table %}\n\n* **Parameter**\n* **Description**\n\n---\n\n* **index**\n* The absolute bar index value used\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // If the Highs of the two most recent bars are falling, place a long stop market order \n    // at the Ask price \n    if (High[0] < High[1] && High[1] < High[2])\n    {\n        EnterLongStopMarket(Bars.GetAsk(CurrentBar));\n    }\n}\n```"
  },
  {
    "_id": "f73bcbf19d5db1de61970aee7c181d3e258ee953f650f361671174ae4148b56c",
    "_type": "desktopSdkDoc",
    "title": "GetBar()",
    "pathName": "getbar",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the first bar that matches the time stamp of the \"time\" parameter provided.\n\n{% callout type=\"note\" %}\n\nIf the time parameter provided is older than the first bar in the series, a bar index of 0 is returned. If the time stamp is newer than the last bar in the series, the last absolute bar index is returned.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **int** value representing an absolute bar index value.\n\n## Syntax\n\n**Bars.GetBar(DateTime time)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* time\n* Time stamp to be converted to an absolute bar index\n{% /table %}\n\n## Examples\n\n```csharp\n// Check that its past 9:45 AM\nif (ToTime(Time[0]) >= ToTime(9, 45, 00))\n{\n    // Calculate the bars ago value for the 9 AM bar for the current day\n    int barsAgo = CurrentBar - Bars.GetBar(new DateTime(2006, 12, 18, 9, 0, 0));\n    \n    // Print out the 9 AM bar closing price\n    Print(\"The close price on the 9 AM bar was: \" + Close[barsAgo].ToString());\n}\n```"
  },
  {
    "_id": "e5f9cfd898d1dddab905badbb6b05cf7ef1e7dece8939ff2c9b8f7e0245779a8",
    "_type": "desktopSdkDoc",
    "title": "GetBid()",
    "pathName": "getbid",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the bid price value at a selected absolute bar index value.\n\n{% callout type=\"note\" %}\n\n* This method does NOT return the current real-time bid price, but rather the historical / real-time bid price at the desired index. For obtaining the current real-time bid price, please use **GetCurrentBid()**.\n\n* This method returns expected values when 1 tick bid / ask stamped data is used and available from **your provider**.\n\n{% /callout %}\n\n## Method Return Value\n\nA **double** value that represents the bidding price at the desired bar index.\n\n## Syntax\n\n**Bars.GetBid(int index)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **index**\n* The absolute bar index value used\n\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // If the Highs of the two most recent bars are falling, place a long stop market order\n   // at the Ask price\n   if (Low[0] > Low[1] && Low[1] < Low[2])\n   {\n     EnterShortStopMarket(Bars.GetBid(CurrentBar));\n   }\n}\n```"
  },
  {
    "_id": "ea2a5d1ae94297ffe8c4be8787a10f6364ed43cf2d1a469680259a55489c430d",
    "_type": "desktopSdkDoc",
    "title": "GetClose()",
    "pathName": "getclose",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the closing price at the current bar index value.\n\n## Method Return Value\n\nA **double** value that represents the close price at the desired bar index.\n\n## Syntax\n\n**Bars.GetClose(int index)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **index**\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   base.OnRender(chartControl, chartScale);\n   // loop through only the rendered bars on the chart\n   for(int barIndex = ChartBars.FromIndex; barIndex &lt;= ChartBars.ToIndex; barIndex++)\n   {\n     // get the close price at the selected bar index value\n     double closePrice = Bars.GetClose(barIndex);\n     Print(\"Bar #\" + barIndex + \" closing price is \" + closePrice);\n   }\n}\n\n```"
  },
  {
    "_id": "8068904b4a3b2fc049ecb7539221b72546c37a9b3e8f7ebcc05833503bc53af6",
    "_type": "desktopSdkDoc",
    "title": "GetDayBar()",
    "pathName": "getdaybar",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a virtual historical Bar object that represents a trading day whose properties for open, high, low, close, time and volume can be accessed.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n1. The bar object returned is a \"virtual bar\" built from the underlying bar series and its configured session. Since the bar object is virtual, its property values are calculated based on session definitions contained in the trading day only. The returned bar object does NOT necessarily represent the actual day. For accessing a true \"Daily\" bar, please see use **AddDataSeries()** and use the **BarsPeriodType.Day** as the bars period.\n2. **GetDayBar()** should ONLY be used for accessing prior trading day data. To access current trading day data, use the **CurrentDayOHL()** method.\n{% /callout %}\n\n## Method Return Value\n\nA virtual bar object representing the current configured session. Otherwise null if there is insufficient intraday data.\n\n## Syntax\n\nThe properties below return double values:\n\n- **Bars.GetDayBar(int tradingDaysBack).Open**  \n- **Bars.GetDayBar(int tradingDaysBack).High**  \n- **Bars.GetDayBar(int tradingDaysBack).Low**  \n- **Bars.GetDayBar(int tradingDaysBack).Close**  \n\nThe property below returns a [DateTime](datetime) structure:\n\n- **Bars.GetDayBar(int tradingDaysBack).Time**  \n\nThe property below returns An **int** value:\n\n- **Bars.GetDayBar(int tradingDaysBack).Volume**  \n\n{% callout type=\"warning\" %}\n\nWarning: You must check for a null reference to ensure there is sufficient intraday data to build a trading day bar.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n- Parameter\n- Description\n\n---\n\n- **tradingDaysBack**\n- An int representing the number of the trading day to get OHLCV and time information from\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Check to ensure that sufficient intraday data was supplied\n    if(Bars.GetDayBar(1) != null)\n        Print(\"The prior trading day's close is: \" + Bars.GetDayBar(1).Close);\n}\n```"
  },
  {
    "_id": "6177a50b702ddd86b31b3c167db2fdbe074957b37ba44eb362a8c4423d0bbe01",
    "_type": "desktopSdkDoc",
    "title": "GetHigh()",
    "pathName": "gethigh",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the high price at the selected bar index value.\n\n## Method Return Value\n\nA **double** value that represents the high price at the desired bar index.\n\n## Syntax\n\n**Bars.GetHigh**(int index)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **index**\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   base.OnRender(chartControl, chartScale);\n   // loop through only the rendered bars on the chart\n   for(int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n   {\n     // get the high price at the selected bar index value\n     double highPrice = Bars.GetHigh(barIndex);\n     Print(\"Bar #\" + barIndex + \" high price is \" + highPrice);\n   }\n}\n```"
  },
  {
    "_id": "056b22e02e71525c48be502ed5fe89c467d467a2d00b900b7993860a9d239cf4",
    "_type": "desktopSdkDoc",
    "title": "GetLow()",
    "pathName": "getlow",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the low price at the selected bar index value.\n\n## Method Return Value\n\nA **double** value that represents the low price at the desired bar index.\n\n## Syntax\n\n**Bars.GetLow**(int index)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **index**\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   base.OnRender(chartControl, chartScale);\n   // loop through only the rendered bars on the chart\n   for(int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n   {\n     // get the low price at the selected bar index value\n     double lowPrice = Bars.GetLow(barIndex);\n     Print(\"Bar #\" + barIndex + \" low price is \" + lowPrice);\n   }\n}\n```"
  },
  {
    "_id": "17ef0479e26ea0ec6309ecbbe140fc39277b79b00aff89dff2451035001be4dd",
    "_type": "desktopSdkDoc",
    "title": "GetSessionEndTime()",
    "pathName": "getsessionendtime",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the daily bar session ending time stamp relative to the current bar index value.\n\n{% callout type=\"note\" %}\n\nThis method is ONLY intended for bars built from daily data. If called on intraday data, **GetSessionEndTime()** will return the [**Bars.GetTime()**](gettime) value.\n\n{% /callout %}\n\n## Method Return Value\n\nA DateTime structure that represents the daily bars ending time stamp at the desired bar index; intraday bars will return the time stamp at the current bar index value.\n\n## Syntax\n\n**Bars.GetSessionEndTime(int index)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **index**\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   base.OnRender(chartControl, chartScale);\n   // loop through only the rendered bars on the chart\n   for (int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n   {\n     // get the time stamp at the selected bar index value\n     DateTime timeValue = Bars.GetSessionEndTime(barIndex);\n     Print(\"Bar #\" + barIndex + \" time stamp is \" + timeValue);\n   }\n```"
  },
  {
    "_id": "0baf2302765583164476282b7813526a4cc865c2d339ba87e893b0cf8321f57f",
    "_type": "desktopSdkDoc",
    "title": "GetTime()",
    "pathName": "gettime",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the time stamp at the current bar index value.\n\n{% callout type=\"note\" %}\n\nThis method will return what is displayed in the chart's data box. For formatting purposes, the value returned is NOT guaranteed to be equal to the **[TimeSeries](timeseries)** value. If you are using daily bars and need the session end time, you should use **[Bars.GetSessionEndTime()](getsessionendtime)** instead.\n\n{% /callout %}\n\n## Method Return Value\n\nA DateTime structure that represents the time stamp at the desired bar index.\n\n## Syntax\n\n**Bars.GetTime(int index)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* index\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    base.OnRender(chartControl, chartScale);\n    // loop through only the rendered bars on the chart\n    for(int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n    {\n        // get the time stamp at the selected bar index value\n        DateTime timeValue = Bars.GetTime(barIndex);\n        Print(\"Bar #\" + barIndex + \" time stamp is \" + timeValue);\n    }\n}\n```"
  },
  {
    "_id": "09fc6a3e1fb248337deebf4805d5fbfbd98526778e571b0d7ad15bcb118c88dd",
    "_type": "desktopSdkDoc",
    "title": "GetVolume()",
    "pathName": "getvolume",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the volume at the selected bar index value.\n\n## Method Return Value\n\nA long value represents the volume at the desired bar index.\n\n## Syntax\n\n**Bars.GetVolume(int index)**\n\n## Parameters\n\n{% table %}\n\n* index\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   base.OnRender(chartControl, chartScale);\n   // loop through all the rendered bars on the chart\n   for(int barIndex = ChartBars.FromIndex; barIndex &lt;= ChartBars.ToIndex; barIndex++)\n   {\n     // get the volume value at the selected bar index value\n     long volumeValue = Bars.GetVolume(barIndex);\n     Print(\"Bar #\" + barIndex + \" volume value is \" + volumeValue);\n   }\n}\n```"
  },
  {
    "_id": "5cfabe4d16cd328df67b556d7fdbf62a269c9edfc6aa4f63a9cb304d946949d3",
    "_type": "desktopSdkDoc",
    "title": "IsFirstBarOfSession",
    "pathName": "isfirstbarofsession",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the current bar processing is the first bar updated in a trading session.\n\n{% callout type=\"note\" %}\n\nThis property always returns true on the very first bar processed (i.e., **CurrentBar** == 0). The represented time of the bar will NOT necessarily be equal to the trading hours start time (e.g., if you request 50 1-minute bars at 11:50:00 AM, the first bar processed of the session would be 11:00:00 AM). Loading a data series based on \"dates\" (Days or custom range) ensures that the first bar processed matches hours defined by the session template.\n\n{% /callout %}\n\n## Property Value\n\nThis property returns true if the bar is the first processed in a session; otherwise, false. This property is read-only.\n\n{% callout type=\"warning\" %}\n\nThis property will always return false on non-intraday bar periods (e.g., Day, Month, etc). For checking for new non-intraday bar updates, please see [IsFirstTickOfBar](isfirsttickofbar).\n\n{% /callout %}\n\n## Syntax\n\n**Bars.IsFirstBarOfSession**\n\n{% callout type=\"note\" %}\n\nFor checking at a specified bar index, please see [IsFirstBarOfSessionByIndex()](isfirstbarofsessionbyindex).\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Print the current bar number of the first bar processed for each session on a chart\n    if (Bars.IsFirstBarOfSession)\n        Print(string.Format(\"Bar number {0} was the first bar processed of the session at {1}.\", CurrentBar, Time[0]));\n}\n```"
  },
  {
    "_id": "9e27bb3883e848d2640fac8078f752173a951a5e7fb7f7e804260734be94a98a",
    "_type": "desktopSdkDoc",
    "title": "IsFirstBarOfSessionByIndex()",
    "pathName": "isfirstbarofsessionbyindex",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the selected bar index value is the first bar of a trading session.\n\n## Property Value\n\nThis property returns true if the bar is the first bar of a session; otherwise, false. This property is read-only.\n\n## Syntax\n\n**Bars.IsFirstBarOfSessionByIndex**(int **index**)\n\n## Warning\n\n{% callout type=\"warning\" %}\n\nThis property will always return false on non-intraday bar periods (e.g., Day, Month, etc).\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n---\n\n* **index**\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    base.OnRender(chartControl, chartScale);\n    // loop through only the rendered bars on the chart \n    for(int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n    {\n        // check if the rendered bar is the first bar of the trading session\n        if (Bars.IsFirstBarOfSessionByIndex(barIndex))\n        {\n            DateTime slotTimeAtBarIndex = chartControl.GetTimeBySlotIndex(barIndex);\n            Print(string.Format(\"Bar index {0} was the first bar of the session at slot time {1}.\", barIndex, slotTimeAtBarIndex));\n        }\n    }\n}\n```"
  },
  {
    "_id": "6c6c8ae67f9e4dc2f7fbc8a16e888da29cfc430ffa69c511a6d26946fbbb5c96",
    "_type": "desktopSdkDoc",
    "title": "IsLastBarOfSession",
    "pathName": "islastbarofsession",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the current bar processing is the last bar updated in a trading session.\n\n{% callout type=\"note\" %}\n\nNotes:  \n\n* This property will always return false on non-intraday bar periods (e.g., Day, Month, etc.)\n* When running Calculate.OnEachTick / OnPriceChange, this property will always return true on the most current real-time bar since it is the last bar that is updating in the trading session. If you need to find a bar which coincides with the session end time, please use the **SessionIterator.ActualSessionEnd**.\n{% /callout %}\n\n## Property Value\n\nThis property returns true if the bar is the last processed in a session; otherwise, false. This property is read-only.\n\n## Syntax\n\n**Bars.IsLastBarOfSession**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Print the current bar number of the first bar processed for each session on a chart\n    if(Bars.IsLastBarOfSession)\n        Print(string.Format(\"Bar number {0} was the last bar processed of the session at {1}.\", CurrentBar, Time[0]));\n}\n```"
  },
  {
    "_id": "0a65c1390ec532cde76ef8faef36399b0bc4771e6ff25a9deddc57b24a375c65",
    "_type": "desktopSdkDoc",
    "title": "IsResetOnNewTradingDay",
    "pathName": "isresetonnewtradingday",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the bars series is using the **Break EOD** data series property.\n\n## Property Value\n\nThis property returns true if the bars series should reset on a new trading day; otherwise, false. This property is read-only.\n\n## Syntax\n\n**Bars.IsResetOnNewTradingDay**\n\n{% callout type=\"note\" %}\n\nTip: This property can be helpful in determining how to amend new bar data when working with a **BarType**.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnDataPoint(Bars bars, double open, double high, double low, double close, DateTime time, long volume, bool isBar, double bid, double ask)\n{\n    // create a session iterator to keep track of session related information\n    if(SessionIterator == null)\n        SessionIterator = new SessionIterator(bars);\n    \n    // determine if the bars are in a new session\n    bool isNewSession = SessionIterator.IsNewSession(time, isBar);\n    \n    if(isNewSession)\n        SessionIterator.GetNextSession(time, isBar);\n    \n    // If bars are using \"Break end of day\", add a new bar for next session\n    if(bars.IsResetOnNewTradingDay && isNewSession)\n        AddBar(bars, open, high, low, close, time, volume);\n    else\n    {\n        // do something with existing bar values\n    }\n}\n```"
  },
  {
    "_id": "7e3d22d2251a04dd7b11eaa3ccad87377528ec3a2d5195b3406934f664bd0f1e",
    "_type": "desktopSdkDoc",
    "title": "IsTickReplay",
    "pathName": "istickreplay",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the bar series is using the **Tick Replay** data series property.\n\n## Property Value\n\nThis property returns true if the bar series is using tick replay; otherwise, false. This property is read-only.\n\n## Syntax\n\n**Bars.IsTickReplay**\n\n{% callout type=\"warning\" %}\n\nWarning: A Tick Replay indicator or strategy CANNOT use a **MarketDataType.Ask** or **MarketDataType.Bid** series. Please see [Developing for Tick Replay](developing_for__tick_replay) for more information.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprivate double askPrice;\nprotected override void OnMarketData(MarketDataEventArgs marketDataUpdate)\n{\n    if(Bars.IsTickReplay)\n    {\n        // if using tick replay, get the current ask price associated with the tick\n        askPrice = marketDataUpdate.Ask;\n    }\n    else // otherwise, get the real-time market data price during MarketDataType.Ask event\n        askPrice = marketDataUpdate.MarketDataType == MarketDataType.Ask ? marketDataUpdate.Price : double.MinValue;\n\n    // only print if a value is set\n    if(askPrice != double.MinValue)\n    {\n        Print(\"ask price: \" + askPrice);\n    }\n}\n```"
  },
  {
    "_id": "304a4f9e8f2cb2f584057c99c800d5d7cabc4d685b2025b5d7e821549d530e71",
    "_type": "desktopSdkDoc",
    "title": "PercentComplete",
    "pathName": "percentcomplete",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a value indicating the percentage complete of the real-time bar processing.\n\n{% callout type=\"note\" %}\n\nNotes:  \n\n1. Since a historical bar is complete, values during State.Historical should be ignored (also the case with **TickReplay** bars).  \n2. Some [BarsTypes](bars_type) may not be compatible with the **PercentComplete** property. In these cases, a value of 0 always returns (e.g., **Range**, **Renko**, **Point & Figure**, **Kagi**, **LineBreak**, and some other 3rd party bars types).\n{% /callout %}\n\n## Property Value\n\nA **double** value representing a percent e.g. a value of .5 indicates the bar was at 50%. This property is read-only.\n\n## Syntax\n\n**Bars.PercentComplete**\n\n{% callout type=\"note\" %}\n\nTip: If you are developing a custom **BarsType**, please use the [GetPercentComplete()](getpercentcomplete) method used to calculate the value returned by **PercentComplete**.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    if(State == State.Realtime)\n    {\n        Draw.TextFixed(this, \"barstatus\", Bars.PercentComplete.ToString(\"P2\"), TextPosition.BottomRight);\n    }\n}\n```"
  },
  {
    "_id": "10cdc8baff71fe88fff8c3dd0c8c67e36b337e97ea003f5e0d3455fe9437ec98",
    "_type": "desktopSdkDoc",
    "title": "TickCount",
    "pathName": "tickcount",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the total number of ticks of the current bar processing.\n\n{% callout type=\"note\" %}\n\nNote: For historical usage, you must use **Calculate.OnEachTick** with [**TickReplay**](developing_for__tick_replay) enabled; otherwise a value of 1 will be returned.\n\n{% /callout %}\n\n## Property Value\n\nA long value that represents the total number of ticks of the current bar.\n\n## Syntax\n\n**Bars.TickCount**\n\n## Examples\n\n```csharp\n// Prints the tick count to the output window\nPrint(\"The tick count of the current bar is \" + **Bars.TickCount**.ToString());\n```"
  },
  {
    "_id": "fb86155bb558f86361ff7a8f975ed16a163bbaec22dbdbae9b3d68e95eed004e",
    "_type": "desktopSdkDoc",
    "title": "ToChartString()",
    "pathName": "tochartstring",
    "parent": "bars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the bars series as a formatted string, including the **Instrument.FullName**, **BarsPeriod** Value, and **BarsPeriodType** name.\n\n{% callout type=\"note\" %}\n\nNote: To obtain a return value which matches the user configured **ChartBars Label property**, please see the **ChartBars.ToChartString()** method.\n\n{% /callout %}\n\n## Syntax\n\n**Bars.ToChartString()**\n\n## Return Value\n\nA **string** value that represents the bars series.\n\n## Parameters\n\nThis method does not accept any parameters.\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // print the chart string on start up\n   if(CurrentBar == 0)\n     Print(Bars.ToChartString()); // ES 09-15 (60 Minute)      \n}\n```"
  },
  {
    "_id": "8556ab2559634a19bd1d144dc844a0da5a0716a0d671e3b4bb2e36c23a2fe8a8",
    "_type": "desktopSdkDoc",
    "title": "Bars",
    "pathName": "bars",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents the data returned from the historical data repository. The Bars object contain several methods and properties for working with bar data.\n\n{% callout type=\"warning\" %}\n\nThe Bars object and its member should NOT be accessed within the **OnStateChange()** method before the State has reached State.DataLoaded\n\n{% /callout %}\n\n## Additional Access Information\n\nMembers within the Bars class can be accessed without a null reference check in the OnBarUpdate() event handler. When the OnBarUpdate() event is triggered, there will always be a Bar object which holds the method or property. Should you wish to access these members elsewhere, check for null reference first. e.g. if (Bars != null)\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [BarsSinceNewTradingDay](barssincenewtradingday)\n* Number of bars that have elapsed since the start of the trading day\n\n---\n\n* [GetAsk()](getask)\n* Returns the Ask price\n\n---\n\n* [GetBar()](getbar)\n* Returns the bar index based on time\n\n---\n\n* [GetBid()](getbid)\n* Returns the Bid price\n\n---\n\n* [GetClose()](getclose)\n* Returns the closing price\n\n---\n\n* [GetDayBar()](getdaybar)\n* Returns a Bar object that represents a trading day whose properties for open, high, low, close, time and volume can be accessed.\n\n---\n\n* [GetHigh()](gethigh)\n* Returns the High price\n\n---\n\n* [GetLow()](getlow)\n* Returns the Low price\n\n---\n\n* [GetOpen()](getopen)\n* Returns the opening price\n\n---\n\n* [GetTime()](gettime)\n* Returns the time\n\n---\n\n* [GetVolume()](getvolume)\n* Returns the volume\n\n---\n\n* [IsFirstBarOfSession](isfirstbarofsession)\n* Returns true if the bar is the first bar of a session\n\n---\n\n* [IsFirstBarOfSessionByIndex()](isfirstbarofsessionbyindex)\n* Returns true if the bar is the first bar of a session\n\n---\n\n* [IsLastBarOfSession](islastbarofsession)\n* Returns true if the bar is the last bar of a session\n\n---\n\n* [IsResetOnNewTradingDay](isresetonnewtradingday)\n* Returns true if the chart bars should reset on a new trading day\n\n---\n\n* [IsTickReplay](istickreplay)\n* Returns true if the bars are using tick replay\n\n---\n\n* [PercentComplete](percentcomplete)\n* Value indicating the completion percent of a bar\n\n---\n\n* [TickCount](tickcount)\n* Total number of ticks of the current bar\n\n---\n\n* [ToChartString()](tochartstring)\n* Returns the bars series as a string formatted as the series would be displayed in the user interface\n{% /table %}"
  },
  {
    "_id": "cc57fc1903e444cf6a726490b43b27ee9f87facc037f86872201847c565b45fb",
    "_type": "desktopSdkDoc",
    "title": "Charts",
    "pathName": "chart",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The following section covers information related to accessing chart related data, such as **ChartControl**, **ChartBars**, **ChartScales**, and **ChartPanels**, and advanced Indicator **Rendering**.\n\n## In this section\n\n{% table %}\n\n---\n\n* **ChartBars**\n\n* The Chart's Primary Data Series which the NinjaScript object is running\n\n---\n\n* **ChartControl**\n* The entire grid hosting the chart including the X-axis, additional panels, and chart related properties\n\n---\n\n* **ChartPanel**\n* The Panel that the indicator object is running\n\n---\n\n* **ChartScale**\n* The Y-axis of the indicator object's panel\n{% /table %}\n\nA chart's objects can be broken down into the four following areas:\n\n![guichart.png](guichart.png)"
  },
  {
    "_id": "8556c4f775667fc4aeb3477f45a6e3e24c7bbdcc7a37062e5f689fcdd406cffe",
    "_type": "desktopSdkDoc",
    "title": "AxisXHeight",
    "pathName": "axisxheight",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nMeasures the distance (in pixels) between the x-axis and the top of the horizontal scroll bar near the bottom of the chart.\n\n### Property Value\n\nA double representing the number of pixels separating the x-axis and the top of the horizontal scroll bar on the chart.\n\n### Syntax\n\n**ChartControl.AxisXHeight**\n\n### Example\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n     // Print the number of pixels between the x-axis and the top of the horizontal scrollbar\n     double height = chartControl.AxisXHeight;\n     Print(height);\n}\n```\n\nBased on the image below, AxisXHeight reveals that the space between the x-axis and the top of the horizontal scrollbar is 31 pixels on this chart.\n\n![ChartControl_AxisXHeight](chartcontrol_axisxheight.png)"
  },
  {
    "_id": "86252ac4bc1f434d14db9e0942a7c7b4b96b862ed7865be3fbff5abf5b2d01f3",
    "_type": "desktopSdkDoc",
    "title": "AxisYLeftWidth",
    "pathName": "axisyleftwidth",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nMeasures the distance (in pixels) between the y-axis and the left edge of a chart.\n\n## Property Value\n\nA double representing the number of pixels separating the y-axis and the left edge of the chart.\n\n## Syntax\n\n**ChartControl.AxisYLeftWidth**\n\n## Example\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n     // Print the number of pixels between the y-axis and the left edge of the chart\n     double leftWidth = chartControl.AxisYLeftWidth;\n     Print(leftWidth);\n}\n```\n\nBased on the image below, AxisYLeftWidth reveals that the space between the y-axis and the left edge of the chart is 53 pixels on this chart.\n\n![ChartControl_AxisYLeftWidth](chartcontrol_axisyleftwidth.png)\n\n{% callout type=\"note\" %}\n\nWhen there are no left-justified data series on a chart, AxisYLeftWidth will return 0, as there will be no space between the y-axis and the left margin.\n\n{% /callout %}"
  },
  {
    "_id": "ec4b01cd6486b748f9f252c78b3e451ccd604f3025228c2f40dc0fbefaaae7c4",
    "_type": "desktopSdkDoc",
    "title": "AxisYRightWidth",
    "pathName": "axisyrightwidth",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nMeasures the distance (in pixels) between the y-axis and the right edge of a chart.\n\n## Property Value\n\nA double representing the number of pixels separating the y-axis and the right edge of the chart.\n\n## Syntax\n\n**<`chartcontrol`>.AxisYRightWidth**\n\n## Example\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n     // Print the number of pixels between the y-axis and the right edge of the chart\n     double rightWidth = chartControl.AxisYRightWidth;\n     Print(rightWidth);\n}\n```\n\nBased on the image below, AxisYRightWidth reveals that the space between the y-axis and the right edge of the chart is 53 pixels on this chart.\n\n![ChartControl_AxisYRightWidth](chartcontrol_axisyrightwidth.png)\n\n{% callout type=\"note\" %}\n\nWhen there are no right-justified data series on a chart, AxisYRightWidth will return 0, as there will be no space between the y-axis and the right edge.\n\n{% /callout %}"
  },
  {
    "_id": "2777a4a406a3feed7a3a68331ce35a1456873d07b5f379784f74042899be78a6",
    "_type": "desktopSdkDoc",
    "title": "BarMarginLeft",
    "pathName": "barmarginleft",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA hard-coded minimum bar margin value, set to 8 pixels, which can be used as a base value when creating custom Chart Styles.\n\n## Property Value\n\nA value representing the minimum margin applied to the left edge of bars. This value is hard-coded to 8 pixels, and it can be used as a base value when setting the bar margin in custom [Chart Styles](chart_style).\n\n## Syntax\n\n**ChartControl.BarMarginLeft**\n\n## Example\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n     // Print the number of pixels maintained as a margin to the left of bars\n     double barMargin = chartControl.BarMarginLeft;\n     Print(barMargin);\n}\n```\n\nBased on the image below, BarMarginLeft reveals that the minimum margin maintained to the left of each bar is 8 pixels on this chart.\n\n![ChartControl_BarMarginLeft](chartcontrol_barmarginleft.png)"
  },
  {
    "_id": "d8115d96476932bf4364cff4994313eeecdeaaf65833f39151cac1b2a30fc724",
    "_type": "desktopSdkDoc",
    "title": "BarSpacingType",
    "pathName": "barspacingtype",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the type of bar spacing used for the primary [Bars](bars) object on the chart.\n\n## Property Value\n\nAn enum representing one of the values below:\n\n{% table %}\n*\n*\n---\n\n* EquidistantSingle\n* Indicates Equidistant Bar Spacing is used, and only one Bars object exists on the chart\n\n---\n\n* EquidistantMulti\n* Indicates Equidistant Bar Spacing is used, and more than one Bars objects exist on the chart\n\n---\n\n* TimeBased\n* Indicates Time-Based bar spacing is used\n{% /table %}\n\n## Syntax\n\n**chartcontrol.BarSpacingType**\n\n## Example\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the type of bar spacing used on the chart\n   Print(chartControl.BarSpacingType);\n}\n```\n\nBased on the image below, BarSpacingType confirms that there are multiple Bars objects configured on the chart, and that the chart is set to Equidistant Bar Spacing:\n\n![ChartControl_BarSpacingType](chartcontrol_barspacingtype.png)"
  },
  {
    "_id": "3c4f6030a5de481a5705a4a83e82bd69ee70b8802ddfbbfab463846d2280888e",
    "_type": "desktopSdkDoc",
    "title": "BarWidthArray",
    "pathName": "barwidtharray",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn array containing the values of the [BarWidth](chartcontrol_barwidth) properties of all Bars objects applied to the chart.\n\n## Property Value\n\nAn array of double variables containing the values of the BarWidth properties of Bars objects on the chart.\n\n## Syntax\n\n**ChartControl.BarWidthArray[]**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Assign BarWidthArray to a new array\n   double[] barWidths = chartControl.BarWidthArray;\n \n   double referenceWidth = barWidths[0];\n \n   // Trigger an alert if bar widths on the chart differ\n   foreach (double width in barWidths)\n   {\n       if (width != referenceWidth)\n           Alert(\"mismatchWidths\", Priority.Low, \"Bar widths on the chart do not match!\", \" \", 20, Brushes.White, Brushes.Black);\n   }\n}\n```"
  },
  {
    "_id": "a87720808cb749a3562b4766bc29836ef9116d956d21b2ded030b45c8bccdb5c",
    "_type": "desktopSdkDoc",
    "title": "CanvasZoomState",
    "pathName": "canvaszoomstate",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the current state of the Zoom tool on the chart. This property reveals the state of the tool while it is in use, and does not indicate a chart is zoomed in on or not. As soon as a zoom action is completed, the tool is considered to be no longer in use.\n\n## Property Value\n\nAn enum representing the state of the Zoom tool on the chart. Possible values are listed below:\n\n{% table %}\n\n* State\n* Description\n\n---\n\n* None\n* The Zoom tool is not currently being used\n\n---\n\n* Selected\n* The Zoom tool is selected, but has not yet been used to zoom in\n\n---\n\n* DrawingRectangle\n* The Zoom tool is currently in use (User is currently drawing the rectangle in which to zoom)\n{% /table %}\n\n## Syntax\n\n**<`chartcontrol`>.CanvasZoomState**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    CanvasZoomState zoomState = chartControl.CanvasZoomState;\n\n    // Trigger an alert while a user is zooming in on a chart\n    if (zoomState == CanvasZoomState.DrawingRectangle)\n        Alert(\"zoomAlert\", Priority.Medium, \"Make sure to zoom in on the entire chart pattern!\", \" \", 60, Brushes.White, Brushes.Black);\n}\n```\n\nBased on the image below, CanvasZoomState confirms that the Zoom rectangle is currently being drawn:\n\n![ChartControl_CanvasZoomState](chartcontrol_canvaszoomstate.png)"
  },
  {
    "_id": "84cdd7644b6eba3e43b975ec83728e6094d83caabead8cb1ed7beb91394f2539",
    "_type": "desktopSdkDoc",
    "title": "BarWidth",
    "pathName": "barwidth",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nMeasures the value of the **bar width** set for the primary Bars object on the chart.\n\n{% callout type=\"note\" %}\n\nThis property value is not stated in pixels. To obtain the pixel-width of bars on the chart, use **GetBarPaintWidth()** instead.\n\n{% /callout %}\n\n## Property Value\n\nA double representing the value of the bar width.\n\n## Syntax\n\n**<`chartcontrol`>.BarWidth**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    double barWidth = chartControl.BarWidth;\n\n    // Prints the width of bars on the chart\n    Print(barWidth);\n}\n```\n\nBased on the image below, BarWidth reveals that the bars on the chart are 4.02 pixels wide.\n\n![ChartControl_BarWidth](chartcontrol_barwidth.png)"
  },
  {
    "_id": "75e84f20cc44339e09c7c722d233f826cfcbf8aa6e13dbafd5162068a97250ac",
    "_type": "desktopSdkDoc",
    "title": "Strategies",
    "pathName": "strategies",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of strategies configured on the chart.\n\n## Property Value\n\nA **ChartObjectCollection** of **StrategyRenderBase** objects containing information on all configured strategies on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.Strategies**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the number of strategies configured on the chart\n   if (chartControl.Strategies.Count > 0) \n           Print(chartControl.Strategies[0].Name);\n}\n```"
  },
  {
    "_id": "97df83fb06bbf7a4392974a48e872ab332a8f3b79203046a34d55c4f4389a3bd",
    "_type": "desktopSdkDoc",
    "title": "GetSlotIndexByX()",
    "pathName": "getslotindexbyx",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the slot index relative to the chart control corresponding to a specified x-coordinate.\n\n{% callout type=\"note\" %}\n\n* A \"Slot\" is used in Equidistant **bar spacing** and represents a position on the chart canvas background which may or may not contain a bar. The concept of \"Slots\" does NOT exist on a **TimeBased** bar spacing type.  \n* If you are looking for information on a bar series, please see [ChartBars.GetBarIdxByX()](chartbars_getbaridxbyx).  \n* Since the slot index is based on the chart canvas, the value returned by **GetSlotIndexByX()** can be expected to change as new bars are painted, or as the chart is scrolled backward or forward on the x-axis.\n{% /callout %}\n\n## Method Return Value\n\nA double representing a slot index; returns -1 on a time based bar spacing type.\n\n## Syntax\n\n**<`chartcontrol`>.GetSlotIndexByX(int x)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* x\n* An int used to determine a slot index\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Find the index of the bar painted at x-coordinate 35\n    double slotIndex = chartControl.GetSlotIndexByX(35);\n    \n    // Print the slot index of the specified time\n    Print(slotIndex);\n}\n```"
  },
  {
    "_id": "0f20d88ad6eb84616129c4f43687bd032a727b9e40736b588b0f4b9525e198bf",
    "_type": "desktopSdkDoc",
    "title": "GetTimeByX()",
    "pathName": "gettimebyx",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a time value related to the primary **Bars** slot index at a specified x-coordinate relative to the **ChartControl**.\n\n{% callout type=\"note\" %}\n\nSince the time is based upon a coordinate of the chart canvas, the value returned by **GetTimeByX()** can be expected to change as new bars are painted on the chart, or as the chart is scrolled backward or forward on the x-axis.\n\n{% /callout %}\n\n## Method Return Value\n\nA **DateTime** object corresponding to a slot index at a specified x-coordinate.\n\n## Syntax\n\n**<`chartcontrol`>.GetTimeByX(int x)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* x\n* The x-coordinate used to find a time value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Find the timestamp of the bar at x-coordinate 100\n   DateTime slotTime = chartControl.GetTimeByX(100);\n \n   // Print the date of slotTime\n   Print(slotTime);\n}\n```"
  },
  {
    "_id": "0913a4eb0cdf3658b6b356ab4d3292fad7dbada52aca251b14083f1a21ddda03",
    "_type": "desktopSdkDoc",
    "title": "GetXByTime()",
    "pathName": "getxbytime",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the chart-canvas x-coordinate of the slot index of the primary **Bars** object corresponding to a specified time.\n\n{% callout type=\"note\" %}\n\nSince the time correlates with a specific bar index, and since bars move on the chart canvas as new bars are painted, the value returned by **GetXByTime()** can be expected to change as new bars are painted on the chart, or as the chart is scrolled backward or forward on the x-axis.\n\n{% /callout %}\n\n## Method Return Value\n\nAn int representing a chart-canvas x-coordinate.\n\n## Syntax\n\n**<`chartcontrol`>.GetXByTime(DateTime time)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* time\n* A [DateTime](datetime) object used to determine an x-coordinate\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   DateTime timeToCheck = new DateTime(2017, 8, 6, 11, 0, 0);\n\n   // Find the chart-canvas x-coordinate of the bar at the specified time\n    int xCoordinate = chartControl.GetXByTime(timeToCheck);\n\n   // Print the x-coordinate value\n   Print(xCoordinate);\n}\n```"
  },
  {
    "_id": "324a1a79e0915fdabc98abf72403851d7ba4566e64a907706948a01f23aa3abb",
    "_type": "desktopSdkDoc",
    "title": "TimePainted",
    "pathName": "timepainted",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the range of time in which bars are painted on the visible chart canvas.\n\n## Property Value\n\nA TimeSpan measuring the difference between the earliest and latest times at which bars are painted on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.TimePainted**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print a message if less than three hours' worth of data is painted on the chart canvas\n   if(chartControl.TimePainted.Hours < 3)\n       Print(String.Format(\"It is recommended to view at least three hours worth of data on your chart with this indicator. You are currently viewing {0}\", chartControl.TimePainted));\n}\n```\n\n{% callout type=\"note\" %}\n\nNote: TimePainted is intended to be used when Non-Equidistant (time-based) bar spacing is enabled on the chart. Otherwise, it will have a value of 0.\n\n{% /callout %}"
  },
  {
    "_id": "8556ab2559634a19bd1d144dc844a0da5a0716a0d671e3b4bb2e36c23a2fe8a8",
    "_type": "desktopSdkDoc",
    "title": "Bars",
    "pathName": "bars",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents the data returned from the historical data repository in relation to the primary **ChartBars** object configured on the chart. See also [Bars](bars).\n\n## Property Value\n\nA **Bars** object\n\n## Syntax\n\n**ChartBars.Bars**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if(ChartBars != null && ChartBars.Bars != null)\n   {\n     Print(\"The configured bars period type represented on the chart is\" + ChartBars.Bars.BarsPeriod.BarsPeriodType);\n   }\n}\n```"
  },
  {
    "_id": "6c35493a2b937829c9815c39e23af964bc84e5430a7dc104c700bbc0de2b59e3",
    "_type": "desktopSdkDoc",
    "title": "Count",
    "pathName": "count",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe total number of **ChartBars** in the charts primary data series.\n\n## Property Value\n\nAn **int** value representing the total number of bars.\n\n## Syntax\n\n**ChartBars.Count**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if(ChartBars != null)\n   {\n     Print(\"ChartBars contain \" + ChartBars.Count + \" bars\");\n     //Output:  ChartBars contain 73 bars\n   }\n}\n\n```"
  },
  {
    "_id": "04487aee7bf758381044f0ce61a9e62d055388fdcdb3e81fd1e69d009543d991",
    "_type": "desktopSdkDoc",
    "title": "FromIndex",
    "pathName": "fromindex",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn index value representing the first bar rendered on the chart. See also **ToIndex**.\n\n{% callout type=\"note\" %}\n\nThis value is NOT the first value that exists on the **ChartBars**, but rather the first bar index that is within the viewable range of the chart canvas area. This value changes as the user interacts with the **ChartControl** time-scale (x-axis).\n\n{% /callout %}\n\n## Property Value\n\nAn int representing the first bar index painted on the chart.\n\n## Syntax\n\n**ChartBars.FromIndex**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (ChartBars != null)\n   {\n     // loop through all of the viewable range of the chart\n     for (int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n     {\n         // print the High value for each index within the viewable range\n         Print(High.GetValueAt(barIndex));\n     }\n   }\n}\n```"
  },
  {
    "_id": "9446617b7e22085324cfed925c054f13e928678c5dae2c91cbafaa9f85857cdb",
    "_type": "desktopSdkDoc",
    "title": "GetBarIdxByTime()",
    "pathName": "getbaridxbytime",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the **ChartBars** index value calculated from the time parameter provided.\n\n## Method Return Value\n\nAn **int** representing the bar index value at a specific time.\n\n## Syntax\n\n**ChartBars.GetBarIdxByTime(ChartControl chartControl, DateTime time)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **chartControl**\n* The **ChartControl** object used to determine the chart's time axis\n\n---\n\n* **time**\n* The **DateTime** value used to convert to a ChartBar index value\n{% /table %}\n\n## Examples\n\n```csharp\n\nprotected override void OnBarUpdate()\n{\n   if (ChartBars != null)\n   {\n     Print(ChartBars.GetBarIdxByTime(ChartControl, Time[0]));  \n   }\n}\n```"
  },
  {
    "_id": "41cf0f0f4e5291d663eea890dc16d2afccde5f9abd23b7467bd917c8194b1ad9",
    "_type": "desktopSdkDoc",
    "title": "GetBarIdxByX()",
    "pathName": "getbaridxbyx",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the **ChartBars** index value at a specified x-coordinate relative to the ChartControl.\n\n## Method Return Value\n\nAn **int** value representing the bar index.\n\n## Syntax\n\n**ChartBars.GetBarIdxByX(ChartControl chartControl, int x)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **chartControl**\n* The **ChartControl** object used to determine the chart's time axis\n\n---\n\n* **x**\n* The x-coordinate used to find a bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // get the users mouse down point and convert to device pixels for DPI accuracy\n   int mousePoint = chartControl.MouseDownPoint.X.ConvertToHorizontalPixels(chartControl.PresentationSource);\n   \n   // convert mouse point to bar index\n   int barIdx = ChartBars.GetBarIdxByX(chartControl, mousePoint);\n   \n   Print(\"User clicked on Bar #\" + barIdx);\n}\n```"
  },
  {
    "_id": "9580a46312d4f08cc7d6751615994c5c133f2149bf84c0efac66f0279a68e500",
    "_type": "desktopSdkDoc",
    "title": "GetTimeByBarIdx()",
    "pathName": "gettimebybaridx",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the **ChartBars** time value calculated from a bar index parameter provided.\n\n## Method Return Value\n\nA **DateTime** struct representing a bar time value at a specific bar index value.\n\n## Syntax\n\n**ChartBars.GetTimeByBarIdx(ChartControl chartControl, int barIndex)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **chartControl**\n* The **ChartControl** object used to determine the chart's time axis\n\n---\n\n* **barIndex**\n* An **int** value representing a bar index used to convert to a **ChartBar** index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   if (ChartBars != null)\n   {\n     Print(ChartBars.GetTimeByBarIdx(ChartControl, 50)); //8/11/2015 4:30:00 AM\n   }\n}\n```"
  },
  {
    "_id": "320e00e73a7d24a9a44cde87e98d150e10e72b05ccffb74e7332354fdd85c5e5",
    "_type": "desktopSdkDoc",
    "title": "Panel",
    "pathName": "panel",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA zero-based index value that represents the **ChartPanel** where the **ChartBars** reside.\n\n{% callout type=\"note\" %}\n\nThis is NOT the same as the **PanelUI** property displays on the Chart's **Data Series** menu. A **ChartBars.Panel** value of 0 represents the first panel on the chart.\n\n{% /callout %}\n\n## Property Value\n\nAn int indicating the panel of the **ChartBars**.\n\n## Syntax\n\n**Bars.Panel**\n\n## Examples\n\n   // Output:  ChartBars reside on panel index: 0"
  },
  {
    "_id": "96adb92452863058fa1616efcc89c6e7c92a0c49148dfbd3e127ce829a45406e",
    "_type": "desktopSdkDoc",
    "title": "Properties",
    "pathName": "properties",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents various **ChartBar** properties configured from the Chart's **Data Series** menu.\n\n{% callout type=\"note\" %}\n\nThe properties on this page indicate what have been configured by the user, and is NOT necessarily representative of what is actually contained on the chart. For example, a user may have requested 120 days of chart data; however, only 60 days of bar data are actually returned from their provider.\n\n{% /callout %}\n\n![ChartBars_DataSeries](chartbars_dataseries.png)\n\n{% callout type=\"warning\" %}\n\nThese are UI properties which are designed to be set by a user. Attempting to modify these values through a custom script is NOT guaranteed to take effect.\n\n{% /callout %}\n\n## Properties\n\n{% table %}\n\n* Property\n* Description\n\n---\n\n* AutoScale\n* A bool indicating if the Chart Data Series participates in the chart's auto scaling methods\n\n---\n\n* BarsBack\n* An int representing the Chart's Data Series configured \"Bars to load\" when the RangeType.Bars is selected\n\n---\n\n* BarsPeriod\n* The **BarsPeriod** object configured for Chart's Data Series\n\n---\n\n* CenterPriceOnScale\n* A bool indicating if the Chart's Data Series should center the last traded price on the chart scale\n\n---\n\n* ChartStyle\n* The **ChartStyle** object configured for the Chart's Data Series\n\n---\n\n* ChartStyleType\n* A **ChartStyleType** enum indicating the type of chart style configured. System defaults include:\n  * **ChartStyleType.Box**\n  * **ChartStyleType.CandleStick**\n  * **ChartStyleType.LineOnClose**\n  * **ChartStyleType.OHLC**\n  * **ChartStyleType.PointAndFigure**\n  * **ChartStyleType.KagiLine**\n  * **ChartStyleType.OpenClose**\n  * **ChartStyleType.Mountain**\n\n---\n\n* DaysBack\n* An int representing the Chart's Data Series configured \"Days to load\" when the RangeType.Days is selected\n\n---\n\n* DisplayInDataBox\n* A bool indicating if the Chart's Data Series value should display in the Chart's **Data Box**\n\n---\n\n* DisplayName\n* A string representing the Chart's Data Series instrument and period\n\n---\n\n* From\n* A DateTime representing the Chart's Data Series configured \"Start Date\" when the RangeType.CustomRange is configured.\n\n---\n\n* Instrument\n* A string representing the Chart's Data Series instrument\n\n---\n\n* IsStableSession\n* A bool indicating the Chart's Data Series **Break EOD** option is configured\n\n---\n\n* IsTickReplay\n* A bool indicating the Chart's Data Series **Tick Replay** option is configured\n\n---\n\n* Label\n* A string representing the configured Chart's Data Series \"Label\"\n\n---\n\n* LongExecutionBrush\n* A **Brush** object representing the Chart's Data Series \"Color for execution - buy\" brush configured\n\n---\n\n* PaintPriceMarker\n* A bool indicating the Chart's Data Series Price Marker \"Visible\" option is configured\n\n---\n\n* Panel\n* An int indicating which Chart's Data Series \"Panel\" the **ChartBars** are configured\n\n---\n\n* PlotExecutions\n* A **ChartExecutionStyle** enum representing \"Plot executions\" option. Possible values include:\n  * **ChartExecutionStyle.DoNotPlot**\n  * **ChartExecutionStyle.MarkersOnly**\n  * **ChartExecutionStyle.TextAndMarker**\n\n---\n\n* PositionPenLoser\n* A **Stroke** object representing the Chart's Data Series \"NinjaScript strategy unprofitable trade line\"\n\n---\n\n* PositionPenWinner\n* A **Stroke** object representing the Chart's Data Series \"NinjaScript strategy profitable trade line\"\n\n---\n\n* PriceMarker\n* A **PriceMarker** object representing various brushes used to paint the Chart's Data Series \"Price marker\"\n\n---\n\n* RangeType\n* A **RangeType** enum indicating the \"Load data based on\" value configured on the Data Series. Possible values include:\n  * **RangeType.Bars**\n  * **RangeType.Days**\n  * **RangeType.CustomRange**\n\n---\n\n* ScaleJustification\n* A **ScaleJustification** enum indicating the \"Scale justification\" option configured on the Chart's Data Series. Possible values include:\n  * **ScaleJustification.Right**\n  * **ScaleJustification.Left**\n  * **ScaleJustification.Overlay**\n\n---\n\n* ShortExecutionBrush\n* A **Brush** object representing the Chart's Data Series \"Color for execution - sell\" brush configured\n\n---\n\n* ShowGlobalDrawObjects\n* A bool indicating the Chart's Data Series \"Show global draw object\" option is configured\n\n---\n\n* To\n* A DateTime representing the configured \"End Date\" used with any RangeType\n\n---\n\n* TradingHoursBreakLine\n* A **TradingHoursBreakLine** object representing the **stroke** used and **TradingHoursBreakLineVisible** enum used for the Chart's Data Series \"Trading hours break line\". Possible **TradingHoursBreakLine.TradingHoursBreakLineVisible** values include:\n  * **TradingHoursBreakLineVisible.AllSessions**\n  * **TradingHoursBreakLineVisible.EodOnly**\n  * **TradingHoursBreakLineVisible.Off**\n\n---\n\n* TradingHoursData\n* A string representing the Chart's Data Series configured \"Trading hours\" option\n{% /table %}"
  },
  {
    "_id": "fb86155bb558f86361ff7a8f975ed16a163bbaec22dbdbae9b3d68e95eed004e",
    "_type": "desktopSdkDoc",
    "title": "ToChartString()",
    "pathName": "tochartstring",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a formatted string representing the **ChartBars.Properties.Label** property, **BarsPeriod** Value, and **BarsPeriodType** name.\n\n{% callout type=\"note\" %}\n\nThe property returned is dependent on a user configured **Data Series** property, and results may return differently than expected. See also **Bars.ToChartString()** for a return value which is not subject to user-defined variables.\n\n{% /callout %}\n\n## Syntax\n\n**ChartBars.ToChartString()**\n\n## Return Value\n\nA **string** value that represents the ChartBars label and configured bars period.\n\n## Parameters\n\nThis method does not accept any parameters.\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (ChartBars != null)\n     Print(ChartBars.ToChartString()); // My Favorite Instrument (1 Minute)\n}\n```"
  },
  {
    "_id": "daa346b103cb8dd7dc2950e99545d35b03df708db8d6512148e3950d3bdde9e6",
    "_type": "desktopSdkDoc",
    "title": "ToIndex",
    "pathName": "toindex",
    "parent": "chartbars",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn index value representing the last bar rendered on the chart. See also [FromIndex](chartbars_fromindex).\n\n{% callout type=\"note\" %}\n\nThis value is NOT the last value that exists on the **ChartBars**, but rather the last bar index that is within the viewable range of the chart canvas area. This value changes as the user interacts with the **ChartControl** time-scale (x-axis).\n\n{% /callout %}\n\n## Property Value\n\nAn int representing the last bar index painted on the chart.\n\n## Syntax\n\n**ChartBars.ToIndex**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (ChartBars != null)\n   {\n     // loop through all of the viewable range of the chart\n     for (int barIndex = ChartBars.FromIndex; barIndex <= ChartBars.ToIndex; barIndex++)\n     {\n         // print the High value for each index within the viewable range\n         Print(High.GetValueAt(barIndex));\n     }\n   }\n```"
  },
  {
    "_id": "a013855b6655569959a0c95bed058a1207083074f462865892737665f31c5ff8",
    "_type": "desktopSdkDoc",
    "title": "ChartBars",
    "pathName": "chartbars",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The **ChartBars** class provides GUI access related methods and properties to the primary bars series configured on the Chart through the [Data Series](working_with_price_data) menu. For data access information related to the NinjaScript input's bars series, please use the [Bars Series](bars) object (or the [BarsArray](barsarray) for multi-series input).\n\n{% callout type=\"note\" %}\n\nA ChartBars object will ONLY exist should the hosting NinjaScript type be loaded through a [Chart](chart). For example, a Strategy would have access to a ChartBars property when running on a Chart, but would NOT when loaded through the [Strategies Grid](strategies_tab2) or [Strategy analyzer](strategy_analyzer).\n\n{% /callout %}\n\n![ChartBars](chartbars.png)\n\n{% callout type=\"warning\" %}\n\nIt is crucial to check for object references before accessing the ChartBars otherwise possible null reference errors can be expected depending on where the NinjaScript object was started. See example below.\n\n{% /callout %}\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [Bars](chartbars_bars)\n* Data returned from the historical data repository.\n\n---\n\n* [Count](chartbars_count)\n* The total number of ChartBars that exist on the chart.\n\n---\n\n* [FromIndex](chartbars_fromindex)\n* An index value representing the first bar painted on the chart.\n\n---\n\n* [GetBarIdxByTime()](chartbars_getbaridxbytime)\n* An ChartBar index value calculated from a time value on the chart.\n\n---\n\n* [GetBarIdxByX()](chartbars_getbaridxbyx)\n* Returns the ChartBar index value at a specified x-coordinate relative to the ChartControl.\n\n---\n\n* [GetTimeByBarIdx()](chartbars_gettimebybaridx)\n* The ChartBars time value calculated from a bar index value on the chart.\n\n---\n\n* [Panel](chartbars_panel)\n* The Panel index value that the ChartBars reside.\n\n---\n\n* [Properties](chartbars_properties)\n* Various ChartBar properties that have been configured from the Chart's [Data Series](working_with_price_data) menu.\n\n---\n\n* [ToChartString()](chartbars_tochartstring)\n* A string formatted for the Chart's Data Series Label as well as the period.\n\n---\n\n* [ToIndex](chartbars_toindex)\n* An index value representing the last bar painted on the chart.\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{         \n   if (State == State.DataLoaded)\n   {\n     if(ChartBars != null)\n     {\n         Print(\"The starting number of bars on the chart is \" + ChartBars.Bars.Count);\n     }\n     else \n     {\n         Print(\"Strategy was not loaded from a chart, exiting strategy...\");\n         return;\n     }\n   }\n}\n```"
  },
  {
    "_id": "e4564d8e9e63eb0d99afb5fa2b336bf746880422ed666beae1f794e3eba74664",
    "_type": "desktopSdkDoc",
    "title": "CanvasLeft",
    "pathName": "canvasleft",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the x-coordinate (in pixels) of the beginning of the chart canvas area.\n\n## Property Value\n\nA double representing the beginning of the chart canvas area.\n\n## Syntax\n\n**<`chartcontrol>.CanvasLeft**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Store the beginning and ending x-coordinates of the canvas area\n    double canvasBeginCoordinate = chartControl.CanvasLeft;\n    double canvasEndCoordinate = chartControl.CanvasRight;\n    // Print the stored values\n    Print(String.Format(\"Chart canvas begins at x-coordinate {0} and ends at x-coordinate {1}\", canvasBeginCoordinate, canvasEndCoordinate));\n}\n```\n\nBased on the image below, CanvasLeft reveals that the chart canvas area begins at x-coordinate 53.\n\n![ChartControl_CanvasLeft](chartcontrol_canvasleft.png)\n\n{% callout type=\"note\" %}\n\nWhen no data series are left-aligned on a chart, CanvasLeft will return 0, representing the x-coordinate origin, because the chart canvas will begin at coordinate 0.\n\n{% /callout %}"
  },
  {
    "_id": "7172129056d69e14bb943d5ec7f38246ca3f0061d6e877f0df47151532010cca",
    "_type": "desktopSdkDoc",
    "title": "CanvasRight",
    "pathName": "canvasright",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the x-coordinate (in pixels) of the end of the chart canvas area.\n\n## Property Value\n\nA double representing the end of the chart canvas area.\n\n## Syntax\n\n**<`chartcontrol>**.CanvasRight\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Store the beginning and ending x-coordinates of the canvas area\n   double canvasBeginCoordinate = chartControl.CanvasLeft;\n   double canvasEndCoordinate = chartControl.CanvasRight;\n \n   // Print the stored values\n   Print(String.Format(\"Chart canvas begins at x-coordinate {0} and ends at x-coordinate {1}\", canvasBeginCoordinate, canvasEndCoordinate)); \n}\n```\n\nBased on the image below, CanvasRight reveals that the chart canvas ends at x-coordinate 526.\n\n![ChartControl_CanvasRight](chartcontrol_canvasright.png)"
  },
  {
    "_id": "ff3c857cf38367f2fc482002930bc4e17fce6a276c82b41d464299caa11eaaf4",
    "_type": "desktopSdkDoc",
    "title": "BarsArray",
    "pathName": "barsarray",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nProvides a collection of **ChartBars** objects currently configured on the chart.\n\n## Property Value\n\nAn **ObservableCollection** of **ChartBars** objects.\n\n## Syntax\n\n**<`chartcontrol`>.BarsArray**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Instantiate a new <chartcontrol`>.BarsArray collection\n   System.Collections.ObjectModel.ObservableCollection<chartbars> myChartBars = chartControl.BarsArray;\n \n   // Print the number of bars in each Bars object within the <chartcontrol`>.BarsArray collection\n   foreach(ChartBars bars in myChartBars)\n   {\n       Print(bars.Bars.Count);\n   }\n}\n```"
  },
  {
    "_id": "2fd4cef1f90bc04e4e130a2e2dd3fdbef9109ce60fe07e1f7812132e832a4e04",
    "_type": "desktopSdkDoc",
    "title": "BarsPeriod",
    "pathName": "barsperiod",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nProvides the period (interval) used for the primary **Bars** object on the chart.\n\n## Property Value\n\nA **NinjaTrader.Data.BarsPeriod** object containing information on the period used by the **Bars** object on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.BarsPeriod**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale) \n{\n   BarsPeriod period = chartControl.BarsPeriod;\n \n   // Print the period (interval) of the Bars object on the chart\n   Print(period);\n}\n```\n\nBased on the image below, **BarsPeriod** confirms that the primary **Bars** object on the chart is configured to a 5-minute interval.\n\n![ChartControl_BarsPeriod](chartcontrol_barsperiod.png)"
  },
  {
    "_id": "085a29f7701cdba082224e52959b5942830042335dbe8a79c4dc5ee3af0c391f",
    "_type": "desktopSdkDoc",
    "title": "GetBarPaintWidth()",
    "pathName": "getbarpaintwidth",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the width of the bars in the primary Bars object on the chart, in pixels.\n\n## Method Return Value\n\nA double representing the pixel width of bars on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.GetBarPaintWidth(ChartBars chartBars)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **chartBars**\n* A [ChartBars](chartbars) object to measure\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Use BarsArray[0] to pass in a ChartBars object representing the primary Bars object on the chart\n   double barPixelWidth = chartControl.GetBarPaintWidth(chartControl.BarsArray[0]);\n \n   // Print the pixel width of bars painted on the chart\n   Print(String.Format(\"Bars on the chart are {0} pixels wide\", barPixelWidth));   \n}\n```\n\nIn the image below, **GetBarPaintWidth()** reveals that the bars are being drawn 27 pixels wide on the chart:\n\n![ChartControl_GetBarPaintWidth](chartcontrol_getbarpaintwidth.png)"
  },
  {
    "_id": "44089be1da32ac4c638404cdad114c4d1df9030d1626d20eee1d97beeb5563d8",
    "_type": "desktopSdkDoc",
    "title": "Indicators",
    "pathName": "indicators",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nContains a collection of indicators currently configured on the chart.\n\n## Property Value\n\nA ChartObjectCollection of **NinjaTrader.Gui.NinjaScript.IndicatorRenderBase** objects representing the indicators on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.Indicators**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Instantiate a ChartObjectCollection to hold chartControl.Indicators\n    ChartObjectCollection<NinjaTrader.Gui.NinjaScript.IndicatorRenderBase> indicatorCollection = chartControl.Indicators;\n\n    // Print the Calculate setting for any configured indicators not using Calculate.OnBarClose\n    foreach (NinjaTrader.Gui.NinjaScript.IndicatorRenderBase indicator in indicatorCollection)\n    {\n        if (indicator.Calculate != Calculate.OnBarClose)\n            Print(String.Format(\"{0} is using Calculate.{1}\", indicator.Name, indicator.Calculate.ToString()));\n    }\n}\n\n```"
  },
  {
    "_id": "96adb92452863058fa1616efcc89c6e7c92a0c49148dfbd3e127ce829a45406e",
    "_type": "desktopSdkDoc",
    "title": "Properties",
    "pathName": "properties",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of properties related to the configuration of the Chart\n\n![Chart_Properites](chart_properites.png)\n\n{% callout type=\"note\" %}\n\nWarning: These are UI properties which are designed to be set by a user. Attempting to modify these values through a custom script is NOT guaranteed to take effect.\n\n{% /callout %}\n\n## Property Value\n\nA ChartControlProperties object containing values for all properties configured on the specified ChartBars object.\n\n{% table %}\n\n* Property\n* Return Type and Description\n\n---\n\n* **AllowSelectionDragging**\n* A bool indicating selected chart objects can be moved within a chart panel or dragged to a new chart panel\n\n---\n\n* **AlwaysOnTop**\n* A bool indicating \"Always on Top\" is enabled for the chart window\n\n---\n\n* **AreHGridLinesVisible**\n* A bool indicating the horizontal grid lines are visible on the chart\n\n---\n\n* **AreTabsVisible**\n* A bool indicating tabs are visible in the chart window\n\n---\n\n* **AreVGridLinesVisible**\n* A bool indicating the vertical grid lines are visible on the chart\n\n---\n\n* **AxisPen**\n* A Stroke object used in painting the x- and y-axis\n\n---\n\n* **BarDistance**\n* A float measuring the distance (in pixels) between the left or right edge of one bar and the corresponding edge of the previous or subsequent bar\n\n---\n\n* **BarMarginRight**\n* An int representing the \"Right Margin\" property value configured on the chart\n\n---\n\n* **ChartBackground**\n* A Brush object used to paint the chart background\n\n---\n\n* **ChartText**\n* A Brush object used to paint text on the chart\n\n---\n\n* **ChartTraderVisibility**\n* An enum indicating the visibility status of Chart Trader. Possible values are Collapsed, Visible, and VisibleCollapsed\n\n---\n\n* **CrosshairCrosshairType**\n* An enum indicating the type of Cross Hair enabled on the chart. Possible values are Off, Local, Global, and GlobalNoTimeScroll\n\n---\n\n* **CrosshairIsLocked**\n* A bool indicating the Cross Hair's vertical line is locked in place\n\n---\n\n* **CrosshairLabelBackground**\n* A Brush object used to paint the Cross Hair's price and time markers in the x- and y-axis\n\n---\n\n* **CrosshairLabelForeground**\n* A Brush object used to paint the text in the Cross Hair's price and time markers\n\n---\n\n* **CrosshairPen**\n* A string representing the Pen used within the Stroke that is used to draw the Cross Hair\n\n---\n\n* **CrosshairStroke**\n* A CrosshairStroke object containing information on the Cross Hair's Stroke, CrosshairType, and isLocked property\n\n---\n\n* **GridLineHPen**\n* A GridLine object containing information on the horizontal grid lines' Stroke and isVisible property\n\n---\n\n* **GridLineVPen**\n* A GridLine object containing information on the vertical grid lines' Stroke and isVisible property\n\n---\n\n* **InactivePriceMarkersBackground**\n* A Brush object used to paint the background of inactive price markers on the chart\n\n---\n\n* **InactivePriceMarkersForeground**\n* A Brush object used to paint the display text of inactive price markers on the chart\n\n---\n\n* **LabelFont**\n* A NinjaTrader.Gui.Tools.SimpleFont object containing information on the font used in text labels throughout the chart\n\n---\n\n* **PanelSplitterPen**\n* A Stroke object used to paint the lines between chart panels\n\n---\n\n* **ShowDateRange**\n* A bool indicating the date range of the bars painted on the visible chart canvas will be displayed within the chart\n\n---\n\n* **ShowScrollBar**\n* A bool indicating the horizontal scroll bar is visible beneath the x-axis\n\n---\n\n* **SnapMode**\n* An enum indicating the currently enabled Snap Mode. Possible values are None, Bar, Price, and BarAndPrice\n\n---\n\n* **TabName**\n* A string representing the name of the current tab\n{% /table %}\n\n## Syntax\n\n**<`chartcontrol`>.Properties**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Instantiate a ChartControlProperties object to hold a reference to chartControl.Properties\n   ChartControlProperties myProperties = chartControl.Properties;\n \n   // Set the AllowSelectionDragging property to false\n   myProperties.AllowSelectionDragging = false;\n}\n```"
  },
  {
    "_id": "011bf63dfdd9637320c2d49dbb9692e0a752ba296ed7e54cb29ceb7d50c87fe7",
    "_type": "desktopSdkDoc",
    "title": "CrosshairType",
    "pathName": "crosshairtype",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the **Cross Hair** type currently enabled on the chart.\n\n## Property Value\n\nAn enum specifying the type of Cross Hair currently enabled on the chart. Possible values are listed below:\n\n{% table %}\n\n---\n\n* Local\n* The local (single-chart) Cross Hair is enabled\n\n---\n\n* Global\n* Global Cross Hair\n\n---\n\n* GlobalNoTimeScroll\n* Global Cross Hair (No Time Scroll) is enabled\n{% /table %}\n\n## Syntax\n\n**<`chartcontrol`>.CrosshairType**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print a message if the user enables the Global Cross Hair without time scrolling\n   if (chartControl.CrosshairType == CrosshairType.GlobalNoTimeScroll)\n       Print(\"It is recommended to enable Global Cross Hair time scrolling with this indicator\");\n}\n```\n\nIn the image below, **CrosshairType** reveals that Global Cross Hair (No Time Scroll) is enabled on the chart.\n\n![ChartControl_CrosshairType](chartcontrol_crosshairtype.png)"
  },
  {
    "_id": "df9c82d25479c9b934622b08036e1b653204224c3d6431a01f33b6f4c70e15e6",
    "_type": "desktopSdkDoc",
    "title": "FirstTimePainted",
    "pathName": "firsttimepainted",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates a **DateTime** value of the first bar painted on the chart.\n\n**FirstTimePainted** provides the timestamp of the first bar, NOT the time at which the bar was painted. For example, if a chart was opened and historical bars drawn on August 2nd at 5:00 pm, but the first bar on the chart is painted at a time-axis value of July 31st at 1:00 am, then **FirstTimePainted** will return the July 31st date and time.\n\n## Property Value\n\nA [**DateTime**](datetime) object containing information on the timestamp of the first bar of the chart.\n\n## Syntax\n\n**<`chartcontrol`>.FirstTimePainted**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Draw text to display the first timestamp of a bar on the chart\n    Draw.Text(this, \"firstTimeText\", String.Format(\"The first bar of {0} is drawn at {1}\", Instrument.MasterInstrument.Name, chartControl.FirstTimePainted), 1, High[0],Brushes.Black);\n}\n```\n\nIn the image below, **FirstTimePainted** reveals that the first painted slot corresponds to 8/12/17 at 10:40:00 AM.\n\n![ChartControl_FirstTimePainted](chartcontrol_firsttimepainted.png)"
  },
  {
    "_id": "58217883896f11e73430aaf9bace563c4c11df3acd543bf7952a17d636a8c5ca",
    "_type": "desktopSdkDoc",
    "title": "GetTimeBySlotIndex()",
    "pathName": "gettimebyslotindex",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a time value relative to the chart control corresponding to a specified slot index.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* A \"Slot\" is used in Equidistant **bar spacing** and represents a position on the chart canvas background which may or may not contain a bar. The concept of \"Slots\" does NOT exist on a TimeBased bar spacing type.\n* If you are looking for information on a bar series, please see [ChartBars.GetTimeByBarIdx()](chartbars_gettimebybaridx).\n* For slot index values in the future, an estimation of time will be returned. It is not possible to predict the future time of a bar for all bar series (i.e., tick/volume based bars).\n{% /callout %}\n\n## Method Return Value\n\nA **DateTime** object corresponding to a specified slot index; returns **DateTime** value for 'now' on a time based bar spacing type.\n\n## Syntax\n\n**<`chartcontrol`>.GetTimeBySlotIndex(double slotIndex)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* slotIndex\n* The slot index used to determine a time value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Find the timestamp of the bar at index 150\n    DateTime slotTime = chartControl.GetTimeBySlotIndex(150);\n    \n    // Print the date of slotTime\n    Print(slotTime.Date);\n}\n```"
  },
  {
    "_id": "ae068ac19a3df4d68fbea9c1976d2bae127a93f17bc0ee1e6b3c2472c5558179",
    "_type": "desktopSdkDoc",
    "title": "GetXByBarIndex()",
    "pathName": "getxbybarindex",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the chart-canvas x-coordinate of the bar at a specified index of a specified **ChartBars** object on the chart.\n\n{% callout type=\"note\" %}\n\nSince the index is based upon bars that move across the chart canvas as new bars are painted, the value returned by **GetXByBarIndex()** can be expected to change as new bars are painted on the chart, or as the chart is scrolled backward or forward on the x-axis.\n\n{% /callout %}\n\n## Method Return Value\n\nAn int representing a chart-canvas x-coordinate.\n\n## Syntax\n\n**<`chartcontrol`>.GetXByBarIndex(ChartBars chartBars, int barIndex)**\n\n## Method Parameters\n\n{% table %}\n\n* **Parameter**\n* **Description**\n\n---\n\n* **chartBars**\n* The **ChartBars** object to check.\n\n---\n\n* **barIndex**\n* The slot index used to determine an x-coordinate.\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    double xCoordinate = chartControl.GetXByBarIndex(ChartBars, 100);\n    \n    // Print the x-coordinate value\n    Print(xCoordinate);\n}\n```"
  },
  {
    "_id": "f65080d293aa540c4d0f7ba985e7b41f76693aac007294ea2ad03142471e231f",
    "_type": "desktopSdkDoc",
    "title": "IsScrollArrowVisible",
    "pathName": "isscrollarrowvisible",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the time-axis scroll arrow is visible in the top-right corner of the chart.\n\n## Property Value\n\nA bool value. When **True**, indicates that the scroll arrow is visible on the chart; otherwise **False**.\n\n## Syntax\n\n**<`chartcontrol`>.IsScrollArrowVisible**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print a message if the scroll arrow is visible on the chart\n   if(chartControl.IsScrollArrowVisible);\n       Print(\"The chart is currently not set to auto-scroll. Click the scroll arrow to return to auto-scrolling\");\n}\n```\n\nBased on the image below, **IsScrollArrowVisible** confirms that the scroll arrow is currently visible on the chart.\n\n![ChartControl_IsScrollArrowVisible](chartcontrol_isscrollarrowvisible.png)"
  },
  {
    "_id": "465d912f1b77cfdcf4db1e5094fae0bd48567aff2786fdccbe3c67e317128e22",
    "_type": "desktopSdkDoc",
    "title": "IsStayInDrawMode",
    "pathName": "isstayindrawmode",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates **Stay in Draw Mode** is currently enabled on the chart.\n\n## Property Value\n\nA bool value. When True, indicates that Stay in Draw Mode is enabled on the chart; otherwise False.\n\n## Syntax\n\n**<`chartcontrol`>.IsStayInDrawMode**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print a message if Stay in Draw Mode is enabled\n   if(chartControl.IsStayInDrawMode);\n       Print(\"Stay in Draw Mode is currently enabled\");\n}\n```"
  },
  {
    "_id": "d6b58f8bf0d0e302bd6e61315f77d8abdafd23ebb1c2a28101a48d156ea438fd",
    "_type": "desktopSdkDoc",
    "title": "IsYAxisDisplayedLeft",
    "pathName": "isyaxisdisplayedleft",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the y-axis displays (in any chart panel) to the left side of the chart.\n\n## Property Value\n\nA boolean value. When **True**, indicates that the y-axis displays to the left of the chart canvas; otherwise **False**.\n\n## Syntax\n\n**<`chartcontrol`>.IsYAxisDisplayedLeft**\n\n## Examples\n\n{% callout type=\"note\" %}\n\nBased on the image below, IsYAxisDisplayedLeft confirms that the y-axis displays to the left of the chart canvas.\n\n{% /callout %}\n\n![ChartControl_isYAxisDisplayedLeft](chartcontrol_isyaxisdisplayedleft.png)\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the value of IsYAxisDisplayedLeft\n   Print(\"Y-Axis visible to the left of the chart canvas? \" + chartControl.IsYAxisDisplayedLeft);\n}\n```"
  },
  {
    "_id": "a0f93ed5fb7ef03f5d8a225b5c9c1171ba7039c1c915d5c0e5e82687335d9a01",
    "_type": "desktopSdkDoc",
    "title": "IsYAxisDisplayedOverlay",
    "pathName": "isyaxisdisplayedoverlay",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates an object on the chart is using the Overlay scale justification.\n\n## Property Value\n\nA boolean value. When **True**, indicates that one or more objects on the chart are using the Overlay scale justification; otherwise **False**.\n\n## Syntax\n\n**<`chartcontrol`>.IsYAxisDisplayedOverlay**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the value of IsYAxisDisplayedOverlay\n   Print(\"Is Overlay used? \" + chartControl.IsYAxisDisplayedOverlay);\n}\n\n```\n\nBased on the image below, **IsYAxisDisplayedOverlay** confirms that an object on the chart, in this case an SMA indicator, is using the Overlay scale justification.\n\n![ChartControl_IsXAxisDisplayedOverlay](chartcontrol_isxaxisdisplayedoverlay.png)"
  },
  {
    "_id": "76336a43b165d278d0c6745df15702474ec4f2f90c0c3c597bac353fb4bbad1b",
    "_type": "desktopSdkDoc",
    "title": "IsYAxisDisplayedRight",
    "pathName": "isyaxisdisplayedright",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the y-axis displays (in any chart panel) to the right side of the chart.\n\n## Property Value\n\nA boolean value. When **True**, indicates that the y-axis displays to the right of the chart canvas; otherwise **False**.\n\n## Syntax\n\n**<`chartcontrol`>.IsYAxisDisplayedRight**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the value of IsYAxisDisplayedRight\n   Print(\"Y-Axis visible to the right of the chart canvas? \" + chartControl.IsYAxisDisplayedRight);\n}\n```\n\nBased on the image below, **IsYAxisDisplayedRight** confirms that the y-axis is not displayed to the right of the chart canvas.\n\n![ChartControl_IsYAxisDisplayedRight](chartcontrol_isyaxisdisplayedright.png)"
  },
  {
    "_id": "30b1d23bd393a670270801b46e73d396005fec13a100abd69e38230ee2634ecb",
    "_type": "desktopSdkDoc",
    "title": "LastSlotPainted",
    "pathName": "lastslotpainted",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the most recent (last) slot index of the Data Series on the chart, regardless if a bar is actually painted in that slot.\n\n{% callout type=\"note\" %}\n\nLastSlotPainted differs from **ChartBars.ToIndex**, which returns the last index containing a bar painted in the visible area of the chart.\n\n{% /callout %}\n\n## Property Value\n\nA int representing the most recent (last) slot index on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.LastSlotPainted**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   int lastSlot = chartControl.LastSlotPainted;\n \n   // Print the index of the last slot on the chart\n   Print(lastSlot);\n}\n```"
  },
  {
    "_id": "2a82a9210744f2b85859eba82863557f2f943ce7efdab77f03a6f47a2999cb1c",
    "_type": "desktopSdkDoc",
    "title": "LastTimePainted",
    "pathName": "lasttimepainted",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the time of the most recently painted bar on the primary **Bars** object configured on the chart.\n\n## Property Value\n\nA **DateTime** object corresponding to the slot index of the most recently painted bar.\n\n## Syntax\n\n<chartcontrol`>.LastTimePainted\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   DateTime lastSlotTime = chartControl.LastTimePainted;\n\n   // Print the index of the last slot painted on the chart\n   Print(lastSlotTime);\n}\n```\n\nIn the image below, LastTimePainted reveals that the last index painted on the chart corresponds to 8/12/17 at 2:10:00 PM.\n\n![ChartControl_LastTimePainted](chartcontrol_lasttimepainted.png)"
  },
  {
    "_id": "eaac1bdb6c594c3a31fed654f05fd03472069255913e872679ed5171da9ffef4",
    "_type": "desktopSdkDoc",
    "title": "PanelIndex",
    "pathName": "panelindex",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the minimum Y value of objects within the chart panel, based on the current y-axis scale. The scale of the y-axis is dependent upon the values of objects in the panel which have Auto Scale enabled.\n\n## Property Value\n\nA double representing the minimum Y value in the panel's vertical scale\n\n## Syntax\n\n**ChartPanel.MinValue**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)**\n{\n   base.OnRender(chartControl, chartScale);\n\n   // Print the minimum and maximum Y values for objects in the panel\n   Print(String.Format(\"Min value: {0}, Max value: {1}\", **ChartPanel.MinValue**, **ChartPanel.MaxValue**));\n}\n\n```"
  },
  {
    "_id": "cd485f83f891fa4182b47a0830e816562bc31a32517f4fb3131e39f9c5727d91",
    "_type": "desktopSdkDoc",
    "title": "MouseDownPoint",
    "pathName": "mousedownpoint",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the WPF x- and y-coordinates of the mouse cursor at the most recent **OnMouseDown()** event.\n\n## Property Value\n\nA [Point](https://msdn.microsoft.com/en-us/library/system.drawing.point(v=vs.110).aspx) object containing x- and y-coordinates of the mouse cursor when the left mouse button is clicked or held.\n\n## Syntax\n\n**<`chartcontrol`>.MouseDownPoint**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   Point cursorPoint = chartControl.MouseDownPoint;\n \n   // Print the x- and y-coordinates of the mouse cursor when clicked\n   Print(String.Format(\"Mouse clicked at coordinates {0},{1}\", cursorPoint.X, cursorPoint.Y));\n}\n```"
  },
  {
    "_id": "7c394be974935ec3f79478b5bf70636d4ae60ee594b3149d870baf09308546f6",
    "_type": "desktopSdkDoc",
    "title": "PresentationSource",
    "pathName": "presentationsource",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nProvides a reference to the base window in which the chart is rendered. **PresentationSource** can be used when converting application pixels to/from device pixels via the helper methods in the [ChartingExtensions](chartingextensions) class.\n\n## Property Value\n\nA **PresentationSource** object representing the base window in which the chart is rendered.\n\n## Syntax\n\n**ChartControl.PresentationSource**\n\n## Examples\n\n```csharp\nint devicePixelX;\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Obtain the device-pixel coordinate corresponding to an application-pixel X value of 500\n   devicePixelX = ChartingExtensions.ConvertToHorizontalPixels(500, ChartControl.PresentationSource);\n}\n```"
  },
  {
    "_id": "62cec4be371ea50919d752b67a6de92f5f1c0e06c59d90602a33624f2d3f68f0",
    "_type": "desktopSdkDoc",
    "title": "SlotsPainted",
    "pathName": "slotspainted",
    "parent": "chartcontrol",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the number of index slots in which bars are painted within the chart canvas area. This covers the visible portion of the chart only, and does not include historical painted bars outside of the visible area.\n\n## Property Value\n\nAn int representing the number of index slots in which bars are painted.\n\n## Syntax\n\n**<`chartcontrol`>.SlotsPainted**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   int painted = chartControl.SlotsPainted;\n \n   // Print the number of bars painted on the visible chart canvas\n   Print(painted);\n}\n```\n\nIn the image below, **SlotsPainted** reveals that there are 17 bars painted on the chart canvas.\n\n![ChartControl_SlotsPainted](chartcontrol_slotspainted.png)"
  },
  {
    "_id": "b40716e3347cec3a0e27c786403f77716af4ba736056e696f1aa7d149223f53f",
    "_type": "desktopSdkDoc",
    "title": "ChartControl",
    "pathName": "chartcontrol",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The **ChartControl** class provides access to a wide range of properties and methods related to the location of objects on a chart and other chart-related properties. The **ChartControl** object provides information related to the entire hosting grid of the chart, which overlap with the [ChartPanel](chartpanel), [ChartScale](chartscale) and [ChartBars](chartbars).\n\n{% callout type=\"note\" %}\n\nThe **ChartControl** object is ONLY guaranteed to be available when a **NinjaScript** type initiates from a Chart Window. There are situations where an indicator or strategy starts from another Windows (such as the Control Center's Strategies Grid, or from a Strategy Analyzer), where the **ChartControl** object is NOT accessible. Therefore, the **ChartControl** object should always be safely accessed (e.g., from within a try-catch, or conditionally using null reference checks).\n\n{% /callout %}\n\n![ChartControl_1](chartcontrol_1.png)\n\n{% callout type=\"warning\" %}\n\nWarning: The **ChartControl** and its methods and properties should ONLY be accessed once the **State** has reached **State.Historical**.\n\n{% /callout %}\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [AxisXHeight](axisxheight)\n* Measures the distance (in pixels) between the x-axis and the top of the horizontal scroll bar\n\n---\n\n* [AxisYLeftWidth](axisyleftwidth)\n* Measures the distance (in pixels) between the y-axis and the left margin of a chart\n\n---\n\n* [AxisYRightWidth](axisyrightwidth)\n* Measures the distance (in pixels) between the y-axis and the right margin of a chart\n\n---\n\n* [BarMarginLeft](barmarginleft)\n* Measures the margin to the left of each bar on the chart, in pixels\n\n---\n\n* [BarsArray](chartcontrol_barsarray)\n* Provides a collection of [ChartBars](chartbars) objects currently configured on the chart\n\n---\n\n* [BarSpacingType](barspacingtype)\n* Provides the type of bar spacing used for the primary [Bars](bars) object on the chart\n\n---\n\n* [BarsPeriod](chartcontrol_barsperiod)\n* Provides the period (interval) used for the primary [Bars](bars) object on the chart\n\n---\n\n* [BarWidth](chartcontrol_barwidth)\n* Measures the value of the bar width set for the primary [Bars](bars) object on the chart\n\n---\n\n* [BarWidthArray](barwidtharray)\n* An array containing the values of the [BarWidth](chartcontrol_barwidth) properties of all [Bars](bars) objects on the chart\n\n---\n\n* [CanvasLeft](canvasleft)\n* Indicates the x-coordinate (in pixels) of the beginning of the chart canvas area\n\n---\n\n* [CanvasRight](canvasright)\n* Indicates the x-coordinate (in pixels) of the end of the chart canvas area\n\n---\n\n* [CanvasZoomState](canvaszoomstate)\n* Indicates the current state of the Zoom tool on the chart\n\n---\n\n* [ChartPanels](chartpanels)\n* Holds a collection of [ChartPanel](chartpanel) objects\n\n---\n\n* [CrosshairType](crosshairtype)\n* Indicates the [Cross Hair](cross_hair) type currently enabled on the chart\n\n---\n\n* [FirstTimePainted](firsttimepainted)\n* Indicates a time value of the first bar painted on the chart\n\n---\n\n* [GetBarPaintWidth()](getbarpaintwidth)\n* Returns the width of the bars in the primary [Bars](bars) object on the chart, in pixels\n\n---\n\n* [GetSlotIndexByTime()](getslotindexbytime)\n* Returns the slot index of the primary [Bars](bars) object on the chart corresponding to a specified time value\n\n---\n\n* [GetSlotIndexByX()](getslotindexbyx)\n* Returns the slot index of the primary [Bars](bars) object on the chart corresponding to a specified x-coordinate on the visible chart canvas\n\n---\n\n* [GetTimeBySlotIndex()](gettimebyslotindex)\n* Returns a time value corresponding to a specified slot index of the primary [Bars](bars) object on the chart\n\n---\n\n* [GetTimeByX()](gettimebyx)\n* Returns a time value related to the primary [Bars](bars)' slot index at a specified x-coordinate on the chart canvas\n\n---\n\n* [GetXByBarIndex()](getxbybarindex)\n* Returns the chart-canvas x-coordinate of the bar at a specified index of a specified [ChartBars](chartbars) object on the chart\n\n---\n\n* [GetXByTime()](getxbytime)\n* Returns the chart-canvas x-coordinate of the slot index of the primary [Bars](bars) object corresponding to a specified time\n\n---\n\n* [Indicators](chartcontrol_indicators)\n* Returns a collection of indicators currently configured on the chart\n\n---\n\n* [IsScrollArrowVisible](isscrollarrowvisible)\n* Indicates the time-axis scroll arrow is visible in the top-right corner of the chart\n\n---\n\n* [IsStayInDrawMode](isstayindrawmode)\n* Indicates the [Stay in Draw Mode](working_with_drawing_tools__ob) is currently enabled on the chart\n\n---\n\n* [IsYAxisDisplayedLeft](isyaxisdisplayedleft)\n* Indicates the y-axis displays (in any chart panel) to the left side of the chart canvas\n\n---\n\n* [IsYAxisDisplayedOverlay](isyaxisdisplayedoverlay)\n* Indicates an object on the chart is using the Overlay scale justification\n\n---\n\n* [IsYAxisDisplayedRight](isyaxisdisplayedright)\n* Indicates the y-axis displays (in any chart panel) to the right side of the chart canvas\n\n---\n\n* [LastSlotPainted](lastslotpainted)\n* Indicates the slot index of the most recently painted bar on the primary [Bars](bars) object configured on the chart\n\n---\n\n* [LastTimePainted](lasttimepainted)\n* Indicates the time of the most recently painted bar on the primary [Bars](bars) object configured on the chart\n\n---\n\n* [MouseDownPoint](mousedownpoint)\n* Indicates the x- and y-coordinates of the mouse cursor at the most recent **OnMouseDown()** event\n\n---\n\n* [Properties](chartcontrol_properties)\n* A collection of properties related to the configuration of the Chart\n\n---\n\n* [SlotsPainted](slotspainted)\n* Indicates the number of index slots in which bars are painted within the chart canvas area\n\n---\n\n* [Strategies](chartcontrol_strategies)\n* A collection of strategies configured on the chart\n\n---\n\n* [TimePainted](timepainted)\n* Indicates the range of time in which bars are painted on the visible chart canvas\n{% /table %}"
  },
  {
    "_id": "795eff1dfb30bd6600f24b81d052c40538e1471191bdc38775200231fac6cab1",
    "_type": "desktopSdkDoc",
    "title": "ConvertFromHorizontalPixels",
    "pathName": "convertfromhorizontalpixels",
    "parent": "chartingextensions",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nConverts an x-axis pixel coordinate from device pixels to application pixels.\n\n{% callout type=\"note\" %}\n\nFor more information concerning the differences between application pixels and device pixels, please see the [Working with Pixel Coordinates](working_with_pixel_coordinates).\n\n{% /callout %}\n\n## Method Return Value\n\nA double representing an x-coordinate value in terms of application pixels.\n\n## Syntax\n\n**ChartingExtensions.ConvertFromHorizontalPixels(this int x, PresentationSource target)**  \n\n**int.ConvertFromHorizontalPixels(PresentationSource target)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **x**\n* The horizontal int coordinates in device pixels to convert.\n\n---\n\n* **target**\n* The [PresentationSource](https://msdn.microsoft.com/en-us/library/system.windows.presentationsource(v=vs.110).aspx) representing the display surface used for the conversion. Note: For Charts, see [ChartControl.PresentationSource](presentationsource).\n{% /table %}\n\n## Examples\n\n```csharp\nint applicationPixelX;\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Obtain the application-pixel coordinate corresponding to a device-pixel X value of 500\n    applicationPixelX = ChartingExtensions.ConvertFromHorizontalPixels(500, ChartControl.PresentationSource);\n}\n```"
  },
  {
    "_id": "08af7a701e3dfd3943561bc1ad9714a43533de75abc10defdc35d65c3c07c15b",
    "_type": "desktopSdkDoc",
    "title": "ConvertFromVerticalPixels",
    "pathName": "convertfromverticalpixels",
    "parent": "chartingextensions",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nConverts a y-axis pixel coordinate from device pixels to application pixels.\n\n{% callout type=\"note\" %}\n\nFor more information concerning the differences between application pixels and device pixels, please see the [Working with Pixel Coordinates](working_with_pixel_coordinates).\n\n{% /callout %}\n\n## Method Return Value\n\nA double representing a y-coordinate value in terms of application pixels.\n\n## Syntax\n\n**ChartingExtensions.ConvertFromVerticalPixels**(**this int x**, **PresentationSource target**)  \n\n**<`int`>.ConvertFromVerticalPixels**(**PresentationSource target**)\n\n## Parameters\n\n{% table %}\n\n* x\n* target\n\n---\n\n* The vertical int coordinates in device pixels to convert\n* The [PresenationSource](https://msdn.microsoft.com/en-us/library/system.windows.presentationsource(v=vs.110).aspx) representing the display surface used for the conversion.  \nNote: For Charts, see [ChartControl.PresentationSource](presentationsource).\n{% /table %}\n\n## Examples\n\n```csharp\nint applicationPixelY;\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Obtain the application-pixel coordinate corresponding to a device-pixel Y value of 500\n    applicationPixelY = ChartingExtensions.ConvertFromVerticalPixels(500, ChartControl.PresentationSource);\n}\n```"
  },
  {
    "_id": "99efce06d9269314421b647209acf3c8246e7dd437a943c3ee5ad95d5a5f284a",
    "_type": "desktopSdkDoc",
    "title": "ConvertToHorizontalPixels",
    "pathName": "converttohorizontalpixels",
    "parent": "chartingextensions",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nConverts an x-axis pixel coordinate from application pixels to device pixels.\n\n{% callout type=\"note\" %}\n\nFor more information concerning the differences between application pixels and device pixels, please see the [Working with Pixel Coordinates](working_with_pixel_coordinates).\n\n{% /callout %}\n\n## Method Return Value\n\nAn int representing an x-coordinate value in terms of device pixels.\n\n## Syntax\n\n**ChartingExtensions.ConvertToHorizontalPixels**(this double x, **PresentationSource** target)  \n\n**<`double>**.ConvertToHorizontalPixels(**PresentationSource** target)\n\n## Parameters\n\n{% table %}\n\n---\n\n* **x**\n* The horizontal double coordinates in application pixels to convert\n\n---\n\n* **target**\n* The [PresenationSource](https://msdn.microsoft.com/en-us/library/system.windows.presentationsource(v=vs.110).aspx) representing the display surface used for the conversion.  \nNote: For Charts, see [ChartControl.PresentationSource](presentationsource).\n{% /table %}\n\n## Examples\n\n```csharp\nint devicePixelX;\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Obtain the device-pixel coordinate corresponding to an application pixel X-value of 500\n    devicePixelX = ChartingExtensions.ConvertToHorizontalPixels(500, ChartControl.PresentationSource);\n}\n```"
  },
  {
    "_id": "d39e9d0f342702931c0465c03e5af65e40b9c264b654fa3e887f37f8f522c045",
    "_type": "desktopSdkDoc",
    "title": "ConvertToVerticalPixels",
    "pathName": "converttoverticalpixels",
    "parent": "chartingextensions",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nConverts a y-axis pixel coordinate from application pixels to device pixels.\n\n{% callout type=\"note\" %}\n\nFor more information concerning the differences between application pixels and device pixels, please see the [Working with Pixel Coordinates](working_with_pixel_coordinates).\n\n{% /callout %}\n\n## Method Return Value\n\nAn int representing a y-coordinate value in terms of device pixels.\n\n## Syntax\n\n**ChartingExtensions.ConvertToVerticalPixels**(this double x, **PresentationSource** target)  \n\n**double.ConvertToVerticalPixels**(**PresentationSource** target)\n\n## Parameters\n\n{% table %}\n\n* x\n* target\n\n---\n\n* The vertical double coordinates in application pixels to convert\n* The [PresenationSource](https://msdn.microsoft.com/en-us/library/system.windows.presentationsource(v=vs.110).aspx) representing the display surface used for the conversion. Note: For Charts, see [ChartControl.PresentationSource](presentationsource).\n{% /table %}\n\n## Examples\n\n```csharp\nint devicePixelY;\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // Obtain the device-pixel coordinate corresponding to an application-pixel Y value of 500\n    devicePixelY = ChartingExtensions.ConvertToVerticalPixels(500, ChartControl.PresentationSource);\n}\n```"
  },
  {
    "_id": "624a0f67a30184cc3996bff7bc9dbf4489b208a38df32309e5cf6bc28f566fe8",
    "_type": "desktopSdkDoc",
    "title": "ChartingExtensions",
    "pathName": "chartingextensions",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The **ChartingExtensions** class provides helper methods useful for converting a pixel coordinate from application-specific pixels (i.e., WPF coordinates) to Device Independent Pixels.\n\n{% callout type=\"note\" %}\n\nMore information about the differences between application pixels and device pixels can be found on the [Working with Pixel Coordinates](working_with_pixel_coordinates) page.\n\n{% /callout %}\n\n## ChartingExtensions Helper Methods\n\n{% table %}\n\n* Method\n* Description\n\n---\n\n* [ConvertFromHorizontalPixels](convertfromhorizontalpixels)\n* Converts a horizontal coordinate (x) from device pixels to application pixels\n\n---\n\n* [ConvertFromVerticalPixels](convertfromverticalpixels)\n* Converts a vertical coordinate (y) from device pixels to application pixels\n\n---\n\n* [ConvertToHorizontalPixels](converttohorizontalpixels)\n* Converts a horizontal coordinate (x) in application pixels to device pixels\n\n---\n\n* [ConvertToVerticalPixels](converttoverticalpixels2)\n* Converts a vertical coordinate (y) in application pixels to device pixels\n{% /table %}"
  },
  {
    "_id": "9c3d0d864f2ce471c4be5d28e9f924d37ab5a382b2e47b268db1f53436f0951b",
    "_type": "desktopSdkDoc",
    "title": "ChartObjects",
    "pathName": "chartobjects",
    "parent": "chartpanel",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of objects configured on the chart panel.\n\n## Property Value\n\nAn **IList** of **Gui.NinjaScript.IChartObject** instances containing references to the objects configured on the panel.\n\n## Syntax\n\n**ChartPanel.ChartObjects**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    base.OnRender(chartControl, chartScale);\n\n    IList<Gui.NinjaScript.IChartObject> myObjects = ChartPanel.ChartObjects;\n\n    foreach (Gui.NinjaScript.IChartObject thisObject in myObjects)\n    {\n        Print(String.Format(\"{0} is of type {1}\", thisObject.Name, thisObject.GetType()));\n    }\n}\n```\n\nThe image below shows the output of the code example above, while applied in a chart panel with three objects.\n\n![ChartPanel_ChartObjects](chartpanel_chartobjects.png)"
  },
  {
    "_id": "9b057eb483bb4cf4354fee74ac745e6d45877f9f6799ca0c500e074b40655dbe",
    "_type": "desktopSdkDoc",
    "title": "ChartPanels",
    "pathName": "chartpanels",
    "parent": "chartpanel",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds a collection of **ChartPanel** objects containing information about the panels active on the chart.\n\n## Property Value\n\nAn **ObservableCollection** of **ChartPanel** objects\n\n## Syntax\n\n**<`chartcontrol`>.ChartPanels**\n\n## Examples\n\n{% callout type=\"note\" %}\n\nBased on the image below, there are three ChartPanel objects in the ChartPanels collection, as seen by **ChartPanels.Count** in the code above.\n\n{% /callout %}\n\n![ChartControl_ChartPanels](chartcontrol_chartpanels.png)\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the number of panels currently displayed on the chart\n   Print(String.Format(\"There are {0} panels on the chart\", chartControl.ChartPanels.Count));  \n}\n```"
  },
  {
    "_id": "0b8fbb7aaa8fdd3fe123cb7661092f85789ed67343686e9d3b27825bfde08793",
    "_type": "desktopSdkDoc",
    "title": "H (Height)",
    "pathName": "h_height",
    "parent": "chartpanel",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the height (in pixels) of the rendered area of the chart panel.\n\n{% callout type=\"note\" %}\n\nThe paintable area does not extend all the way to the top edge of the panel itself, as seen in the image below.\n\n{% /callout %}\n\n## Property Value\n\nA int representing the height of the panel in pixels.\n\n## Syntax\n\n**ChartPanel.H**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    base.OnRender(chartControl, chartScale);\n    \n    // Print the height of the panel\n    Print(ChartPanel.H);\n}\n```\n\nBased on the image below, H reveals that the paintable area of the chart panel is 69 pixels high.\n\n![ChartPanel_H](chartpanel_h.png)"
  },
  {
    "_id": "d6b58f8bf0d0e302bd6e61315f77d8abdafd23ebb1c2a28101a48d156ea438fd",
    "_type": "desktopSdkDoc",
    "title": "IsYAxisDisplayedLeft",
    "pathName": "isyaxisdisplayedleft",
    "parent": "chartpanel",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the y-axis is visible on the left side of the chart panel.\n\n## Property Value\n\nA bool indicating the y-axis is visible to the left\n\n## Syntax\n\n**ChartPanel.IsYAxisDisplayedLeft**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   base.OnRender(chartControl, chartScale);\n\n   // Print a message if the y-axis is visible on the left\n   if (ChartPanel.IsYAxisDisplayedLeft)\n       Print(\"The y-axis is visible on the left\");\n}\n```\n\nBased on the image below, **IsYAxisDisplayedLeft** confirms that the y-axis displays to the left. In this image, the property would be set to true when applied to either chart panel.\n\n![ChartPanel_IsYAxisDisplayedLeft](chartpanel_isyaxisdisplayedleft.png)"
  },
  {
    "_id": "a0f93ed5fb7ef03f5d8a225b5c9c1171ba7039c1c915d5c0e5e82687335d9a01",
    "_type": "desktopSdkDoc",
    "title": "IsYAxisDisplayedOverlay",
    "pathName": "isyaxisdisplayedoverlay",
    "parent": "chartpanel",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates any objects configured in the panel are using the Overlay scale justification.\n\n## Property Value\n\nA bool indicating any objects use the Overlay scale justification.\n\n## Syntax\n\n**ChartPanel.IsYAxisDisplayedOverlay**\n\n## Examples\n\n{% callout type=\"note\" %}\n\nBased on the image below, **IsYAxisDisplayedOverlay** is set to True, since the SMA indicator is using the Overlay scale justification.\n\n{% /callout %}\n\n![ChartPanel_IsYAxisDisplayedOverlay](chartpanel_isyaxisdisplayedoverlay.png)\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    base.OnRender(chartControl, chartScale);\n\n    // Trigger an alert when the Overlay scale justification is used\n    if (ChartPanel.IsYAxisDisplayedOverlay)\n        Alert(\"overlayAlert\", Priority.Low, \"It is not recommended to use 'Overlay' with this indicator\", \"\", 300, Brushes.Yellow, Brushes.Black);\n}\n```"
  },
  {
    "_id": "76336a43b165d278d0c6745df15702474ec4f2f90c0c3c597bac353fb4bbad1b",
    "_type": "desktopSdkDoc",
    "title": "IsYAxisDisplayedRight",
    "pathName": "isyaxisdisplayedright",
    "parent": "chartpanel",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the y-axis is visible on the right side of the chart panel.\n\n## Property Value\n\nA **bool** indicating the y-axis is visible to the right\n\n## Syntax\n\n**ChartPanel.IsYAxisDisplayedRight**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n\n{\n\n   base.OnRender(chartControl, chartScale);\n\n   // Print a message if the y-axis is visible on the right\n\n   if (ChartPanel.IsYAxisDisplayedRight)\n\n       Print(\"The y-axis is visible on the right\");\n\n}\n```\n\nBased on the image below, **IsYAxisDisplayedRight** confirms that the y-axis is not displayed on the right. The property would be set to false when applied in either chart panel in this instance.\n\n![ChartPanel_IsYAxisDisplayedRight](chartpanel_isyaxisdisplayedright.png)"
  },
  {
    "_id": "fb4f2bb8213b78849db73de8660359b295dfe21c001984ea5bf9c34a34221baf",
    "_type": "desktopSdkDoc",
    "title": "MaxValue",
    "pathName": "maxvalue",
    "parent": "chartpanel",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the maximum Y value of objects within the chart panel, based on the current y-axis scale. The scale of the y-axis is dependent upon the values of objects in the panel which have Auto Scale enabled.\n\n## Property Value\n\nA double representing the maximum Y value in the panel's vertical scale\n\n## Syntax\n\n**ChartPanel.MaxValue**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   base.OnRender(chartControl, chartScale);\n \n   // Print the minimum and maximum Y values for objects in the panel\n   Print(String.Format(\"Min value: {0}, Max value: {1}\", ChartPanel.MinValue, ChartPanel.MaxValue));\n}\n```"
  },
  {
    "_id": "eaac1bdb6c594c3a31fed654f05fd03472069255913e872679ed5171da9ffef4",
    "_type": "desktopSdkDoc",
    "title": "PanelIndex",
    "pathName": "panelindex",
    "parent": "chartpanel",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the index of the chart panel in the collection of configured panels.\n\n{% callout type=\"note\" %}\n\nThis property comes from a zero-based index, which is not the same as the panel number displayed in the Indicators window opened from within the chart. The panel number displayed in the Indicators window will equate to **ChartPanel.PanelIndex** + 1.\n\n{% /callout %}\n\n## Property Value\n\nA int representing the zero-based index of the panel.\n\n## Syntax\n\n**ChartPanel.PanelIndex**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    base.OnRender(chartControl, chartScale);\n\n    // Print the panel's zero-based index\n    Print(String.Format(\"This panel sits at index {0}\", ChartPanel.PanelIndex));\n}\n```\n\nNotice three things in the image below:\n\n* An indicator containing the example code above is configured on the second chart panel.\n* In the Indicators window, the \"Panel\" property is set to 2.\n* The output of the example code displays the zero-based index of Panel #2, which is at index 1.\n\n![ChartPanel_PanelIndex](chartpanel_panelindex.png)"
  },
  {
    "_id": "da0db2eeee015ab829d8d91c531292536ad4406f016ce19090e54189beb51707",
    "_type": "desktopSdkDoc",
    "title": "ChartPanel",
    "pathName": "chartpanel",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The **ChartPanel** class includes a range of properties related to the [panel](chart_panels) on which the calling script resides. Each Panel has 3 independent [ChartScales](chartscale): Left, Right, and Overlay.\n\n![ChartPanel_1](chartpanel_1.png)\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* ChartObjects\n* A collection of objects configured on the chart panel\n\n---\n\n* H\n* Indicates the height (in pixels) of the chart panel\n\n---\n\n* IsFocused\n* Indicates the chart panel is currently in focus in the window\n\n---\n\n* IsWaitingForBars\n* Indicates one or more objects in the chart panel are waiting for Bars objects to load or refresh\n\n---\n\n* IsYAxisDisplayedLeft\n* Indicates the y-axis is visible on the left side of the chart panel\n\n---\n\n* IsYAxisDisplayedOverlay\n* Indicates any objects configured in the panel are using the Overlay scale justification\n\n---\n\n* IsYAxisDisplayedRight\n* Indicates the y-axis is visible on the right side of the chart panel\n\n---\n\n* MaxValue\n* Indicates the maximum Y value of objects within the chart panel\n\n---\n\n* MinValue\n* Indicates the minimum Y value of objects within the chart panel\n\n---\n\n* PanelIndex\n* Indicates the index of the chart panel in the collection of configured panels\n\n---\n\n* Scales\n* A collection of [ChartScale](chartscale) objects corresponding to objects within the chart panel\n\n---\n\n* W\n* Indicates the width (in pixels) of the chart panel\n\n---\n\n* X\n* Indicates the x-coordinate on the chart canvas at which the chart panel begins\n\n---\n\n* Y\n* Indicates the y-coordinate on the chart canvas at which the chart panel begins\n\n---\n\n{% /table %}"
  },
  {
    "_id": "6c00c076acc9c2f4b6a0c6403e07c7eb8ca220a10b4750c239cd013f24a8778c",
    "_type": "desktopSdkDoc",
    "title": "Scales",
    "pathName": "scales",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of **ChartScale** objects corresponding to objects within the chart panel.\n\n## Property Value\n\nA **ChartScaleCollection** containing **ChartScale** objects\n\n## Syntax\n\n**ChartPanel.Scales**\n\n## Examples\n\n```csharp\n\nprotected override void OnStateChange()\n{\n   if (State == State.Historical)\n   {\n     // loop through each panel which is currently configured on the hosting chart\n     foreach (ChartPanel chartPanel in ChartControl.ChartPanels)\n     {\n         // there are multiple scale per panel\n         // i.e., Right, Left, Overlay\n         foreach (ChartScale scale in chartPanel.Scales)\n         {\n           // get the right scale margin type\n           if (scale.ScaleJustification == ScaleJustification.Right)\n           {\n               Print(string.Format(\"The Right Scale of panel #{0}'s margin type is {1}\",\n                                   scale.PanelIndex, scale.Properties.AutoScaleMarginType));\n           }\n         }\n     }\n   }\n}\n```\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.Historical)\n   {\n       // Shows us at which index in the Scales collection the individual panel scales reside [0: Right, 1: Left, 2: Overlay]\n       // The Scale collection gets accessed via passing the ScaleJustification enum in as index\n       Print(\"Scales index \" + 0 + \" \" + ChartPanel.Scales[ScaleJustification.Right]);\n       Print(\"Scales index \" + 1 + \" \" + ChartPanel.Scales[ScaleJustification.Left]);\n       Print(\"Scales index \" + 2 + \" \" + ChartPanel.Scales[ScaleJustification.Overlay]);\n   }\n}\n```"
  },
  {
    "_id": "51061b8289e4a16ba83e660839ec0a3a10ba76aea04ec822e0483fd3d1b59a0c",
    "_type": "desktopSdkDoc",
    "title": "IsVisible",
    "pathName": "isvisible",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the chart scale is viewable on the UI. If the bar series, indicator, or strategy which uses the chart scale is not in view, the chart scale **IsVisible** property will return false.\n\n## Property Value\n\nA bool value, which when true the series used to build the scale is viewable; otherwise false. This property is read-only.\n\n## Syntax\n\n**<`chartscale`>.IsVisible**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{         \n   // do not process render info chart scale is not visible\n   if(!chartScale.IsVisible)\n     return;\n}\n```"
  },
  {
    "_id": "fb4f2bb8213b78849db73de8660359b295dfe21c001984ea5bf9c34a34221baf",
    "_type": "desktopSdkDoc",
    "title": "MaxValue",
    "pathName": "maxvalue",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe highest displayed value on the chart scale.\n\n## Property Value\n\nA **double** value representing highest value on the chart scale as a y value.\n\n## Syntax\n\n**<`chartscale`>.MaxValue**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // the maximum value of the chart scale\n   double maxValue   = chartScale.MaxValue;\n\n   Print(\"maxValue: \" + maxValue);\n}\n```\n\nIn the image below, the highest value displayed as text on the y-axis reads 2106.00, however as you can see, there are a few pixels on the chart scale above this tick. The absolute rendered MaxValue on the chart scale is calculated as 2106.21.\n\n![MaxValue](maxvalue.png)"
  },
  {
    "_id": "d5da256da226761b5a7901303db7858cd6137f5e815b042c7dc6815c26462a37",
    "_type": "desktopSdkDoc",
    "title": "MinValue",
    "pathName": "minvalue",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe lowest rendered value on the chart scale.\n\n## Property Value\n\nA **double** value representing the lowest value on the chart scale as a y value.\n\n## Syntax\n\n**<`chartscale>**.MinValue\n\n## Examples\n\n{% callout type=\"note\" %}\n\nIn the image below, the lowest value displayed as text on the y-axis reads 2102.50, however as you can see, there are a few pixels on the chart scale below this tick. The absolute rendered MinValue on the chart scale is calculated as 2102.29.\n\n{% /callout %}\n\n![MinValue](minvalue.png)\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{         \n   // the minimum value of the chart scale\n   double minValue   = chartScale.MinValue;\n\n   Print(\"minValue: \" + minValue);\n}\n```"
  },
  {
    "_id": "96adb92452863058fa1616efcc89c6e7c92a0c49148dfbd3e127ce829a45406e",
    "_type": "desktopSdkDoc",
    "title": "Properties",
    "pathName": "properties",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents a number of properties available to the Chart Scale which can be configured to change the appearance of the scale.\n\n![ChartPanel_Properites](chartpanel_properites.png)\n\n{% callout type=\"note\" %}\n\nWarning: These are UI properties which are designed to be set by a user. Attempting to modify these values through a custom script is NOT guaranteed to take effect.\n\n{% /callout %}\n\n## Property Values\n\n{% table %}\n\n* Property\n* Description\n\n---\n\n* **YAxisRangeType**\n* An **YAxisRangeType** enum, possible values are:\n  * Automatic\n  * Fixed\n\n---\n\n* **AutoScaleDateRangeType**\n* An **AutoScaleDateRangeType** enum, possible values are:\n  * ScreenDateRange\n  * EntireDateRangeSeriesOnly\n\n---\n\n* **HorizontalGridlinesCalculation**\n* An **YAxisRangeType** enum, possible values are:\n  * Automatic\n  * Fixed\n\n---\n\n* **HorizontalGridlinesIntervalType**\n* A **HorizontalGridlinesIntervalType** enum, possible values are:\n  * Ticks\n  * Points\n  * Pips\n\n---\n\n* **HorizontalGridlinesInterval**\n* A **double** value representing the vertical interval of the horizontal axis\n\n---\n\n* **AutoScaleMarginType**\n* An **AutoScaleMarginType** enum, possible values are:\n  * Percent\n  * Price\n\n---\n\n* **AutoScaleMarginLower**\n* A **double** value representing the lowest margin used for the chart scale\n\n---\n\n* **AutoScaleMarginUpper**\n* A **double** value representing the highest margin used for the chart scale\n\n---\n\n* **YAxisScalingType**\n* An **YAxisScalingType** enum, possible values are:\n  * Linear\n  * Logarithmic\n\n---\n\n* **FixedScaleMax**\n* A double representing the highest series value used for the chart scale when the scale is fixed\n\n---\n\n* **FixedScaleMin**\n* A double representing the lowest series value used for the chart scale when the scale is fixed\n{% /table %}\n\n## Syntax\n\n**<`chartscale`>.Properties**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    if (chartScale.Properties.YAxisScalingType == AxisScalingTypeLinear)\n    {\n        // do something\n    }\n}\n```"
  },
  {
    "_id": "62a450a3ae6652a43f41f8094326c58e1577d44b69371951dcdc467e85967cb6",
    "_type": "desktopSdkDoc",
    "title": "ScaleJustification",
    "pathName": "scalejustification",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the location of the chart scale relative to the chart control.\n\n## Property Value\n\nA **ScaleJustification** enum. Possible values are:\n\n* **Right**\n* **Left**\n* **Overlay**\n\n## Syntax\n\n**ScaleJustification**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   if (chartScale.ScaleJustification == ScaleJustification.Right)\n   {\n     // do something\n   }\n\n}\n```"
  },
  {
    "_id": "ecba3488d3e4390f3e1df508ba4a0f14def3a428319af62dc312df2e6354c6a5",
    "_type": "desktopSdkDoc",
    "title": "GetPixelsForDistance()",
    "pathName": "getpixelsfordistance",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the number of device pixels between the value passed to the method representing a series point value on the chart scale.\n\n## Method Return Value\n\nA float representing the number of pixels between a value.\n\n## Syntax\n\n**<`chartscale>**.GetPixelsForDistance(double distance)\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* distance\n* A **double** value representing the distance in points to be measured\n{% /table %}\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // the number of pixels between the point value passed as a distance to the method\n   float pixelForDistance = chartScale.GetPixelsForDistance(0.25);\n\n   Print(\"pixelForDistance: \" + pixelForDistance); //20 pixels per every 1 tick on the chart scale\n\n}\n```\n\nIn the image below, we pass a value of 1 for the distance, which tells us there are 76 pixels for every 1 point on the ES 06-15 chart scale.\n\n![GetPixelsForDistance](getpixelsfordistance.png)"
  },
  {
    "_id": "bc531b328e3b23df0af4035f1396ebf025e48564c5b0d7d95b4465ea990f642e",
    "_type": "desktopSdkDoc",
    "title": "GetSlotIndexByTime()",
    "pathName": "getslotindexbytime",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the slot index relative to the chart control corresponding to a specified time value.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* A \"Slot\" is used in Equidistant [bar spacing](barspacingtype) and represents a position on the chart canvas background which may or may not contain a bar. The concept of \"Slots\" does NOT exist on a TimeBased bar spacing type.  \n* If you are looking for information on a bar series, please see [ChartBars.GetBarIdxByTime()](chartbars_getbaridxbytime).\n{% /callout %}\n\n## Method Return Value\n\nA double representing a slot index.\n\n## Syntax\n\n**<`chartcontrol>**.GetSlotIndexByTime(**DateTime** time)\n\n{% callout type=\"warning\" %}\n\nWarning: This method CANNOT be called on BarSpacingType.TimeBased charts. You will need to ensure an Equidistant [bar spacing type](barspacingtype) is used, otherwise errors will be thrown.\n\n{% /callout %}\n\n## Method Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **time**\n* A [DateTime](https://msdn.microsoft.com/en-us/library/system.datetime(v=vs.110).aspx) Structure used to determine a slot index\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // ensure that GetSlotIndexByTime is called on TimeBased charts\n    if(chartControl.BarSpacingType != BarSpacingType.TimeBased)\n    {\n        // get the slot index of the first time painted on the chart\n        double slotIndex = chartControl.GetSlotIndexByTime(chartControl.FirstTimePainted);\n        \n        Print(slotIndex);\n    }\n}\n```"
  },
  {
    "_id": "4c65f1342fcd0c9117edd30e193e2410142ab5940780d8990c2190ec817b498c",
    "_type": "desktopSdkDoc",
    "title": "GetValueByY()",
    "pathName": "getvaluebyy",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the series value on the chart scale determined by a y pixel coordinate on the chart.\n\n## Method Return Value\n\nA **double** value representing a series value on the chart scale. This is normally a price value, but can represent indicator plot values as well.\n\n## Syntax\n\n**<`chartscale>**.GetValueByY(float y)\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **y**\n* A float value representing a pixel coordinate on the chart scale\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // the price value of the pixel coordinate passed in the method\n   double valueByY =   chartScale.GetValueByY(1);\n\n   Print(\"valueByY: \" + valueByY); //2106.19693333\n}\n```\n\nIn the image below, we pass a value of 1 for the y value, which tells us the pixel coordinate of 1 is located at a price of 2106.19 on the chart scale.\n\n![getvaluebyY](getvaluebyy.png)"
  },
  {
    "_id": "a4370c039878447f3d8895b4bdc678e56d642003e4823533ac8180a2fc94f7bc",
    "_type": "desktopSdkDoc",
    "title": "GetValueByYWpf()",
    "pathName": "getvaluebyywpf",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the series value on the chart scale determined by a WPF coordinate on the chart.\n\n## Method Return Value\n\nA **double** value representing a series value on the chart scale. This is normally a price value, but can represent indicator plot values as well.\n\n## Syntax\n\n**<`chartscale>**.GetValueByYWpf(double y)\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **y**\n* A **double** value representing a WPF coordinate on the chart scale\n{% /table %}\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // store the y location the user clicked\n   double   wpfY = chartControl.MouseDownPoint.Y;\n\n   // gets price value of the WPF coordinate passed to the method\n   double   valueByYWpf = chartScale.GetValueByYWpf(wpfY);\n\n   Print(\"valueByYWpf: \" + valueByYWpf); //2105.49995215\n}\n```\n\nIn the image below, we used the Chart Control property **MouseDownPoint** as the \"wpfy\" variable, which in return tells us the user clicked on a Y value of 2105.499 on the chart scale.\n\n![getvaluebyywpf](getvaluebyywpf.png)"
  },
  {
    "_id": "5fb11277f06023ce9ac3d32b3ebe80b39a2030a1fd00218f85818a52db4ec0ee",
    "_type": "desktopSdkDoc",
    "title": "GetYByValue()",
    "pathName": "getybyvalue",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the chart's y-pixel coordinate on the chart determined by a series value represented on the chart scale.\n\n## Method Return Value\n\nAn **int** value representing a y pixel coordinate on the chart scale.\n\n## Syntax\n\n**<`chartscale>.GetYByValue(double val)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **val**\n* A **double** value which usually represents a price or indicator value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // gets the pixel coordinate of the price value passed to the method\n   int     yByValue = chartScale.GetYByValue(Bars.GetClose(Bars.Count - 1));\n\n   Print(\"yByValue: \" + yByValue); // 207\n}\n```\n\nIn the image below, we pass the last bar close as the value (example logic avoids using a bars ago index, see also [OnRender()](onrender) note #5), which in return tells us the last price displayed on the chart is at a y location of 207 pixels.\n\n![getybyvalue](getybyvalue.png)"
  },
  {
    "_id": "f94207e022757d12af4ac8fc0c490057f00706e2599f4610afa00b4259d15eb0",
    "_type": "desktopSdkDoc",
    "title": "GetYByValueWpf()",
    "pathName": "getybyvaluewpf",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a WPF coordinate on the chart determined by a series value represented on the chart scale.\n\n## Method Return Value\n\nAn double value representing a WPF coordinate on the chart scale.\n\n## Syntax\n\n**<`chartscale>**.GetYByValueWpf(**double val**)\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **val**\n* A **double** value which usually represents a price or indicator value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // gets the wpf coordinate of the price value passed to the method\n   int     valueByYWpf = chartScale.GetYByValueWpf(Bars.GetClose(Bars.Count - 1));\n\n   Print(\"valueByYWpf: \" + valueByYWpf); // 207\n}\n```\n\nIn the image below, we pass the last bar close as the value (example logic avoids using a bars ago index, see also [**OnRender()**](onrender) note #5), which in return tells us the last price displayed on the chart is at a WPF location of 207.30998 pixels.\n\n![GetYByValueWpf](getybyvaluewpf.png)"
  },
  {
    "_id": "39e0f5efdc39ec10992833ad019f0ddf2b42b49b098313df991b8229a37aed21",
    "_type": "desktopSdkDoc",
    "title": "Height",
    "pathName": "height",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the overall distance (from top to bottom) of the chart scale.\n\n## Note\n\n{% callout type=\"note\" %}\n\nHeight does not return its value in terms of device pixels. However, using **Height.ConvertToVerticalPixels** or **Height.ConvertToHorizontalPixels** will convert the Height value to device pixels. Alternatively, **RenderTarget.PixelSize.Height** or **ChartPanel.H** will also provide the height in terms of device pixels.\n\n{% /callout %}\n\n## Property Value\n\nA **double** value representing the height of the chart scale.\n\n## Syntax\n\n**<`chartscale`>.Height**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // the height of the entire chart scale\n   double   height       = chartScale.Height;\n   Print(\"the height of the chart scale is: \" + height);  \n}\n```\n\nIn the image below, the entire height of the chart scale is represented by the blue line which is calculated at 300 pixels.\n\n![Height](height.png)"
  },
  {
    "_id": "55df740ff315be3f1ba624b98af38a2740a3a05104fb3c6def78d90b05290615",
    "_type": "desktopSdkDoc",
    "title": "MaxMinusMin",
    "pathName": "maxminusmin",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe difference between the chart scale's **MaxValue** and **MinValue** represented as a y value.\n\n## Property Value\n\nA **double** value representing the difference in scale as a y value.\n\n## Syntax\n\n<chartscale`>.MaxMinusMin\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // the difference between the scales maximum and minimum value\n   double   maxMinusMin = chartScale.MaxMinusMin;\n\n   Print(\"maxMinusMin: \" + maxMinusMin); // maxMinusMin: 3.92\n}\n```\n\nIn the image below, the highest calculated value on the chart scale is 2106.21, with the lowest value being 2102.29; the MaxMinusMin property therefore provides us calculated value of 3.92.\n\n![MaxMinusMin](maxminusmin.png)"
  },
  {
    "_id": "eaac1bdb6c594c3a31fed654f05fd03472069255913e872679ed5171da9ffef4",
    "_type": "desktopSdkDoc",
    "title": "PanelIndex",
    "pathName": "panelindex",
    "parent": "chartscale",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe panel on which the chart scale resides.\n\n{% callout type=\"note\" %}\n\nThis value is NOT the same value as the indicator's **PanelUI**. **PanelIndex** will provide the actual indexed value of the chart panel used for this chart scale.\n\n{% /callout %}\n\n## Property Value\n\nAn **int** value representing the panel as an index value which starts at 0 and will increment for each panel configured on the chart. This property is read-only.\n\n## Syntax\n\n**<`chartscale>.PanelIndex**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{         \n   // the index value of the panel (not the same as the panelUI)\n   int     panel     = chartScale.PanelIndex;\n   Print(\"panel: \" + panel);\n}\n```"
  },
  {
    "_id": "0b6f95f76e6f6e5e03e920225af88f94f55a30d8c9017fdf86be28d2c8ecd969",
    "_type": "desktopSdkDoc",
    "title": "ChartScale",
    "pathName": "chartscale",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The **ChartScale** class includes a range of properties related to the Y-Axis values of the [**ChartPanel**](chartpanel) on which the calling script resides. The **ChartScale** can be configured to Right, Left, or Overlay.\n\n![ChartScale_1](chartscale_1.png)\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [**GetPixelsForDistance()**](getpixelsfordistance)\n* Returns the number of device pixels between the value passed to the method representing a series point value on the chart scale\n\n---\n\n* [**GetValueByY()**](source_markdown_files/todo/getvaluebyy)\n* Returns the series value on the chart scale determined by a y pixel coordinate on the chart\n\n---\n\n* [**GetValueByYWpf()**](getvaluebyywpf)\n* Returns the series value on the chart scale determined by a WPF coordinate on the chart\n\n---\n\n* [**GetYByValue()**](source_markdown_files/todo/getybyvalue)\n* Returns the chart's y-pixel coordinate on the chart determined by a series value represented on the chart scale\n\n---\n\n* [**GetYByValueWpf()**](source_markdown_files/todo/getybyvaluewpf)\n* Returns a WPF coordinate on the chart determined by a series value represented on the chart scale\n\n---\n\n* [**Height**](height)\n* Indicates the overall distance (from top to bottom) of the chart scale in device pixels\n\n---\n\n* [**IsVisible**](chartscale_isvisible)\n* Indicates if the chart scale is viewable on the UI\n\n---\n\n* [**MaxMinusMin**](source_markdown_files/todo/maxminusmin)\n* The difference between the chart scale's [**MaxValue**](source_markdown_files/todo/chartscale_maxvalue) and [**MinValue**](source_markdown_files/todo/chartscale_minvalue) represented as a y value\n\n---\n\n* [**MaxValue**](source_markdown_files/todo/chartscale_maxvalue)\n* The highest displayed value on the chart scale\n\n---\n\n* [**MinValue**](source_markdown_files/todo/chartscale_minvalue)\n* The lowest rendered value on the chart scale\n\n---\n\n* [**PanelIndex**](panelindex)\n* The panel on which the chart scale resides\n\n---\n\n* [**Properties**](source_markdown_files/todo/chartscale_properties)\n* Represents a number of properties available to the Chart Scale which can be configured to change the appearance of the scale\n\n---\n\n* [**ScaleJustification**](source_markdown_files/todo/chartscale_scalejustification)\n* Indicates the location of the chart scale relative to the chart control\n\n---\n\n* [**Width**](width.md)\n* Indicates the overall distance (from left to right) of the chart scale in device pixels\n{% /table %}"
  },
  {
    "_id": "8f966a61234266061addecb1b4baac4d478770a59cf220b51075ba029a89dfba",
    "_type": "desktopSdkDoc",
    "title": "FormatPriceMarker()",
    "pathName": "formatpricemarker",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nUsed to override the default string format of a NinjaScript's price marker values.\n\n## Method Return Value\n\nA **virtual** string which is overridden from the default price marker value.\n\n## Syntax\n\nYou must override the method in your indicator with the following syntax:\n\n**public override string FormatPriceMarker(double price)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* price\n* A **double** value representing the value to be overridden.\n{% /table %}\n\n## Tip\n\nTip: Standard Numeric Format Strings examples can be found on Microsoft's Developer Network ([MSDN article](https://msdn.microsoft.com/en-us/library/dwhawy9k%28v=vs.110%29.aspx)).\n\n## Examples\n\n```csharp\n// FormatPriceMarker method of a custom indicator\npublic override string FormatPriceMarker(double price)\n{\n     // Formats price marker values to 4 decimal places\n     return price.ToString(\"N4\");\n}\n\nprotected override void OnBarUpdate()\n{\n   // overriding FormatPriceMarker will ensure display of 4 decimal places\n   MyPlot[0] = (Close[0] + Open[0] * .0025);  \n}\n```"
  },
  {
    "_id": "ebb80cb0b30c5650529ab8a132e6bac0033726e1d7a84b20837a2d08f105f264",
    "_type": "desktopSdkDoc",
    "title": "IsAutoScale",
    "pathName": "isautoscale",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIf true, the object will call **CalculateMinMax()** in order to determine the object's **MinValue** and **MaxValue** value used to scale the Y-axis of the chart.\n\n## Property Value\n\nThis property returns true if the object's are included in the y-scale; otherwise, false. Default set to false for **DrawingTools**, but set to true for **Indicators**.\n\n{% callout type=\"warning\" %}\n\nThis property should ONLY be set from the **OnStateChange()** method during State.SetDefaults or State.Configure.\n\n{% /callout %}\n\n## Syntax\n\n**IsAutoScale**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {         \n     Name                 = \"Example Indicator\";         \n     // set this to true to call CalculateMinMix() to ensure drawing tool is fully rendered in chart scale\n     IsAutoScale = true;  \n   }\n   else if (State == State.Configure)\n   {\n   }\n}\n```"
  },
  {
    "_id": "1eb7d55d93df71133e5c587dad351d06c33fa8cb3ec1fa4823259c9b9eb459fb",
    "_type": "desktopSdkDoc",
    "title": "IsOverlay",
    "pathName": "isoverlay",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines if indicator plot(s) are drawn on the chart panel over top of price. Setting this value to true will also allow an Indicator to be used as a [SuperDOM Indicator](working_with_indicators_superdom).\n\n## Property Value\n\nThis property returns true if any indicator plot(s) are drawn on the chart panel; otherwise, false. Default set to false.\n\n{% callout type=\"warning\" %}\nThis property should ONLY be set from the **OnStateChange()** method during **State.SetDefaults**.\n{% /callout %}\n\n## Syntax\n\n**IsOverlay**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.SetDefaults)\n    {\n        IsOverlay = true; // Indicator plots are drawn on the chart panel on top of price     \n        AddPlot(Brushes.Orange, \"SMA\");\n    }\n}\n```"
  },
  {
    "_id": "1eb7d55d93df71133e5c587dad351d06c33fa8cb3ec1fa4823259c9b9eb459fb",
    "_type": "desktopSdkDoc",
    "title": "isoverlay",
    "pathName": "isoverlay",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines if indicator plot(s) are drawn on the chart panel over top of price.  Setting this value to true will also allow an Indicator to be used as a [SuperDOM Indicator](working_with_indicators_superdom.htm).\n\n## Property Value\n\nThis property returns true if any indicator plot(s) are drawn on the chart panel; otherwise, false. Default set to false.\n\n{% callout type=\"warning\" %}\n\nThis property should ONLY be set from the [OnStateChange()](onstatechange) method during State.SetDefaults\n\n{% /callout %}\n\n## Syntax\n\n**IsOverlay**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange() \n{ \n    if (State == State.SetDefaults) \n    { \n        IsOverlay = true; // Indicator plots are drawn on the chart panel on top of price     \n        AddPlot(Brushes.Orange, \"SMA\"); \n    } \n}\n```"
  },
  {
    "_id": "cb4634aab1dfaaf64871362563cea953ec6b57d7dcdceb72c7e13f2fc61f1383",
    "_type": "desktopSdkDoc",
    "title": "IsSeparateZOrder",
    "pathName": "isseparatezorder",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines the **ZOrder** of the drawing object will be different than the **NinjaScript** object that drew it. When false the drawing object will share the same ZOrder.\n\n## Property Value\n\nThis property returns true if the object is drawn on a separate ZOrder; otherwise, false. Default set to false.\n\n## Syntax\n\n**IsSeparateZOrder**\n\n## Examples\n\n```csharp\n\nprotected override void OnBarUpdate()\n{\n   // Instantiate a Dot object\n   Dot myDot = Draw.Dot(this, \"NewDot\", true, 5, High[5], Brushes.Black);\n \n   // Set the Dot object to use a separate Z-Order than the indicator that created it\n   myDot.IsSeparateZOrder = true;\n}\n```"
  },
  {
    "_id": "cb4634aab1dfaaf64871362563cea953ec6b57d7dcdceb72c7e13f2fc61f1383",
    "_type": "desktopSdkDoc",
    "title": "isseparatezorder",
    "pathName": "isseparatezorder",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines the [ZOrder](chart_zorder.htm) of the drawing object will be different than the NinjaScript object that drew it.  When false the drawing object will share the same ZOrder.\n\n## Property Value\n\nThis property returns true if the object is drawn on a separate ZOrder; otherwise, false. Default set to false.\n\n## Syntax\n\n**IsSeparateZOrder**\n\n## Example\n\n```csharp\nprotected override void OnBarUpdate()  \n{  \n  // Instantiate a Dot object  \n  Dot myDot = Draw.Dot(this, \"NewDot\", true, 5, High[5], Brushes.Black);  \n   \n  // Set the Dot object to use a separate Z-Order than the indicator that created it  \n  myDot.IsSeparateZOrder = true;  \n}\n```"
  },
  {
    "_id": "f748f8d90516c1cecee83006e3c9de6c9117affdf9c6e42e0b450195ed88bac8",
    "_type": "desktopSdkDoc",
    "title": "Rendering",
    "pathName": "rendering",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "Rendering methods and properties can be useful when carrying out custom drawing tasks for chart objects. Event handlers such as **OnCalculateMinMax()** and **OnRender()** allow you to override behavior at key points in the rendering process.\n\n{% callout type=\"note\" %}\n\n1. Some rendering methods and properties make use of [SharpDX](http://sharpdx.org/) libraries, which provide a managed framework for working with DirectX technology. Please see the [SharpDX SDK Reference](sharpdx_sdk_reference) for more information.\n2. For a walk through for using the SharpDX, please see the educational resource [Using SharpDX for Custom Chart Rendering](using_sharpdx_for_custom_chart_rendering).\n{% /callout %}\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [RenderTarget](rendertarget)\n* Creates objects and exposes methods used for drawing in the chart area.\n\n---\n\n* [ForceRefresh()](forcerefresh)\n* Forces **OnRender()** to be called, which will re-paint the chart.\n\n---\n\n* [IsInHitTest](isinhittest)\n* Qualifies if object drawn in chart object should be selectable in the hit test procedure.\n\n---\n\n* [IsSelected](isselected)\n* Indicates a chart object is currently selected.\n\n---\n\n* [IsVisibleOnChart()](isvisibleonchart)\n* Indicates a chart object is visible on the chart canvas.\n\n---\n\n* [MaxValue](maxvalue)\n* The maximum value used for the automatic scaling of the y axis.\n\n---\n\n* [MinValue](minvalue)\n* The minimum value used for the automatic scaling of the y axis.\n\n---\n\n* [OnCalculateMinMax()](oncalculateminmax)\n* An event driven method which is called while the chart scale is being updated.\n\n---\n\n* [OnRender()](onrender)\n* Used to render custom drawing to a chart from various chart objects.\n\n---\n\n* [OnRenderTargetChanged()](onrendertargetchanged)\n* Used for efficient handling of SharpDX resources.\n\n---\n\n* [PanelUI](panelui)\n* The chart panel that is configured on the chart's UI.\n\n---\n\n* [ZOrder](chart_zorder)\n* A unique identifier used to control the order in which chart objects are drawn on the chart's Z-axis.\n{% /table %}"
  },
  {
    "_id": "62a450a3ae6652a43f41f8094326c58e1577d44b69371951dcdc467e85967cb6",
    "_type": "desktopSdkDoc",
    "title": "ScaleJustification",
    "pathName": "scalejustification",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines which scale an indicator will be plotted on.\n\n{% callout type=\"warning\" %}\n\nThis property should ONLY be set from the **OnStateChange()** method during **State.SetDefaults** or **State.Configure**.\n\n{% /callout %}\n\n## Property Value\n\nThis property returns a **ScaleJustification** value of either:\n\n* **NinjaTrader.Gui.Charts.ScaleJustification.Left**\n* **NinjaTrader.Gui.Charts.ScaleJustification.Overlay**\n* **NinjaTrader.Gui.Charts.ScaleJustification.Right**\n\n## Syntax\n\n**ScaleJustification**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{       \n   if (State == State.SetDefaults)\n   {\n     Name = \"Examples Indicator\";  \n\n     // force \"My Plot\" to be plotted on the left scale\n     ScaleJustification = ScaleJustification.Left;  \n   }\n   else if (State == State.Configure)\n   {                \n     AddPlot(Brushes.Orange, \"My Plot\");\n   }\n}\n```"
  },
  {
    "_id": "4675f7a22cb3e8703984b50a187f8d6d2790c2d2353279ebd31ff1bc2daa22e0",
    "_type": "desktopSdkDoc",
    "title": "Stroke Class",
    "pathName": "stroke_class",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nObjects derived from the **Stroke** class are used to characterize how a plot is visually displayed (plotted) on a chart.\n\n## Syntax\n\n**Stroke(Stroke stroke)**\n\n**Stroke(Brush brush)**\n\n**Stroke(Brush brush, float width)**\n\n**Stroke(Brush brush, DashStyle dashStyleHelper, float width)**\n\n## Parameters\n\n{% table %}\n\n* brush\n* The brush used to draw the plot ([reference](http://msdn.microsoft.com/en-us/library/System.Windows.Media.Brush%28v=vs.110%29.aspx))\n\n---\n\n* dashStyleHelper\n* Possible values:\n  * **DashStyleHelper.Dash**\n  * **DashStyleHelper.DashDot**\n  * **DashStyleHelper.DashDotDot**\n  * **DashStyleHelper.Dot**\n  * **DashStyleHelper.Solid**\n\n---\n\n* stroke\n* The [stroke](stroke_class.htm) object\n\n---\n\n* width\n* The width of the stroke\n{% /table %}\n\n## Properties\n\n{% table %}\n\n* Brush\n* The System.Windows.Media.Brush used to construct the stroke ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx))\n\n---\n\n* BrushDX\n* A **SharpDX.Direct2D1.Brush** used to actually render the stroke\n  {% callout type=\"note\" %}\n  To avoid and resolve access violation exceptions, please see Warning and examples remarked below.\n  {% /callout %}\n\n---\n\n* DashStyleDX\n* A **SharpDX.Direct2D1.DashStyle** used to render the stroke style\n  {% callout type=\"note\" %}\n  To avoid and resolve access violation exceptions, please see Warning and examples remarked below.\n  {% /callout %}\n\n---\n\n* DashStyleHelper\n* A dashstyle used to construct the stroke. Possible values are:\n  * **DashStyleHelper.Dash**\n  * **DashStyleHelper.DashDot**\n  * **DashStyleHelper.DashDotDot**\n  * **DashStyleHelper.Dot**\n  * **DashStyleHelper.Solid**\n\n---\n\n* RenderTarget\n* The [RenderTarget](rendertarget.htm) drawing context used for the stroke.\n  {% callout type=\"note\" %}\n  This property must be set before accessing a stroke's BrushDX property. Please see Warning and examples remarked below.\n  {% /callout %}\n\n---\n\n* StrokeStyle\n* A **SharpDX.Direct2D1.StrokeStyle**\n\n---\n\n* Width\n* A float representing the width in pixels\n{% /table %}\n\n{% table %}\n---\n\n* Warning: There may be situations where a RenderTarget has not been set, and to prevent access violation exception before accessing the BrushDX or DashStyleDX properties, you should explicitly set the RenderTarget before attempting to access that property. Please see the example below.\n{% /table %}\n\n## Examples\n\nSee the [AddPlot()](addplot.htm) method for additional examples.\n\n### Using a Stroke SharpDX Brush for Custom Rendering\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.SetDefaults)\n    {\n        IsOverlay = true;\n        // set the Stroke default to red brush\n        MyStroke = new Stroke(Brushes.Red);\n    }\n    else if (State == State.Configure)\n    {\n    }\n}\n\npublic override void OnRenderTargetChanged()\n{\n    // Explicitly set the Stroke RenderTarget\n    if (RenderTarget != null)\n        MyStroke.RenderTarget = RenderTarget;\n}\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // create two points from the top left corner\n    SharpDX.Vector2 pointA = new SharpDX.Vector2(0, 0);\n    // to 300 pixels offset X and Y to create a diagonal line\n    SharpDX.Vector2 pointB = new SharpDX.Vector2(300, 300);\n\n    // Draw the line using the Stroke SharpDX brush\n    RenderTarget.DrawLine(pointA, pointB, MyStroke.BrushDX, MyStroke.Width, MyStroke.StrokeStyle);\n}\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.SetDefaults)\n    {\n        IsOverlay = true;\n        // set stroke default to blue brush\n        MyStroke = new Stroke(Brushes.Blue);\n    }\n    else if (State == State.Configure)\n    {\n    }\n}\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    // create two points from the top left corner\n    SharpDX.Vector2 pointA = new SharpDX.Vector2(0, 0);\n    // to 300 pixels offset X and Y to create a diagonal line\n    SharpDX.Vector2 pointB = new SharpDX.Vector2(300, 300);\n\n    NinjaTrader.Gui.Stroke MyStroke = new Stroke(Brushes.Blue);\n\n    // if BrushDX is null, convert the constructed brush to a DX brush\n    SharpDX.Direct2D1.Brush myBrush = MyStroke.BrushDX ?? MyStroke.Brush.ToDxBrush(RenderTarget);\n    RenderTarget.DrawLine(pointA, pointB, myBrush, MyStroke.Width, MyStroke.StrokeStyle);\n\n    myBrush.Dispose();\n}\n```"
  },
  {
    "_id": "4675f7a22cb3e8703984b50a187f8d6d2790c2d2353279ebd31ff1bc2daa22e0",
    "_type": "desktopSdkDoc",
    "title": "stroke_class",
    "pathName": "stroke_class",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nObjects derived from the Stroke class are used to characterize how a plot is visually displayed (plotted) on a chart.\n\n## Syntax\n\n**Stroke(Stroke stroke)**\n\n**Stroke(Brush brush)**\n\n**Stroke(Brush brush, float width)**\n\n**Stroke(Brush brush, DashStyle dashStyleHelper, float width)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* brush\n* The brush used to draw the plot ([reference](http://msdn.microsoft.com/en-us/library/System.Windows.Media.Brush%28v=vs.110%29.aspx))\n\n---\n\n* dashStyleHelper\n* Possible values:\n  * DashStyleHelper.Dash\n  * DashStyleHelper.DashDot\n  * DashStyleHelper.DashDotDot\n  * DashStyleHelper.Dot\n  * DashStyleHelper.Solid\n\n---\n\n* stroke\n* The [stroke](stroke_class.htm) object\n\n---\n\n* width\n* The width of the stroke\n{% /table %}\n\n## Properties\n\n{% table %}\n\n---\n\n* Brush\n* The System.Windows.Media.Brush used to construct the stroke ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx))\n\n---\n\n* BrushDX\n* A [SharpDX.Direct2D1.Brush](sharpdx_direct2d1_brush.htm) used to actually render the stroke\n  Note:  To avoid and resolve access violation exceptions, please see Warning and examples remarked below\n\n---\n\n* DashStyleDX\n* A [SharpDX.Direct2D1.DashStyle](sharpdx_direct2d1_strokestyle_dashstyle.htm) used to render the stroke style\n  Note:  To avoid and resolve access violation exceptions, please see Warning and examples remarked below\n\n---\n\n* DashStyleHelper\n* A dashstyle used to construct the stroke. Possible values are:\n  * DashStyleHelper.Dash\n  * DashStyleHelper.DashDot\n  * DashStyleHelper.DashDotDot\n  * DashStyleHelper.Dot\n  * DashStyleHelper.Solid\n\n---\n\n* RenderTarget\n* The [RenderTarget](rendertarget.htm) drawing context used for the stroke.\n\nNote: This property must be set before accessing a stroke's BrushDX property. Please see Warning and examples remarked below\n\n---\n\n* StrokeStyle\n* A [SharpDX.Direct2D1.StrokeStyle](sharpdx_direct2d1_strokestyle.htm)\n\n---\n\n* Width\n* A float representing the width in pixels\n{% /table %}\n\n{% callout type=\"warning\" %}\n\nThere may be situations where a RenderTarget has not been set, and to prevent access violation exception before accessing the BrushDX or DashStyleDX properties, you should explicitly set the RenderTarget before attempting to access that property.  Please see the example below.\n\n{% /callout %}\n\n## Examples\n\nSee the [AddPlot()](addplot.htm) method for additional examples.\n\n### Using a Stroke SharpDX Brush for Custom Rendering\n\n```csharp\nprotected override void OnStateChange()  \n{  \n  if (State == State.SetDefaults)  \n  {  \n    IsOverlay = true;  \n    // set the Stroke default to red brush  \n    MyStroke = new Stroke(Brushes.Red);  \n  }  \n  else if (State == State.Configure)  \n  {  \n  }  \n}  \n\npublic override void OnRenderTargetChanged()  \n{  \n  // Explicitly set the Stroke RenderTarget  \n  if (RenderTarget != null)  \n    MyStroke.RenderTarget = RenderTarget;  \n}  \n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)  \n{  \n  // create two points from the top left corner  \n  SharpDX.Vector2 pointA = new SharpDX.Vector2(0, 0);  \n  // to 300 pixels offset X and Y to create a diagonal line  \n  SharpDX.Vector2 pointB = new SharpDX.Vector2(300, 300);  \n\n  // Draw the line using the Stroke SharpDX brush  \n  RenderTarget.DrawLine(pointA, pointB, MyStroke.BrushDX, MyStroke.Width, MyStroke.StrokeStyle);  \n\n}  \n\n[NinjaScriptProperty]  \n[Description(\"My Stroke\")]  \npublic Stroke MyStroke { get; set; }\n```\n\n```csharp\nprotected override void OnStateChange()  \n{  \n  if (State == State.SetDefaults)  \n  {  \n    IsOverlay = true;  \n    // set stroke default to blue brush  \n    MyStroke = new Stroke(Brushes.Blue);  \n  }  \n  else if (State == State.Configure)  \n  {  \n  }  \n}  \n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)  \n{  \n  // create two points from the top left corner  \n  SharpDX.Vector2 pointA = new SharpDX.Vector2(0, 0);  \n  // to 300 pixels offset X and Y to create a diagonal line  \n  SharpDX.Vector2 pointB = new SharpDX.Vector2(300, 300);  \n\n  NinjaTrader.Gui.Stroke MyStroke = new Stroke(Brushes.Blue);  \n\n  // if BrushDX is null, convert the constructed brush to a DX brush  \n  SharpDX.Direct2D1.Brush myBrush = MyStroke.BrushDX ?? MyStroke.Brush.ToDxBrush(RenderTarget);  \n  RenderTarget.DrawLine(pointA, pointB, myBrush, MyStroke.Width, MyStroke.StrokeStyle);  \n\n  myBrush.Dispose();  \n}  \n\n[NinjaScriptProperty]  \n[Description(\"My Stroke\")]  \npublic Stroke MyStroke { get; set; }\n```"
  },
  {
    "_id": "3616f6ac6cbe5ee6eaa32924e6292f00f228f89c54559adae90a95c0dcb9b3a6",
    "_type": "desktopSdkDoc",
    "title": "UserControlCollection",
    "pathName": "usercontrolcollection",
    "parent": "charts",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn [observable collection](https://msdn.microsoft.com/en-us/library/ms668604(v=vs.110).aspx) of 3rd party [framework elements](https://msdn.microsoft.com/en-us/library/system.windows.frameworkelement(v=vs.110).aspx), the purpose of which is to allow developers to add a custom control to the chart (e.g., add a button or create your own data grid). This framework collection resides on top of the [ChartControl](chartcontrol.htm) in order to prevent 3rd party custom controls from interfering with native NinjaTrader chart framework members.  For example, if you wish to add a button to a chart, it is recommended to add it to this UserControlCollection rather than attempting to modify or add to any pre-existing NinjaTrader chart elements.  \n\n{% callout type=\"note\" %}\n\nNotes:\n\n1.This collection is provided \"as-is\" and does NOT contain any automatic layout options.  By default, the last added framework element will reside on top of any previously added controls.  This means it is possible for a user to install two NinjaScript objects which may be competing for an area of a chart.\n\n2.Once the NinjaScript object is removed from the chart by the user, the custom control will be automatically removed from the collection.\n{% /callout %}\n\n{% callout type=\"warning\" %}\n\nWarnings:\n\n1. This property should ONLY be accessed once your NinjaScript object has reached State.Historical or later\n\n2. You MUST use a [Dispatcher](https://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcher(v=vs.110).aspx) in order to account for any UI threading errors.  Please see the example below for proper usage\n\n3. It is imperative that you dispose of any custom control resources in State.Terminated to ensure there are no leaks between instances of the object\n{% /callout %}\n\n## Property Value\n\nObservableCollection<System.Windows.FrameworkElement>\n\n## Syntax\n\n**UserControlCollection[int idx]**\n\n## Examples\n\n```csharp\nprivate System.Windows.Controls.Button myBuyButton;  \nprivate System.Windows.Controls.Button mySellButton;  \nprivate System.Windows.Controls.Grid   myGrid;  \n\n// Define a custom event method to handle our custom task when the button is clicked  \nprivate void OnMyButtonClick(object sender, RoutedEventArgs rea)  \n{  \n  System.Windows.Controls.Button button = sender as System.Windows.Controls.Button;  \n  if (button != null)  \n    Print(button.Name + \" Clicked\");  \n}  \n   \nprotected override void OnStateChange()  \n{  \n  if (State == State.SetDefaults)  \n  {  \n    Name         = \"SampleAddButton\";  \n    Description   = \"Adds a custom control to the chart\";  \n    IsOverlay     = true;  \n  }  \n  else if (State == State.Configure)  \n  {  \n  }  \n   \n  // Once the NinjaScript object has reached State.Historical, our custom control can now be added to the chart  \n  else if (State == State.Historical)  \n  {  \n    // Because we're dealing with UI elements, we need to use the Dispatcher which created the object  \n    // otherwise we will run into threading errors...  \n    // e.g, \"Error on calling 'OnStateChange' method: You are accessing an object which resides on another thread.\"  \n    // Furthermore, we will do this operation Asynchronously to avoid conflicts with internal NT operations  \n    ChartControl.Dispatcher.InvokeAsync((() =>  \n    {  \n        // Grid already exists  \n        if (UserControlCollection.Contains(myGrid))  \n          return;  \n   \n        // Add a control grid which will host our custom buttons  \n        myGrid = new System.Windows.Controls.Grid  \n        {  \n          Name = \"MyCustomGrid\",  \n          // Align the control to the top right corner of the chart  \n          HorizontalAlignment = HorizontalAlignment.Right,  \n          VerticalAlignment = VerticalAlignment.Top,  \n        };  \n   \n        // Define the two columns in the grid, one for each button  \n        System.Windows.Controls.ColumnDefinition column1 = new System.Windows.Controls.ColumnDefinition();  \n        System.Windows.Controls.ColumnDefinition column2 = new System.Windows.Controls.ColumnDefinition();  \n   \n        // Add the columns to the Grid  \n        myGrid.ColumnDefinitions.Add(column1);  \n        myGrid.ColumnDefinitions.Add(column2);  \n   \n        // Define the custom Buy Button control object  \n        myBuyButton = new System.Windows.Controls.Button  \n        {  \n          Name = \"MyBuyButton\",  \n          Content = \"LONG\",  \n          Foreground = Brushes.White,  \n          Background = Brushes.Green  \n        };  \n   \n        // Define the custom Sell Button control object  \n        mySellButton = new System.Windows.Controls.Button  \n        {  \n          Name = \"MySellButton\",  \n          Content = \"SHORT\",  \n          Foreground = Brushes.White,  \n          Background = Brushes.Red  \n        };  \n   \n        // Subscribe to each buttons click event to execute the logic we defined in OnMyButtonClick()  \n        myBuyButton.Click += OnMyButtonClick;  \n        mySellButton.Click += OnMyButtonClick;  \n   \n        // Define where the buttons should appear in the grid  \n        System.Windows.Controls.Grid.SetColumn(myBuyButton, 0);  \n        System.Windows.Controls.Grid.SetColumn(mySellButton, 1);  \n   \n        // Add the buttons as children to the custom grid  \n        myGrid.Children.Add(myBuyButton);  \n        myGrid.Children.Add(mySellButton);  \n   \n        // Finally, add the completed grid to the custom NinjaTrader UserControlCollection  \n        UserControlCollection.Add(myGrid);  \n   \n    }));  \n  }  \n   \n  // When NinjaScript object is removed, make sure to unsubscribe to button click events  \n  else if (State == State.Terminated)  \n  {  \n    if (ChartControl == null)  \n        return;  \n   \n    // Again, we need to use a Dispatcher to interact with the UI elements  \n    ChartControl.Dispatcher.InvokeAsync((() =>  \n    {  \n        if (myGrid != null)  \n        {  \n          if (myBuyButton != null)  \n          {  \n              myGrid.Children.Remove(myBuyButton);  \n              myBuyButton.Click -= OnMyButtonClick;  \n              myBuyButton = null;  \n          }  \n          if (mySellButton != null)  \n          {  \n              myGrid.Children.Remove(mySellButton);  \n              mySellButton.Click -= OnMyButtonClick;  \n              mySellButton = null;  \n          }  \n        }  \n    }));  \n  }  \n}\n\n```\n\n![AddOnFrameWorkExample2](addonframeworkexample2.png)"
  },
  {
    "_id": "b5d61dc89a35d2c924b28c9760765da94039e94184c50f87dde54532f126b4ac",
    "_type": "desktopSdkDoc",
    "title": "Clone()",
    "pathName": "clone",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nUsed to override the default **NinjaScript** **Clone()** method which is called any time an instance of a **NinjaScript** object is created. By default, the **NinjaScript** **Clone()** method will copy all the [Property Info](https://msdn.microsoft.com/en-us/library/system.reflection.propertyinfo%28v=vs.110%29.aspx) and [Browsable Attributes](https://msdn.microsoft.com/en-us/library/system.componentmodel.browsableattribute%28v=vs.110%29.aspx) to the new instance when the object is created (e.g., when an optimization is ran a new instance of the strategy will be created for each iteration). However, it is possible to override this behavior if desired for custom development. There is no requirement to override the **Clone** behavior and this method will use the default constructor if not overridden.\n\n{% callout type=\"note\" %}\n\nThis method is reserved for advanced developers who would like to change the default behavior when a **NinjaScript** object is created.\n\n{% /callout %}\n\n## Method Return Value\n\nA [virtual](https://msdn.microsoft.com/en-us/library/9fkccyh4.aspx) object representing the **NinjaScript** type.\n\n## Syntax\n\n**public override object Clone()**\n\n## Parameters\n\nThis method does not take any parameters.\n\n## Examples\n\n```csharp\n\npublic override object Clone()\n{\n   // custom logic to handle before the base clone\n\n   return base.Clone();\n\n // custom logic to hand after the base clone\n}\n```"
  },
  {
    "_id": "c9046f7a37ad0ea7cee73355984fa5428982f8b37c8f7bcec91f7ac71a7cd104",
    "_type": "desktopSdkDoc",
    "title": "Description",
    "pathName": "description",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nText which is used on the UI's information box to be displayed to a user when configuring a **NinjaScript** object.\n\n## Method Return Value\n\nA **string** value representing text used to describe the object.\n\n{% callout type=\"warning\" %}\n\nWarning: This property should ONLY be set from the **OnStateChange()** method during **State.SetDefaults** or **State.Configure**.\n\n{% /callout %}\n\n## Syntax\n\nDescription\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Examples Indicator\";\n     Description = @\"An indicator used to demonstrate various NinjaScript methods and properties\";\n   }\n}\n```"
  },
  {
    "_id": "30b4cec5d9f37e6b1856c0733147c424deb653ec0f235a5d8a4abfa80143e092",
    "_type": "desktopSdkDoc",
    "title": "AllowRemovalOfDrawObjects",
    "pathName": "allowremovalofdrawobjects",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines if programmatically drawn **DrawObjects** are allowed to remove manually from the chart\n\n### Property Value\n\nWhen set to true, the draw objects from the indicator or strategy can be deleted from the chart manually by a user. If false, draw objects from the indicator or strategy can only be removed from the chart if the script removes the drawing object, or the script is terminates. Default set to false.\n\n### Syntax\n\n**AllowRemovalOfDrawObjects**\n\n### Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n     Add(new Plot(Brushes.Orange, \"SMA\"));\n     AllowRemovalOfDrawObjects = true; // Draw objects can be removed separately from the script\n}\n```"
  },
  {
    "_id": "8fd7176acafa8e30e5de2ddba28fd206ac88ab90006516525b31e0bff79a5644",
    "_type": "desktopSdkDoc",
    "title": "AndrewsPitchfork",
    "pathName": "andrewspitchfork",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an object that exposes information regarding an Andrews Pitchfork IDrawingTool.\n\nThe Standard Pitchfork creates a trend channel out of the 3 user defined extreme price anchor points by connecting the first 2 points to form the anchor, and the next 2 points to form the retracement handle. From the first point then a trendline is drawn through the 50% midpoint of the retracement handle, parallel lines originating at the other 2 points forming the channel, while multiple further price levels could be set to allow for finer analysis.\n\nIn contrast the Schiff Pitchfork variant is constructed then by shifting the first anchor of the Standard Pitchfork one-half the vertical distance between the first 2 anchor points.\n\nAs further alternation the Modified Schiff Pitchfork variant is found by moving the first anchor to the midpoint of the original pitchfork's anchor handle, the trend-line connecting our first 2 anchor points.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An IDrawingTool's ChartAnchor representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An IDrawingTool's ChartAnchor representing the end point of the drawing object\n\n---\n\n* ExtensionAnchor\n\n* An IDrawingTool's ChartAnchor representing the extension point of the drawing object\n\n---\n\n* PriceLevels\n\n* A collection of prices calculated by the drawing object\n\n---\n\n* CalculationMethod\n\n* The AndrewsPitchforkCalculationMethod property determining which method is used to calculate the pitchfork. Possible values are: ModifiedSchiff, Schiff, StandardPitchfork\n\n---\n\n* IsTextDisplayed\n\n* A bool value determining if the draw object should display text on the chart.\n\n---\n\n* RetracementLineStroke\n\n* A Stroke object used to draw the center retracement line of the object\n\n---\n\n* AnchorLineStroke\n\n* A Stroke object used to draw the object\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Instantiate an Andrews Pitchfork object\nAndrewsPitchfork myFork = Draw.AndrewsPitchfork(this, \"tag1\", false, 7, Low[7], 5, High[5], 1, Low[1], false, \"ForkTemplate\");\n\n// Print the tag used to draw the object\nPrint(myFork.Tag);\n```"
  },
  {
    "_id": "404fcfb394d23199f6d95f1f36bd2beb6df8564f993f44517f6015fcd16101a9",
    "_type": "desktopSdkDoc",
    "title": "Arc",
    "pathName": "arc",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding an Arc **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An IDrawingTool's ChartAnchor representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An IDrawingTool's ChartAnchor representing the end point of the drawing object\n\n---\n\n* AreaBrush\n\n* A Brush object representing the fill color of the draw object\n\n---\n\n* AreaOpacity\n\n* An int value representing the opacity of the area color\n\n---\n\n* ArcStroke\n\n* The Stroke object used to draw the arc line of the object's outline\n\n---\n\n* Stroke\n\n* The Stroke object used to draw the straight line of the object's outline\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Draw an Arc object\nArc myArc = Draw.Arc(this, \"myArc\", Time[10], Close[10], Time[0], Close[0], Brushes.Blue);\n\n// Set the opacity of the shading between the arc and the chord\nmyArc.AreaOpacity = 100;\n```"
  },
  {
    "_id": "ae282b1004675ade953d2cbcaee82bb70f9c014455ed4cc6b8d96d21370a9a29",
    "_type": "desktopSdkDoc",
    "title": "ArrowDown",
    "pathName": "arrowdown",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding an Arrow Down IDrawingTool.\n\n## Methods and Properties\n\n{% table %}\n\n* Anchor\n* An IDrawingTool's ChartAnchor representing the point of the drawing object\n\n---\n\n* AreaBrush\n* A Brush object representing the fill color of the draw object\n\n---\n\n* OutlineBrush\n* A Brush object representing the color of the draw object's outline\n{% /table %}\n\n## Example\n\n```csharp\n// Instantiate an ArrowDown object\nArrowDown myArrow = Draw.ArrowDown(this, \"tag1\", true, Time[0], High[0] + (2 * TickSize), Brushes.Green);\n\n// Set the outline color of the Arrow\nmyArrow.OutlineBrush = Brushes.Black;\n```"
  },
  {
    "_id": "027ccba0a7d905c4df688cf29640ed8afd28b445081f70eb37927054cf3179cc",
    "_type": "desktopSdkDoc",
    "title": "ArrowLine",
    "pathName": "arrowline",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding an Arrow Line **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* StartAnchor\n* EndAnchor\n* Stroke\n\n---\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n* A **Stroke** object used to draw the object\n{% /table %}\n\n## Example\n\n```csharp\n// Draw an ArrowLine object\nArrowLine myArrow = Draw.ArrowLine(this, \"myArrowLine\", 3, High[3], 1, High[1], Brushes.Blue, DashStyleHelper.DashDot, 3);\n\n// Disable the arrow's visibility\nmyArrow.IsVisible = false;\n```"
  },
  {
    "_id": "6b77912d0ccf29ed91384691271650149a0302cf31c0c84264779404fe47c046",
    "_type": "desktopSdkDoc",
    "title": "ArrowUp",
    "pathName": "arrowup",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding an Arrow Up [IDrawingTool](idrawingtool).\n\n## Methods and Properties\n\n{% table %}\n\n* Anchor\n* An [IDrawingTool's ChartAnchor](idrawingtool.md#chartanchor) representing the point of the drawing object\n\n---\n\n* AreaBrush\n* A **Brush** object representing the fill color of the draw object\n\n---\n\n* OutlineBrush\n* A **Brush** object representing the color of the draw object's outline\n{% /table %}\n\n## Example\n\n```csharp\n// Instantiate an ArrowDown object\nArrowUp myArrow = Draw.ArrowUp(this, \"tag1\", true, Time[0], Low[0] - (2 * TickSize), Brushes.Green);\n\n// Set the outline color of the Arrow\nmyArrow.OutlineBrush = Brushes.Black;\n```"
  },
  {
    "_id": "b0fbaaa3b1a8736069fc177b8bb76f09b8670e72fd6711942bc65743b0075cbf",
    "_type": "desktopSdkDoc",
    "title": "BackBrush",
    "pathName": "backbrush",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nSets the brush used for painting the chart panel's background color for the current bar.\n\n{% callout type=\"note\" %}\n\nThis property will only set the back color for the panel the indicator is running. To set background color for all panels, please see the [BackBrushAll](backbrushall) property.\n\n{% /callout %}\n\n## Property Value\n\nA [Brush](http://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) object that represents the color of the current chart bar.\n\n## Syntax\n\n**BackBrush**\n\n{% callout type=\"warning\" %}\n\nYou may have up to 65,535 unique **BackBrush** instances, therefore, using [static predefined brushes](working_with_brushes) should be favored. Alternatively, in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Sets the chart panel back color to pale green\n     BackBrush = Brushes.PaleGreen;\n\n     // Sets the back color to to null which will use the default color set in the chart properties dialog window\n     BackBrush = null;\n\n     // Sets the back color to maroon when the closing price is less than the 20 period SMA // and to lime green when above (see image below)\n     BackBrush = SMA(20)[0] >= Close[0] ? Brushes.Maroon : Brushes.LimeGreen;\n}\n```\n\n![MAPriceBars](mapricebars.png)"
  },
  {
    "_id": "b0c13e6087d3097f56fd80cc7cde61c7c694937897c37b5e7009f513e93f1e3d",
    "_type": "desktopSdkDoc",
    "title": "BackBrushAll",
    "pathName": "backbrushall",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of prior back brushes used for the background colors for all chart panels.\n\n## Property Value\n\nA Brush object that represents the color of the current chart bar.\n\n{% callout type=\"note\" %}\n\nTo reset the Chart background color to the default background color property, set the BackBrushAll to null for that bar.\n\n{% /callout %}\n\n## Syntax\n\nBackBrushAll\n\n{% callout type=\"warning\" %}\n\nYou may have up to 65,535 unique BackBrushAll instances, therefore, using static predefined brushes should be favored. Alternatively, in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Sets the back color to pale green\n     BackBrushAll = Brushes.PaleGreen;\n\n     // Sets the back color to null to use the default color set in the chart properties dialog window\n     BackBrushAll = null;\n\n     // Sets the back color to pink when the closing price is less than the 20 period SMA\n     // and to lime green when above (see image below)\n     BackBrushAll = SMA(20)[0] >= Close[0] ? Brushes.Pink : Brushes.PaleGreen;\n}\n```\n\n![MAPriceBars2](mapricebars2.png)"
  },
  {
    "_id": "09b962deb6efb5105c4a330552d5e7d54159d47cf8f7fcd68bd9a35f914cd60e",
    "_type": "desktopSdkDoc",
    "title": "BackBrushes",
    "pathName": "backbrushes",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of prior back brushes used for the background colors of the chart panel.\n\n## Property Value\n\nA brush series type object. Accessing this property via an index value **int barsAgo** returns a **Brush** object representing the color of the background color on the referenced bar.\n\n## Syntax\n\n**BackBrushes**\n\n**BackBrushes[int barsAgo]**\n\n{% callout type=\"warning\" %}\n\nYou may have up to 65,535 unique BackBrushes instances, therefore, using [static predefined brushes](working_with_brushes) should be favored. Alternatively, in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 1)\n        return;\n\n    // Sets the color of the background on the current bar as blue\n    BackBrushes[0] = Brushes.Blue;\n\n    // Sets the color of the background on the previous bar as orange\n    BackBrushes[1] = Brushes.Orange;\n}\n```"
  },
  {
    "_id": "17ae8f2ac2450a8338eb5928e65b64302d12a51452ecdb949b31136f9e8a559d",
    "_type": "desktopSdkDoc",
    "title": "BackBrushesAll",
    "pathName": "backbrushesall",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical brushes used for the background colors for all chart panels.\n\n## Property Value\n\nA brush series type object. Accessing this property via an index value [int barsAgo] returns a **Brush** object representing the color of the background color on the referenced bar for all chart panels.\n\n## Syntax\n\n**BackBrushesAll**  \n\n**BackBrushesAll[int barsAgo]**\n\n{% callout type=\"warning\" %}\n\nYou may have up to 65,535 unique BackBrushAll instances, therefore, using **static predefined brushes** should be favored. Alternatively, in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 1)\n        return;\n\n    // Sets the color of the background on the current bar as blue on all chart panels.\n    BackBrushesAll[0] = Brushes.Blue;\n\n    // Sets the color of the background on the previous bar as orange on all chart panels.\n    BackBrushesAll[1] = Brushes.Orange;\n}\n```"
  },
  {
    "_id": "727162fa522c296186fb06d1ab16bd555a702b4ad89251e093963e980f9f49f7",
    "_type": "desktopSdkDoc",
    "title": "BarBrush",
    "pathName": "barbrush",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nSets the brush used for painting the color of a price bar's body.\n\n## Property Value\n\nA Brush object that represents the color of this price bar.\n\n{% callout type=\"note\" %}\n\nTo set the price bar color to an empty color which uses the default bar color property, set the BarBrush to null for that bar.\n\n{% /callout %}\n\n## Syntax\n\nBarBrush\n\n{% callout type=\"warning\" %}\n\nYou may have up to 65,535 unique BarBrush instances, therefore, using static predefined brushes should be favored. Alternatively, in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Sets the bar color to yellow\n     BarBrush = Brushes.Yellow;\n\n     // Sets the brush used for the bar color to its default color as defined in the chart properties dialog\n     BarBrush = null;\n\n     // Sets the bar color to yellow if the 20 SMA is above the 50 SMA and the closing\n     // price is above the 20 SMA (see image below)\n     if (SMA(20)[0] > SMA(50)[0] && Close[0] > SMA(20)[0])\n         BarBrush = Brushes.Yellow;\n}\n```"
  },
  {
    "_id": "10426dfdc92fa159438601325e9bc6c16329c9f5004776fab02a0fc37d82e2ec",
    "_type": "desktopSdkDoc",
    "title": "BarBrushes",
    "pathName": "barbrushes",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical brushes used for painting the color of a price bar's body.\n\n## Property Value\n\nA brush series type object. Accessing this property via an index value **int barsAgo** returns a **Brush** object representing the referenced bar's color.\n\n{% callout type=\"note\" %}\n\nThis will only return the color of a bar in which an explicit color overwrite was used. Otherwise it will return null.\n\n{% /callout %}\n\n## Syntax\n\n**BarBrushes**\n\n**BarBrushes[int barsAgo]**\n\n{% callout type=\"warning\" %}\n\nYou may have up to 65,535 unique BarBrushes instances, therefore, using **static predefined brushes** should be favored. Alternatively, in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 1)\n        return;\n\n    // Sets the color of the current bar to blue.\n    BarBrushes[0] = Brushes.Blue;\n\n    // Sets the color of the previous bar to orange.\n    BarBrushes[1] = Brushes.Orange;\n}\n```"
  },
  {
    "_id": "b4d2062daaed8dcfe507ec4e3f68d6817b1f2a4554bf709d6be7a03eaa515c15",
    "_type": "desktopSdkDoc",
    "title": "Brushes",
    "pathName": "brushes",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Brushes\n\nFor detailed information on using **Brushes** for **Drawing** please see the [Working with Brushes](working_with_brushes)."
  },
  {
    "_id": "c4aa637da1812fbb153af3438b474664a4ad66d3175ee79ec202e7dd32a4cb7c",
    "_type": "desktopSdkDoc",
    "title": "CandleOutlineBrush",
    "pathName": "candleoutlinebrush",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nSets the outline Brush of a candlestick.\n\n## Property Value\n\nA **brush** object that represents the color of this price bar.\n\n## Syntax\n\n**CandleOutlineBrush**\n\n{% callout type=\"warning\" %}\n\nYou may have up to 65,535 unique **CandleOutlineBrushes** instances, therefore, using [static predefined brushes](working_with_brushes) should be favored. Alternatively, in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Sets the candle outline color to black\nCandleOutlineBrush = Brushes.Black;\n```\n\n{% callout type=\"warning\" %}\n\n* Warning:  You may have up to 65,535 unique CandleOutlineBrushes instances, therefore, using [static predefined brushes](working_with_brushes) should be favored.  Alternatively,  in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n{% /callout %}"
  },
  {
    "_id": "da6bbb3e9dd4b73d867f7f624eafbd4a8ab7a25f8a62ba0d35ac26dce903568d",
    "_type": "desktopSdkDoc",
    "title": "CandleOutlineBrushes",
    "pathName": "candleoutlinebrushes",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical outline brushes for candlesticks.\n\n## Property Value\n\nA brush series type object. Accessing this property via an index value **int barsAgo** returns a [brush](http://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) structure representing the referenced bar's outline color.\n\n{% callout type=\"note\" %}\n\nThis will only return the color of a candlestick outline in which an explicit color overwrite was used. Otherwise it will return null.\n\n{% /callout %}\n\n## Syntax\n\n**CandleOutlineBrushes**  \n**CandleOutlineBrushes[int barsAgo]**\n\n{% callout type=\"warning\" %}\n\nWarning: You may have up to 65,535 unique CandleOutlineBrushes instances, therefore, using [static predefined brushes](working_with_brushes) should be favored. Alternatively, in order to use fewer brushes, please try to cache your custom brushes until a new brush would actually need to be created.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Sets the outline color of the current bar to black.\nCandleOutlineBrushes[0] = Brushes.Black;\n\n// Sets the outline color of the previous bar to blue.\nCandleOutlineBrushes[1] = Brushes.Blue;\n```"
  },
  {
    "_id": "81c9d6128b5fcd7bbe4ba65c177388ff767a2017f971c053dcaa6f32b4d6a758",
    "_type": "desktopSdkDoc",
    "title": "Diamond",
    "pathName": "diamond",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Diamond **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* Anchor\n\n* An **IDrawingTool's ChartAnchor** representing the point of the drawing object\n\n---\n\n* AreaBrush\n\n* A **Brush** object representing the fill color of the draw object\n\n---\n\n* OutlineBrush\n\n* A **Brush** object representing the color of the draw object's outline\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiates a red diamond on the current bar 1 tick below the low\nDiamond myDiamond = Draw.Diamond(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n\n// Set the area fill color to Red\nmyDiamond.AreaBrush = Brushes.Red;\n```"
  },
  {
    "_id": "e392dad8b08599f74d4819cd291feef81ab4389e0a6fae2b1286f99411b0c7ca",
    "_type": "desktopSdkDoc",
    "title": "Dot",
    "pathName": "dot",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Dot **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* Anchor\n\n* An **IDrawingTool's ChartAnchor** representing the point of the drawing object\n\n---\n\n* AreaBrush\n\n* A **Brush** object representing the fill color of the draw object\n\n---\n\n* OutlineBrush\n\n* A **Brush** object representing the color of the draw object's outline\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiates a red dot on the current bar 1 tick below the low\nDot myDot = Draw.Dot(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n\n// Disable the dot's Auto Scale property\nmyDot.IsAutoScale = false;\n```"
  },
  {
    "_id": "1f38b349f16df481392a92b4b31d4539f5354cee921b60b357c4070d213f1610",
    "_type": "desktopSdkDoc",
    "title": "DrawObjects",
    "pathName": "drawobjects",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection holding all of the drawn chart objects on the chart, for all series. The draw objects can be manually drawn or script generated objects.\n\n{% table %}\n\n* Notes\n\n---\n\n* When reloading **NinjaScript**, all objects (including manual drawing tools) are reloaded at the same time. There is no guarantee a manually drawn object will be added to the **DrawObjects** collection before an indicator starts processing data.\n* **DrawObjects.ToList()** is thread safe. **DrawObjects** collection itself is still dynamic (meaning it updates live) and as a result you can still run the risk of the collection being modified while you try to read it (and thus would see the related **C#** log entry). However, **DrawObjects.ToList()** is a snapshot of **DrawObjects** collection at the time the call is made.\n* Also please keep in mind that iterating over a large **DrawObjects** collection could have an impact on performance.\n* Draw objects are disposed (for example on chart closing) after **State.Terminated** is seen for your custom **NinjaScript** studies potentially working with those.\n{% /table %}\n\n## Property Value\n\nA collection of [**IDrawingTool**](idrawingtool) objects.\n\n## Syntax\n\n**DrawObjects**  \n\n**DrawObjects[string tag]**  \n\n**DrawObjects.Count**\n\n## Examples\n\n### Finding the draw object of a specific tag\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   if (DrawObjects[\"someTag\"] != null && DrawObjects[\"someTag\"] is DrawingTools.Line)\n   {\n     // Do something with the drawing tool line\n   }\n  \n   // An alternative approach to find the draw object by a tag\n   if (DrawObjects[\"someTag\"] as DrawingTools.Line != null)\n   {\n     // Do something drawing tool line\n   }\n  \n   // Yet another way to find a drawing tool by a tag\n   if (DrawObjects[\"someTag\"].GetType().Name == \"Line\")\n   {\n     // Do something drawing tool line\n   }\n}\n\n```\n\n### Get the number of draw objects on a chart\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   if (DrawObjects.Count == 3)\n   {\n         // Do something\n   }\n}\n```\n\n## Looping through the collection to find specific draw objects\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Loops through the DrawObjects collection via a threadsafe list copy\n   foreach (DrawingTool draw in DrawObjects.ToList())\n   {\n     // Finds line objects that are attached globally to all charts of the same instrument\n     if (draw.IsGlobalDrawingTool && draw is DrawingTools.Line)\n     {\n         DrawingTools.Line globalLine = draw as DrawingTools.Line;\n\n         // Changes the line color and prints its starting and end points\n         globalLine.Stroke.Brush = Brushes.Black;\n\n         Print(\"Start: \" + globalLine.StartAnchor.SlotIndex + \" End: \" + globalLine.EndAnchor.SlotIndex);\n     }\n\n     // Finds non-global line objects\n     else if (draw is DrawingTools.Line)\n     {\n         // Indicates if this is a manually drawn or script generated line\n         Print(\"Line Object: \" + draw.Tag + \" Manually Drawn: \" + draw.IsUserDrawn);\n     }\n   }\n}\n```\n\n{% callout type=\"note\" %}\n\nTypecasting as in the example above will not function the same way in a compiled assembly (DLL). For an alternative approach, see the [Considerations For Compiled Assemblies](considerations_for_compiled_assemblies) page.\n\n{% /callout %}"
  },
  {
    "_id": "3f8275c11955df2dd623dead8a594418a1952589ae27e9dd1cc28de45ad97b5e",
    "_type": "desktopSdkDoc",
    "title": "Draw.AndrewsPitchfork()",
    "pathName": "draw_andrewspitchfork",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws an Andrew's Pitchfork.\n\n## Method Return Value\n\nAn **AndrewsPitchfork** object that represents the draw object.\n\n## Syntax\n\n**Draw.AndrewsPitchfork(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.AndrewsPitchfork(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime anchor1Time, double anchor1Y, DateTime anchor2Time, double anchor2Y, DateTime anchor3Time, double anchor3Y, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.AndrewsPitchfork(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, bool isGlobal, string templateName)**  \n\n**Draw.AndrewsPitchfork(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime anchor1Time, double anchor1Y, DateTime anchor2Time, double anchor2Y, DateTime anchor3Time, double anchor3Y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* anchor1BarsAgo\n* The number of bars ago (x value) of the 1st anchor point.\n\n---\n\n* anchor1Time\n* The time of the 1st anchor point.\n\n---\n\n* anchor1Y\n* The y value of the 1st anchor point.\n\n---\n\n* anchor2BarsAgo\n* The number of bars ago (x value) of the 2nd anchor point.\n\n---\n\n* anchor2Time\n* The time of the 2nd anchor point.\n\n---\n\n* anchor2Y\n* The y value of the 2nd anchor point.\n\n---\n\n* anchor3BarsAgo\n* The number of bars ago (x value) of the 3rd anchor point.\n\n---\n\n* anchor3Time\n* The time of the 3rd anchor point.\n\n---\n\n* anchor3Y\n* The y value of the 3rd anchor point.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n \t* **DashStyleHelper.Dash**,\n \t* **DashStyleHelper.DashDot**,\n \t* **DashStyleHelper.DashDotDot**,\n \t* **DashStyleHelper.Dot**,\n \t* **DashStyleHelper.Solid**.\n  Note: Drawing objects with y values very far off the visible canvas can lead to performance hits. Fancier DashStyles like **DashDotDot** will also require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws an Andrew's Pitchfork\nDraw.AndrewsPitchfork(this, \"tag1\", true, 4, Low[4], 3, High[3], 1, Low[1], Brushes.Blue, DashStyleHelper.Solid, 3);\n```"
  },
  {
    "_id": "bd4303c338fcb8c8f357dab11bcb57fb99206e5e52e639801703ff66de9ee2c9",
    "_type": "desktopSdkDoc",
    "title": "Draw.Arc()",
    "pathName": "draw_arc",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws an arc.\n\n## Method Return Value\n\nAn **Arc** object that represents the draw object.\n\n## Syntax\n\n**Draw.Arc(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.Arc(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.Arc(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.Arc(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.Arc(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.Arc(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.Arc(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.Arc(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n \t* **DashStyleHelper.Dash**\n \t* **DashStyleHelper.DashDot**\n \t* **DashStyleHelper.DashDotDot**\n \t* **DashStyleHelper.Dot**\n \t* **DashStyleHelper.Solid**  \n  Note: Drawing objects with y values very far off the visible canvas can lead to performance hits. Fancier DashStyles like **DashDotDot** will also require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a dotted lime green arc  \nDraw.Arc(this, \"tag1\", false, 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);\n```"
  },
  {
    "_id": "9bf149afe7df61efeea994add7ce2e287dd637f1d334ecbf7d7bd8983e3938d4",
    "_type": "desktopSdkDoc",
    "title": "Draw.ArrowDown()",
    "pathName": "draw_arrowdown",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws an arrow pointing down.\n\n## Method Return Value\n\nAn **ArrowDown** object that represents the draw object.\n\n## Syntax\n\n**Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)**  \n\n**Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)**  \n\n**Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)**  \n\n**Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* y\n* The y value.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: The size of the arrow is tied to the chart's BarWidth and thus will scale automatically as the chart is resized.\n{% /callout %}\n\n## Examples\n\n```csharp\n// Paints a red down arrow on the current bar 1 tick above the high\nDraw.ArrowDown(this, \"tag1\", true, 0, High[0] + TickSize, Brushes.Red);\n\n// Paints a blue down arrow on a three bar reversal pattern\nif (High[2] > High[3] && High[1] > High[2] && Close[0] < Open[0])\nDraw.ArrowDown(this, CurrentBar.ToString(), true, 0, High[0] + TickSize, Brushes.Blue);\n```"
  },
  {
    "_id": "638ff34ed784588796f0e7a2ca4d3f6d2e19eef0b2fd57e4ca7a0afcbf98a501",
    "_type": "desktopSdkDoc",
    "title": "Draw.ArrowLine()",
    "pathName": "draw_arrowline",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws an arrow line.\n\n## Method Return Value\n\nAn **ArrowLine** object that represents the draw object.\n\n## Syntax\n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.ArrowLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n  * **DashStyleHelper.Dash**  \n  * **DashStyleHelper.DashDot**  \n  * **DashStyleHelper.DashDotDot**  \n  * **DashStyleHelper.Dot**  \n  * **DashStyleHelper.Solid**  \n  Note: Drawing objects with y values very far off the visible canvas can lead to performance hits. Fancier DashStyles like **DashDotDot** will also require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a dotted lime green arrow line\nDraw.ArrowLine(this, \"tag1\", 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);\n```"
  },
  {
    "_id": "fb1c26825e12a20c16ccce115cfdd9f8583ca86a500af49c5a88c7ddf606dc11",
    "_type": "desktopSdkDoc",
    "title": "Draw.ArrowUp()",
    "pathName": "draw_arrowup",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws an arrow pointing up.\n\n## Method Return Value\n\nAn **ArrowUp** object that represents the draw object.\n\n## Syntax\n\n**Draw.ArrowUp(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)**  \n\n**Draw.ArrowUp(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)**  \n\n**Draw.ArrowUp(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.ArrowUp(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.ArrowUp(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)**  \n\n**Draw.ArrowUp(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* y\n* The y value.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: The size of the arrow is tied to the chart's BarWidth and thus will scale automatically as the chart is resized.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Paints a red up arrow on the current bar 1 tick below the low\nDraw.ArrowUp(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n```"
  },
  {
    "_id": "19f0e205c9734a2b9b129c13cf897ad2057f8797f9983917b13a1e5a07e5ff15",
    "_type": "desktopSdkDoc",
    "title": "Draw.Diamond()",
    "pathName": "draw_diamond",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a diamond.\n\n## Method Return Value\n\nA **Diamond** object that represents the draw object.\n\n## Syntax\n\n**Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)**  \n\n**Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)**  \n\n**Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)**  \n\n**Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* y\n* The y value.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: The size of the diamond is tied to the chart's BarWidth and thus will scale automatically as the chart is resized.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Paints a red diamond on the current bar 1 tick below the low\nDraw.Diamond(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n```"
  },
  {
    "_id": "aae93b0fa3e0393a8553a71bf77352f03869569a37d5936f47d10e7a705c5f6d",
    "_type": "desktopSdkDoc",
    "title": "Draw.Dot()",
    "pathName": "draw_dot",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a dot.\n\n## Method Return Value\n\nA **Dot** object that represents the draw object.\n\n## Syntax\n\n**Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)**  \n\n**Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)**  \n\n**Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)**  \n\n**Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* y\n* The y value.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: The size of the dot is tied to the chart's BarWidth and thus will scale automatically as the chart is resized.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Paints a red dot on the current bar 1 tick below the low\nDraw.Dot(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n```"
  },
  {
    "_id": "5c7d15deadf3cbea6dc85c82f569873354cedde5f3510854f732eaf2340a631e",
    "_type": "desktopSdkDoc",
    "title": "Draw.Ellipse()",
    "pathName": "draw_ellipse",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws an ellipse.\n\n## Method Return Value\n\nAn **Ellipse** object that represents the draw object.\n\n## Syntax\n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.Ellipse(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](brushes)).\n\n---\n\n* areaBrush\n* The brush used to color the fill area of the draw object ([reference](brushes)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobalDrawingTool\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Paints a red ellipse on the current bar\nDraw.Ellipse(this, \"tag1\", true, 5, Close[5], 0, Close[0], Brushes.Red, Brushes.Red, 5);\n\n```"
  },
  {
    "_id": "e04bdc90272e18954652cf4fa55899bd303c7e8175cb36b8d83cd9f4e40bc735",
    "_type": "desktopSdkDoc",
    "title": "Draw.ExtendedLine()",
    "pathName": "draw_extendedline",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a line with infinite end points.\n\n## Method Return Value\n\nAn **ExtendedLine** object that represents the draw object.\n\n## Syntax  \n\n**Draw.ExtendedLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.ExtendedLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.ExtendedLine(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.ExtendedLine(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.ExtendedLine(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.ExtendedLine(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.ExtendedLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.ExtendedLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n* **DashStyleHelper.Dash**, **DashStyleHelper.DashDot**, **DashStyleHelper.DashDotDot**, **DashStyleHelper.Dot**, **DashStyleHelper.Solid**. Note: Drawing objects with y values very far off the visible canvas can lead to performance hits. Fancier DashStyles like **DashDotDot** will also require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a dotted lime green\nDraw.ExtendedLine(this, \"tag1\", 10, Close[10], 0, Close[0], Brushes.LimeGreen, DashStyleHelper.Dot, 2);\n```"
  },
  {
    "_id": "6591d082173326c34b1c714d1fa62ca9f5cf7d6a5f57cbd12570650ae43960ca",
    "_type": "desktopSdkDoc",
    "title": "Draw.FibonacciCircle()",
    "pathName": "draw_fibonaccicircle",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a fibonacci circle.\n\n## Method Return Value\n\nA **FibonacciCircle** object that represents the draw object.\n\n## Syntax  \n\n**Draw.FibonacciCircle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY)**  \n\n**Draw.FibonacciCircle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY)**  \n\n**Draw.FibonacciCircle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**  \n\n**Draw.FibonacciCircle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a Fibonacci circle\nDraw.FibonacciCircle(this, \"tag1\", true, 10, Low[10], 0, High[0]);\n```"
  },
  {
    "_id": "8a96a580d5c50f8eb7ab5008f30f16335d0da49da3c9d8da3a19647f1962354b",
    "_type": "desktopSdkDoc",
    "title": "Draw.FibonacciExtensions()",
    "pathName": "draw_fibonacciextensions",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a fibonacci extension.\n\n## Method Return Value\n\nA **FibonacciExtensions** object that represents the draw object.\n\n## Syntax\n\n**Draw.FibonacciExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, int extensionBarsAgo, double extensionY)**  \n\n**Draw.FibonacciExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, DateTime extensionTime, double extensionY)**  \n\n**Draw.FibonacciExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, DateTime extensionTime, double extensionY, bool isGlobal, string templateName)**  \n\n**Draw.FibonacciExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, int extensionBarsAgo, double extensionY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* startBarsAgo\n* The number of bars ago (x value) of the 1st anchor point.\n\n---\n\n* startTime\n* The time of the 1st anchor point.\n\n---\n\n* startY\n* The y value of the 1st anchor point.\n\n---\n\n* endBarsAgo\n* The number of bars ago (x value) of the 2nd anchor point.\n\n---\n\n* endTime\n* The time of the 2nd anchor point.\n\n---\n\n* endY\n* The y value of the 2nd anchor point.\n\n---\n\n* extensionBarsAgo\n* The number of bars ago (x value) of the 3rd anchor point.\n\n---\n\n* extensionTime\n* The time of the 3rd anchor point.\n\n---\n\n* extensionY\n* The y value of the 3rd anchor point.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a fibonnaci extension\nDraw.FibonacciExtensions(this, \"tag1\", true, 4, Low[4], 3, High[3], 1, Low[1]);\n```"
  },
  {
    "_id": "b2000cdb39c64cb8a2a91bb17c4f915e18817733765ec9acbb0b897d518fcb50",
    "_type": "desktopSdkDoc",
    "title": "Draw.FibonacciRetracements()",
    "pathName": "draw_fibonacciretracements",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a fibonacci retracement.\n\n## Method Return Value\n\nA **FibonacciRetracements** object that represents the draw object.\n\n## Syntax\n\n**Draw.FibonacciRetracements(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY)**\n\n**Draw.FibonacciRetracements(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY)**\n\n**Draw.FibonacciRetracements(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n**Draw.FibonacciRetracements(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting NinjaScript object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a fibonnaci retracement\nDraw.FibonacciRetracements(this, \"tag1\", true, 10, Low[10], 0, High[0]);\n```"
  },
  {
    "_id": "897f43d46fe5a351bfd06c891d6d365f562746646aa7b44c6f7a72c70fb6952c",
    "_type": "desktopSdkDoc",
    "title": "Draw.FibonacciTimeExtensions()",
    "pathName": "draw_fibonaccitimeextensions",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a fibonacci time extension.\n\n## Method Return Value\n\nA **FibonacciTimeExtensions** object that represents the draw object.\n\n## Syntax  \n\n**Draw.FibonacciTimeExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY)**  \n\n**Draw.FibonacciTimeExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY)**  \n\n**Draw.FibonacciTimeExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**  \n\n**Draw.FibonacciTimeExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a fibonacci time extension object\nDraw.FibonacciTimeExtensions(this, \"tag1\", false, 10, Low[10], 0, High[0]);\n\n```"
  },
  {
    "_id": "6fe87725a4852c68956f730a05cf63faa6e0beab6c87e754fdffc154e39118fe",
    "_type": "desktopSdkDoc",
    "title": "Draw.GannFan()",
    "pathName": "draw_gannfan",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a Gann Fan.\n\n## Method Return Value\n\nA **GannFan** object that represents the draw object.\n\n## Syntax\n\n**Draw.GannFan(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y)**  \n\n**Draw.GannFan(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y)**  \n\n**Draw.GannFan(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)**  \n\n**Draw.GannFan(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* y\n* The y value.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a Gann Fan at the current bar low  \nDraw.GannFan(this, \"tag1\", true, 0, Low[0]);\n\n```"
  },
  {
    "_id": "a7d7391b87cfeeb81a81c08e571df47c0e43acc81d59b0fe7555694052c9a67e",
    "_type": "desktopSdkDoc",
    "title": "Draw.HorizontalLine()",
    "pathName": "draw_horizontal_line",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a horizontal line.\n\n## Method Return Value\n\nA **HorizontalLine** object that represents the draw object.\n\n## Syntax\n\n**Draw.HorizontalLine(NinjaScriptBase owner, string tag, double y, Brush brush)**  \n\n**Draw.HorizontalLine(NinjaScriptBase owner, string tag, bool isAutoScale, double y, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.HorizontalLine(NinjaScriptBase owner, string tag, bool isAutoscale, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.HorizontalLine(NinjaScriptBase owner, string tag, double y, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.HorizontalLine(NinjaScriptBase owner, string tag, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* y\n* The y value.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n \t* **DashStyleHelper.Dash**,\n \t* **DashStyleHelper.DashDot**,\n \t* **DashStyleHelper.DashDotDot**,\n \t* **DashStyleHelper.Dot**,\n \t* **DashStyleHelper.Solid**.\n  Note: Fancier DashStyles like **DashDotDot** will require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* isDrawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a horizontal line\nDraw.HorizontalLine(this, \"tag1\", 1000, Brushes.Black);\n```"
  },
  {
    "_id": "91109cb3e58eefee70119f2b6dbcc5f49f14deaabf8216a0f064408033ca6706",
    "_type": "desktopSdkDoc",
    "title": "Draw.Line()",
    "pathName": "draw_line",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a line between two points.\n\n## Method Return Value\n\nA **Line** object that represents the draw object.\n\n## Syntax\n\n**Draw.Line(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.Line(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.Line(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.Line(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.Line(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.Line(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, string templateName)**  \n\n**Draw.Line(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, string templateName)**  \n\n**Draw.Line(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.Line(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**  \n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n \t* **DashStyleHelper.Dash**  \n \t* **DashStyleHelper.DashDot**  \n \t* **DashStyleHelper.DashDotDot**  \n \t* **DashStyleHelper.Dot**  \n \t* **DashStyleHelper.Solid**  \n  Note: Drawing objects with y values very far off the visible canvas can lead to performance hits. Fancier DashStyles like **DashDotDot** will also require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a dotted lime green line from 10 bars back to the current bar\n// with a width of 2 pixels\nDraw.Line(this, \"tag1\", false, 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);\n```"
  },
  {
    "_id": "e79cde657a92203eb9134a050f6c9759b0c4a552b1364e08a7b2cfdb474bf26f",
    "_type": "desktopSdkDoc",
    "title": "Draw.PathTool()",
    "pathName": "draw_pathtool",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a path which can have a user defined set of anchors.\n\n## Method Return Value\n\nA **PathTool** object that represents the draw object.\n\n## Syntax\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y, int anchor5BarsAgo, double anchor5Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y, DateTime Anchor5Time, double anchor5Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, Brush brush, DashStyleHelper dashStyle)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* chartAnchors\n* A list of the chart anchors.\n\n---\n\n* anchor1BarsAgo\n* The bar the first anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor2BarsAgo\n* The bar the second anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor3BarsAgo\n* The bar the third anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor4BarsAgo\n* The bar the forth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor5BarsAgo\n* The bar the fifth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor1Y\n* The first anchor y value.\n\n---\n\n* anchor2Y\n* The second anchor y value.\n\n---\n\n* anchor3Y\n* The third anchor y value.\n\n---\n\n* anchor4Y\n* The forth anchor y value.\n\n---\n\n* anchor5Y\n* The fifth anchor y value.\n\n---\n\n* Anchor1Time\n* The time the first anchor of the object will be drawn at.\n\n---\n\n* Anchor2Time\n* The time the second anchor of the object will be drawn at.\n\n---\n\n* Anchor3Time\n* The time the third anchor of the object will be drawn at.\n\n---\n\n* Anchor4Time\n* The time the forth anchor of the object will be drawn at.\n\n---\n\n* Anchor5Time\n* The time the fifth anchor of the object will be drawn at.\n\n---\n\n* Brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Draws a PathTool object based on bars ago and y anchors\nDraw.PathTool**(this, \"tag1\", false, 20, 194, 10, 184, 13, 176, 25, 182);\n\n// Draws a PathTool object based on a list of anchors with specified times**\nList<chartanchor> anchors = new List<chartanchor>();\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 25), 194, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 12), 184, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 7), 176, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 21), 182, ChartControl));\n\nDraw.PathTool(this, \"tag1\", false, anchors, Brushes.CornflowerBlue, DashStyleHelper.Solid);\n\n```"
  },
  {
    "_id": "e79cde657a92203eb9134a050f6c9759b0c4a552b1364e08a7b2cfdb474bf26f",
    "_type": "desktopSdkDoc",
    "title": "Draw.PathTool()",
    "pathName": "draw_pathtool",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a path which can have a user defined set of anchors.\n\n## Method Return Value\n\nA **PathTool** object that represents the draw object.\n\n## Syntax\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, bool isGlobal, string templateName)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, Brush brush, DashStyleHelper dashStyle)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y, int anchor5BarsAgo, double anchor5Y)**\n\n**Draw.PathTool(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y, DateTime Anchor5Time, double anchor5Y)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* chartAnchors\n* A list of the chart anchors.\n\n---\n\n* anchor1BarsAgo\n* The bar the first anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor2BarsAgo\n* The bar the second anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor3BarsAgo\n* The bar the third anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor4BarsAgo\n* The bar the forth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor5BarsAgo\n* The bar the fifth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor1Y\n* The first anchor y value.\n\n---\n\n* anchor2Y\n* The second anchor y value.\n\n---\n\n* anchor3Y\n* The third anchor y value.\n\n---\n\n* anchor4Y\n* The forth anchor y value.\n\n---\n\n* anchor5Y\n* The fifth anchor y value.\n\n---\n\n* Anchor1Time\n* The time the first anchor of the object will be drawn at.\n\n---\n\n* Anchor2Time\n* The time the second anchor of the object will be drawn at.\n\n---\n\n* Anchor3Time\n* The time the third anchor of the object will be drawn at.\n\n---\n\n* Anchor4Time\n* The time the forth anchor of the object will be drawn at.\n\n---\n\n* Anchor5Time\n* The time the fifth anchor of the object will be drawn at.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a PathTool object based on bars ago and y anchors\nDraw.PathTool(this, \"tag1\", false, 20, 194, 10, 184, 13, 176, 25, 182);\n\n// Draws a PathTool object based on a list of anchors with specified times\nList<chartanchor> anchors = new List<chartanchor>();\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 25), 194, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 12), 184, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 7), 176, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 21), 182, ChartControl));\nDraw.PathTool(this, \"tag1\", false, anchors, Brushes.CornflowerBlue, DashStyleHelper.Solid, Brushes.CornflowerBlue, 40);\n```"
  },
  {
    "_id": "8bba89fef0945fef581be912547cbc265cbd47ca853e5a71d7dd986170f99e04",
    "_type": "desktopSdkDoc",
    "title": "Draw.Polygon()",
    "pathName": "draw_polygon",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a polygon which can have a user defined set of anchors.\n\n## Method Return Value\n\nA **Polygon** object that represents the draw object.\n\n## Syntax\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, bool isGlobal, string templateName)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, List<`chartanchor`> chartAnchors, Brush brush, DashStyleHelper dashStyle, Brush areaBrush, int areaOpacity)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y, int anchor5BarsAgo, double anchor5Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y, DateTime Anchor5Time, double anchor5Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, int anchor4BarsAgo, double anchor4Y, int anchor5BarsAgo, double anchor5Y, int anchor6BarsAgo, double anchor6Y)**\n\n**Draw.Polygon(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime Anchor1Time, double anchor1Y, DateTime Anchor2Time, double anchor2Y, DateTime Anchor3Time, double anchor3Y, DateTime Anchor4Time, double anchor4Y, DateTime Anchor5Time, double anchor5Y, DateTime Anchor6Time, double anchor6Y)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* chartAnchors\n* A list of the chart anchors.\n\n---\n\n* anchor1BarsAgo\n* The bar the first anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor2BarsAgo\n* The bar the second anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor3BarsAgo\n* The bar the third anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor4BarsAgo\n* The bar the forth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor5BarsAgo\n* The bar the fifth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor6BarsAgo\n* The bar the sixth anchor of the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* anchor1Y\n* The first anchor y value.\n\n---\n\n* anchor2Y\n* The second anchor y value.\n\n---\n\n* anchor3Y\n* The third anchor y value.\n\n---\n\n* anchor4Y\n* The forth anchor y value.\n\n---\n\n* anchor5Y\n* The fifth anchor y value.\n\n---\n\n* anchor6Y\n* The sixth anchor y value.\n\n---\n\n* Anchor1Time\n* The time the first anchor of the object will be drawn at.\n\n---\n\n* Anchor2Time\n* The time the second anchor of the object will be drawn at.\n\n---\n\n* Anchor3Time\n* The time the third anchor of the object will be drawn at.\n\n---\n\n* Anchor4Time\n* The time the forth anchor of the object will be drawn at.\n\n---\n\n* Anchor5Time\n* The time the fifth anchor of the object will be drawn at.\n\n---\n\n* Anchor6Time\n* The time the sixth anchor of the object will be drawn at.\n\n---\n\n* areaBrush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Draws a Polygon object based on bars ago and y anchors\nDraw.Polygon(this, \"tag1\", false, 20, 194, 10, 184, 13, 176, 25, 182);\n\n// Draws a Polygon object based on a list of anchors with specified times\nList<chartanchor> anchors = new List<chartanchor>();\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 25), 194, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 12), 184, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 6, 7), 176, ChartControl));\nanchors.Add(new ChartAnchor(new DateTime(2018, 5, 21), 182, ChartControl));\nDraw.Polygon(this, \"tag1\", false, anchors, Brushes.CornflowerBlue, DashStyleHelper.Solid, Brushes.CornflowerBlue, 40);\n\n```"
  },
  {
    "_id": "5608879e202e12ca4e6ccfa5b8d38715b2d503bb43d1ca63fbe069611029009b",
    "_type": "desktopSdkDoc",
    "title": "Draw.Ray()",
    "pathName": "draw_ray",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a line which has an infinite end point in one direction.\n\n## Method Return Value\n\nA **Ray** object that represents the draw object.\n\n## Syntax\n\n**Draw.Ray(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.Ray(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.Ray(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.Ray(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width)**  \n\n**Draw.Ray(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.Ray(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.Ray(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.Ray(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The number of bars ago (x value) of the 1st anchor point.\n\n---\n\n* startTime\n* The time of the 1st anchor point.\n\n---\n\n* startY\n* The y value of the 1st anchor point.\n\n---\n\n* endBarsAgo\n* The number of bars ago (x value) of the 2nd anchor point.\n\n---\n\n* endTime\n* The time of the 2nd anchor point.\n\n---\n\n* endY\n* The y value of the 2nd anchor point.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* dashStyle\n \t* **DashStyleHelper.Dash**  \n \t* **DashStyleHelper.DashDot**  \n \t* **DashStyleHelper.DashDotDot**  \n \t* **DashStyleHelper.Dot**  \n \t* **DashStyleHelper.Solid**  \n  Note: Drawing objects with y values very far off the visible canvas can lead to performance hits. Fancier DashStyles like **DashDotDot** will also require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a lime green ray from 10 bars back through the current bar  \nDraw.Ray(this, \"tag1\", 10, 1000, 0, 1001, **Brushes.LimeGreen**);\n```"
  },
  {
    "_id": "093deb93fa32838dc12316097db78596c505c04bc55504564df7be7769815aa2",
    "_type": "desktopSdkDoc",
    "title": "Draw.Rectangle()",
    "pathName": "draw_rectangle",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a rectangle.\n\n## Method Return Value\n\nA **Rectangle** object that represents the draw object.\n\n## Syntax\n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.Rectangle(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* startY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The end y value co-ordinate where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* areaBrush\n* The brush used to color the fill area of the draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n\n// Draws a blue rectangle from the low 10 bars back to the high of 5 bars back\nDraw.Rectangle(this, \"tag1\", 10, Low[10] - TickSize, 5, High[5] + TickSize, Brushes.Blue);\n\n// Draws a blue rectangle from the low 10 bars back to the high of 5 bars back with a fill color or pale green with a transparency level of 2\nDraw.Rectangle(this, \"tag1\", false, 10, Low[10] - TickSize, 5, High[5] + TickSize, Brushes.PaleGreen, Brushes.PaleGreen, 2);\n\n```"
  },
  {
    "_id": "6741501a70bc4789cec872ca1eace9f7cbabfa5a7e81e4f381d502a6bf58a89e",
    "_type": "desktopSdkDoc",
    "title": "Draw.Region()",
    "pathName": "draw_region",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a region on a chart.\n\n## Method Return Value\n\nA **Region** object that represents the draw object.\n\n## Syntax\n\n**Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,**  \n**int endBarsAgo, ISeries`<double>` series, double price, Brush areaBrush, int areaOpacity, int displacement = 0)**  \n\n**Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,**  \n**int endBarsAgo, ISeries`<double>` series1, ISeries`<double>` series2, Brush outlineBrush,**  \n**Brush areaBrush, int areaOpacity, [int displacement] )**  \n\n**Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,**  \n**DateTime endTime, ISeries`<double>` series, double price, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,**  \n**DateTime endTime, ISeries`<double>` series1, ISeries`<double>` series2, Brush outlineBrush, Brush areaBrush, int areaOpacity)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* series, series1, series2\n* Any **Series<`double`>** type object such as an indicator, Close, High, Low etc. The value of the object will represent a y value.\n\n---\n\n* price\n* Any **double** value.\n\n---\n\n* outlineBrush\n* The brush used to color the region outline of draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* areaBrush\n* The brush used to color the fill region area of the draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* displacement\n* An optional parameter which will offset the barsAgo value for the **Series<`double`>** value used to match the desired [Displacement](displacement.htm). Default value is 0.\n{% /table %}\n\n## Examples\n\n```csharp\n// Draw a region between upper and lower Bollinger bands\nDraw.Region(this, \"tag1\", CurrentBar, 0, Bollinger(2, 14).Upper, Bollinger(2, 14).Lower, null, Brushes.Blue, 50);\n```\n\n## Tips\n\n1. Pass in null to the \"outlineColor\" parameter if you do not want to have an outline color.\n2. If you wanted to fill a region between a value (20 period simple moving average) and the upper edge of the chart, pass in an extreme value to the \"y\" parameter such as 1000000.\n3. Should you be drawing regions based on **Series<`double`>** objects instead of indicator plots, be sure to create the **Series<`double`>** with the **MaximumBarsLookBack.Infinite** parameter if the region you are drawing would be maintained on the chart for more than 256 bars back."
  },
  {
    "_id": "be2ea667237c537a932c4c2b53e372ceed7f657d62d83fd81dff340dd72165bc",
    "_type": "desktopSdkDoc",
    "title": "Draw.RegionHighlightX()",
    "pathName": "draw_regionhighlightx",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a region highlight x on a chart.\n\n## Method Return Value\n\nA **RegionHighlightX** object that represents the draw object.\n\n## Syntax\n\n**Draw.RegionHighlightX(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, Brush brush)**  \n\n**Draw.RegionHighlightX(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, Brush brush)**  \n\n**Draw.RegionHighlightX(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.RegionHighlightX(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.RegionHighlightX(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, bool isGlobal, string templateName)**  \n\n**Draw.RegionHighlightX(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](brushes)).\n\n---\n\n* areaBrush\n* The brush used to color the fill area of the draw object ([reference](brushes)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Fills in the region between the startBar and endBar\nDraw.RegionHighlightX(this, \"tag1\", 10, 0, rushes.Blue);\n```"
  },
  {
    "_id": "7c285d6c2a7c2bdc0b24d678402ea0e8838e00926e2d08ffa4255e7fc86495cb",
    "_type": "desktopSdkDoc",
    "title": "Draw.RegressionChannel()",
    "pathName": "draw_regressionchannel",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a regression channel.\n\n## Method Return Value\n\nA **RegressionChannel** object that represents the draw object.\n\n## Syntax\n\n**Draw.RegressionChannel(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, Brush brush)**\n\n**Draw.RegressionChannel(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, Brush brush)**  \n\n**Draw.RegressionChannel(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, int endBarsAgo, Brush upperBrush, DashStyleHelper upperDashStyleHelper, int upperWidth, Brush middleBrush, DashStyleHelper middleDashStyleHelper, int middleWidth, Brush lowerBrush, DashStyleHelper lowerDashStyleHelper, int lowerWidth)**  \n\n**Draw.RegressionChannel(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, DateTime endTime, Brush upperBrush, DashStyleHelper upperDashStyleHelper, int upperWidth, Brush middleBrush, DashStyleHelper middleDashStyleHelper, int middleWidth, Brush lowerBrush, DashStyleHelper lowerDashStyleHelper, int lowerWidth)**  \n\n**Draw.RegressionChannel(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, bool isGlobal, string templateName)**  \n\n**Draw.RegressionChannel(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](brushes)).\n\n---\n\n* upperDashStyle, middleDashStyle, lowerDashStyle\n* **DashStyleHelper.Dash**, **DashStyleHelper.DashDot**, **DashStyleHelper.DashDotDot**, **DashStyleHelper.Dot**, **DashStyleHelper.Solid**. Note: Fancier DashStyles like **DashDotDot** will require more resources than simple DashStyles like **Solid**.\n\n---\n\n* upperBrush, middleBrush, lowerBrush\n* The line colors ([reference](brushes)).\n\n---\n\n* upperWidth, middleWidth, lowerWidth\n* The line width.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a regression channel from the low 10 bars back to the high of 5 bars back\nDraw.RegressionChannel(this, \"tag1\", 10, 0, Brushes.Blue);\n```"
  },
  {
    "_id": "c5acfd62ee0e15a4b91373aa822273e3b3cc6e3c8d2823a80c2eba893936b36c",
    "_type": "desktopSdkDoc",
    "title": "Draw.RiskReward()",
    "pathName": "draw_riskreward",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a risk/reward on a chart.\n\n## Method Return Value\n\nA **RiskReward** object that represents the draw object.\n\n## Syntax\n\n**Draw.RiskReward(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime entryTime, double entryY, DateTime endTime, double endY, double ratio, bool isStop)**  \n\n**Draw.RiskReward(NinjaScriptBase owner, string tag, bool isAutoScale, int entryBarsAgo, double entryY, int endBarsAgo, double endY, double ratio, bool isStop)**  \n\n**Draw.RiskReward(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime entryTime, double entryY, DateTime endTime, double endY, double ratio, bool isStop, bool isGlobal, string templateName)**  \n\n**Draw.RiskReward(NinjaScriptBase owner, string tag, bool isAutoScale, int entryBarsAgo, double entryY, int endBarsAgo, double endY, double ratio, bool isStop, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* entryTime\n* The time where the draw object's entry will be drawn.\n\n---\n\n* entryBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object's entry will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* entryY\n* The y value co-ordinate where the draw object's entry price will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* endY\n* The starting y value co-ordinate where the draw object will be drawn.\n\n---\n\n* ratio\n* A **double** value determining the calculated ratio between the risk and reward based on the entry point. Example: reward : risk is ratio of 1.0.\n\n---\n\n* isStop\n* A bool value, when true will use the endTime / endBarsAgo and endY to set the stop and will automatically calculate the target based off the ratio value. When false, will set the target and will automatically calculate the stop based off the ratio value.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// draw a risk/reward tool starting from the current bar to 10 bars ago\n// with calculate a ratio of 2 based on stop level\nDraw.RiskReward(this, \"tag1\", false, 0, High[0], 10, Low[0], 2, true);\n```"
  },
  {
    "_id": "cf20904542939f7fdf7e7085b104ec48ebc089f51b00f0d9fd5f3f857bf87737",
    "_type": "desktopSdkDoc",
    "title": "Draw.Ruler()",
    "pathName": "draw_ruler",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a ruler.\n\n## Method Return Value\n\nA **Ruler** object that represents the draw object.\n\n## Syntax\n\n**Draw.Ruler(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, int textBarsAgo, double textY)**  \n\n**Draw.Ruler(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, DateTime textTime, double textY)**  \n\n**Draw.Ruler(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, int textBarsAgo, double textY, bool isGlobal, string templateName)**  \n\n**Draw.Ruler(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, DateTime textTime, double textY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* startBarsAgo\n* The number of bars ago (x value) of the 1st anchor point.\n\n---\n\n* startTime\n* The time of the 1st anchor point.\n\n---\n\n* startY\n* The y value of the 1st anchor point.\n\n---\n\n* endBarsAgo\n* The number of bars ago (x value) of the 2nd anchor point.\n\n---\n\n* endTime\n* The time of the 2nd anchor point.\n\n---\n\n* endY\n* The y value of the 2nd anchor point.\n\n---\n\n* textBarsAgo\n* The number of bars ago (x value) of the 3rd anchor point.\n\n---\n\n* textTime\n* The time of the 3rd anchor point.\n\n---\n\n* textY\n* The y value of the 3rd anchor point.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a ruler measuring the primary bar series\nDraw.Ruler(this, \"tag1\", true, 4, Low[4], 3, High[3], 1, Low[1]);\n```"
  },
  {
    "_id": "07c186950c91cb43288c5b685626eba0e60c987f77f6294cfe493654803e638f",
    "_type": "desktopSdkDoc",
    "title": "Draw.Square()",
    "pathName": "draw_square",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a square.\n\n## Method Return Value\n\nA **Square** object that represents the draw object.\n\n## Syntax\n\n**Draw.Square(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)**  \n\n**Draw.Square(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)**  \n\n**Draw.Square(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Square(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Square(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)**  \n\n**Draw.Square(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* y\n* The y value.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: The size of the square is tied to the chart's BarWidth and thus will scale automatically as the chart is resized.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Paints a red square on the current bar 1 tick below the low\nDraw.Square(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n```"
  },
  {
    "_id": "db49c0794f1828a7028d9000c5fb642239092b0b99e751682c8568b897fe0f76",
    "_type": "desktopSdkDoc",
    "title": "Draw.Text()",
    "pathName": "draw_text",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws text.\n\n## Method Return Value\n\nA **Text** object that represents the draw object.\n\n## Syntax\n\n**Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y)**  \n\n**Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y, Brush textBrush)**  \n\n**Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y, bool isGlobal, string templateName)**  \n\n**Draw.Text(NinjaScriptBase owner, string tag, bool isAutoScale, string text, int barsAgo, double y, int yPixelOffset, Brush textBrush, SimpleFont font, TextAlignment alignment, Brush outlineBrush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Text(NinjaScriptBase owner, string tag, bool isAutoScale, string text, DateTime time, double y, int yPixelOffset, Brush textBrush, SimpleFont font, TextAlignment alignment, Brush outlineBrush, Brush areaBrush, int areaOpacity)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale. Default value is false.\n\n---\n\n* text\n* The text you wish to draw.\n\n---\n\n* barsAgo\n* The bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* time\n* The time where the draw object will be drawn.\n\n---\n\n* y\n* The y co-ordinate location the object will be drawn.\n\n---\n\n* yPixelOffset\n* The offset value in pixels from within the text box area.\n\n---\n\n* textBrush\n* The brush used to color the text of the draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.textalignment%28v=vs.110%29.aspx)).\n\n---\n\n* font\n* A **Simple Font** object.\n\n---\n\n* alignment\n* **TextAlignment.Center**, **TextAlignment.Left**, **TextAlignment.Right**, **TextAlignment.Justify** ([reference](https://msdn.microsoft.com/en-us/library/system.windows.textalignment(v=vs.110).aspx)).\n\n---\n\n* outlineBrush\n* The brush used to color the text box outline ([reference](http://msdn.microsoft.com/en-us/library/system.drawing.color_members(v=vs.90).aspx)).\n\n---\n\n* areaBrush\n* The brush used to color the text box fill area ([reference](http://msdn.microsoft.com/en-us/library/system.drawing.color_members(v=vs.90).aspx)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws text\nDraw.Text(this, \"tag1\", \"Text to draw\", 10, 1000, Brushes.Black);\n```\n\n{% callout type=\"note\" %}\n\nTip: In some cases, it may be useful to pass in the **ChartControl.Properties** **TextFont** brush as well as the **LabelFont** **SimpleFont** object to render your custom text. This will help ensure that the text will be visible and match what a user has configured for their chart label display settings.\n\n{% /callout %}\n\n```csharp\n\n// match the text brush to what the user has configured on their chart\nDraw.Text(this, \"tag1\", \"Text to draw\", 10, 1000, ChartControl.Properties.ChartText);\n\n```"
  },
  {
    "_id": "b1f8bb7304bf07495bf160e7975cc881ec262fa63a344e1c3b44cff6deda0dc4",
    "_type": "desktopSdkDoc",
    "title": "Draw.TextFixed()",
    "pathName": "draw_textfixed",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws text in one of 5 available pre-defined fixed locations on panel 1 (price panel) of a chart. Please note the **Z-Order** is internally set for the method to always be drawn on top.\n\n## Method Return Value\n\nA **TextFixed** object that represents the draw object.\n\n## Syntax\n\n**Draw.TextFixed**(**NinjaScriptBase** owner, **string** tag, **string** text, **TextPosition** textPosition, **Brush** textBrush, **SimpleFont** font, **Brush** outlineBrush, **Brush** areaBrush, **int** areaOpacity)  \n\n**Draw.TextFixed**(**NinjaScriptBase** owner, **string** tag, **string** text, **TextPosition** textPosition)  \n\n**Draw.TextFixed**(**NinjaScriptBase** owner, **string** tag, **string** text, **TextPosition** textPosition, **bool** isGlobal, **string** templateName)\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* text\n* The text you wish to draw.\n\n---\n\n* TextPosition\n* **TextPosition.BottomLeft**\n* **TextPosition.BottomRight**\n* **TextPosition.Center**\n* **TextPosition.TopLeft**\n* **TextPosition.TopRight**\n\n---\n\n* textBrush\n* The brush used to color the text of the draw object ([reference](brushes)).\n\n---\n\n* font\n* A **SimpleFont** object.\n\n---\n\n* outlineBrush\n* The brush used to color the text box outline ([reference](http://msdn.microsoft.com/en-us/library/system.drawing.color_members(v=vs.90).aspx)).\n\n---\n\n* areaBrush\n* The brush used to color the text box fill area ([reference](http://msdn.microsoft.com/en-us/library/system.drawing.color_members(v=vs.90).aspx)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws text in the upper right corner of panel 1\nDraw.TextFixed(this, \"tag1\", \"Text to draw\", TextPosition.TopRight);\n```\n\n{% callout type=\"note\" %}\n\nTip: In some cases, it may be useful to pass in the ChartControl.Properties **TextFont brush as well as the LabelFont**SimpleFont object to render your custom text. This will help ensure that the text will be visible and match what a user has configured for their chart label display settings.\n\n{% /callout %}\n\n```csharp\n// match the text brush to what the user has configured on their chart\nDraw.TextFixed(this, \"myTextFixed\", \"Hello world!\", TextPosition.BottomRight, ChartControl.Properties.ChartText, ChartControl.Properties.LabelFont, Brushes.Blue, Brushes.Transparent, 0);\n\n```"
  },
  {
    "_id": "46aef84390a1c65337dbd75b853556f18bd4bcfedacceca9740a425fd2664bf7",
    "_type": "desktopSdkDoc",
    "title": "Draw.TimeCycles()",
    "pathName": "draw_timecycles",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a time cycle based on two points.\n\n## Method Return Value\n\nA **TimeCycles** object that represents the draw object.\n\n## Syntax\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, double endY, Brush brush, bool drawOnPricePanel)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, bool isGlobal, string templateName)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, Brush brush, bool drawOnPricePanel)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, bool isGlobal, string templateName)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, Brush brush, Brush areaBrush, int areaOpacity)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, Brush brush, Brush areaBrush, int areaOpacity)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, DateTime startTime, DateTime endTime, Brush brush)**\n\n**Draw.TimeCycles(NinjaScriptBase owner, string tag, int startBarsAgo, int endBarsAgo, Brush brush)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* startBarsAgo\n* The starting bar (x axis co-ordinate) where the draw object will be drawn. For example, a value of 10 would paint the draw object 10 bars back.\n\n---\n\n* startTime\n* The starting time where the draw object will be drawn.\n\n---\n\n* endBarsAgo\n* The end bar (x axis co-ordinate) where the draw object will terminate.\n\n---\n\n* endTime\n* The end time where the draw object will terminate.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a Time Cycles object based on 10 bars back to the current bar that is cornflower blue with an opacity of 40\nDraw.TimeCycles(this, \"tag1\", 0, 10, Brushes.CornflowerBlue, Brushes.CornflowerBlue, 40);\n\n```"
  },
  {
    "_id": "30b94e10333166aec5c2471a362cf1a71dc4306e62780d456d87ce19f6448311",
    "_type": "desktopSdkDoc",
    "title": "Draw.TrendChannel()",
    "pathName": "draw_trendchannel",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a trend channel.\n\n## Method Return Value\n\nA **TrendChannel** object that represents the draw object.\n\n## Syntax\n\n**Draw.TrendChannel(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y)**  \n\n**Draw.TrendChannel(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime anchor1Time, double anchor1Y, DateTime anchor2Time, double anchor2Y, DateTime anchor3Time, double anchor3Y)**  \n\n**Draw.TrendChannel(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, bool isGlobal, string templateName)**  \n\n**Draw.TrendChannel(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime anchor1Time, double anchor1Y, DateTime anchor2Time, double anchor2Y, DateTime anchor3Time, double anchor3Y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* anchor1BarsAgo\n* The number of bars ago (x value) of the 1st anchor point.\n\n---\n\n* anchor1Time\n* The time of the 1st anchor point.\n\n---\n\n* anchor1Y\n* The y value of the 1st anchor point.\n\n---\n\n* anchor2BarsAgo\n* The number of bars ago (x value) of the 2nd anchor point.\n\n---\n\n* anchor2Time\n* The time of the 2nd anchor point.\n\n---\n\n* anchor2Y\n* The y value of the 2nd anchor point.\n\n---\n\n* anchor3BarsAgo\n* The number of bars ago (x value) of the 3rd anchor point.\n\n---\n\n* anchor3Time\n* The time of the 3rd anchor point.\n\n---\n\n* anchor3Y\n* The y value of the 3rd anchor point.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a trend channel\nDraw.TrendChannel(this, \"tag1\", true, 10, Low[10], 0, High[0], 10, High[10] + 5 * TickSize);\n\n```"
  },
  {
    "_id": "81b07f8c1ed5ff6456d1b3df365f747cdc2f90c60bb1843881f5b75d3ac6ee97",
    "_type": "desktopSdkDoc",
    "title": "Draw.Triangle()",
    "pathName": "draw_triangle",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a triangle.\n\n## Method Return Value\n\nA **Triangle** object that represents the draw object.\n\n## Syntax\n\n**Draw.Triangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int middleBarsAgo, double middleY, int endBarsAgo, double endY, Brush brush)**  \n\n**Draw.Triangle(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime middleTime, double middleY, DateTime endTime, double endY, Brush brush)**  \n\n**Draw.Triangle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int middleBarsAgo, double middleY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Triangle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime midTime, double middleY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity)**  \n\n**Draw.Triangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int middleBarsAgo, double middleY, int endBarsAgo, double endY, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.Triangle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int middleBarsAgo, double middleY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Triangle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime midTime, double middleY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)**  \n\n**Draw.Triangle(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int middleBarsAgo, double middleY, int endBarsAgo, double endY, bool isGlobal, string templateName)**  \n\n**Draw.Triangle(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime middleTime, double middleY, DateTime endTime, double endY, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* startBarsAgo\n* The number of bars ago (x value) of the 1st anchor point.\n\n---\n\n* startTime\n* The time of the 1st anchor point.\n\n---\n\n* startY\n* The y value of the 1st anchor point.\n\n---\n\n* middleBarsAgo\n* The number of bars ago (x value) of the 2nd anchor point.\n\n---\n\n* midTime\n* The time of the 2nd anchor point.\n\n---\n\n* middleY\n* The y value of the 2nd anchor point.\n\n---\n\n* endBarsAgo\n* The number of bars ago (x value) of the 3rd anchor point.\n\n---\n\n* endTime\n* The time of the 3rd anchor point.\n\n---\n\n* endY\n* The y value of the 3rd anchor point.\n\n---\n\n* brush\n* The brush used to color the outline of draw object ([reference](brushes)).\n\n---\n\n* areaBrush\n* The brush used to color the fill area of the draw object ([reference](brushes)).\n\n---\n\n* areaOpacity\n* Sets the level of transparency for the fill color. Valid values between 0 - 100. (0 = completely transparent, 100 = no opacity).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Paints a blue triangle on the chart\nDraw.Triangle(this, \"tag1\", 4, Low[4], 3, High[3], 1, Low[1], Brushes.Blue);\n```"
  },
  {
    "_id": "012841701bed7bc72ed2b164d1131136191d8ac70ad70dad3e649647ab6df4d0",
    "_type": "desktopSdkDoc",
    "title": "Draw.TriangleDown()",
    "pathName": "draw_triangledown",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a triangle pointing down.\n\n## Method Return Value\n\nA **TriangleDown** object that represents the draw object.\n\n## Syntax\n\n**Draw.TriangleDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)**  \n\n**Draw.TriangleDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)**  \n\n**Draw.TriangleDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.TriangleDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.TriangleDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, bool isGlobal, string templateName)**  \n\n**Draw.TriangleDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* y\n* The y value.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: The size of the triangle is tied to the chart's BarWidth and thus will scale automatically as the chart is resized.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Paints a red triangle pointing down on the current bar 1 tick below the low\nDraw.TriangleDown(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n```"
  },
  {
    "_id": "ed93409d550a5c07e99a14b4efa4866cc8ffa291b1326790d4ac56f51aad1b83",
    "_type": "desktopSdkDoc",
    "title": "Draw.TriangleUp()",
    "pathName": "draw_triangleup",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a triangle pointing up.\n\n## Method Return Value\n\nA **TriangleUp** object that represents the draw object.\n\n## Syntax\n\n**Draw.TriangleUp(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)**  \n\n**Draw.TriangleUp(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)**  \n\n**Draw.TriangleUp(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.TriangleUp(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)**  \n\n**Draw.TriangleUp(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)**  \n\n**Draw.TriangleUp(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* isAutoScale\n* Determines if the draw object will be included in the y-axis scale.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* y\n* The y value.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](brushes)).\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: The size of the triangle is tied to the chart's BarWidth and thus will scale automatically as the chart is resized.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// Paints a red triangle pointing up on the current bar 1 tick below the low\nDraw.TriangleUp(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n```"
  },
  {
    "_id": "d288797487a9dc35105745efa38c15000455abc15039eae1ee66ba1de431a658",
    "_type": "desktopSdkDoc",
    "title": "Draw.VerticalLine()",
    "pathName": "draw_verticalline",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDraws a vertical line.\n\n## Method Return Value\n\nA **VerticalLine** object that represents the draw object.\n\n## Syntax\n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, Brush brush)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, Brush brush)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, bool isGlobal, string templateName)**  \n\n**Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, bool isGlobal, string templateName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* owner\n* The hosting **NinjaScript** object which is calling the draw method. Typically will be the object which is calling the draw method (e.g., \"this\").\n\n---\n\n* tag\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n\n---\n\n* barsAgo\n* The bar the object will be drawn at. A value of 10 would be 10 bars ago.\n\n---\n\n* time\n* The time the object will be drawn at.\n\n---\n\n* brush\n* The brush used to color draw object ([reference](https://msdn.microsoft.com/en-us/library/system.windows.media.brushes%28v=vs.110%29.aspx)).\n\n---\n\n* dashStyle\n \t* **DashStyleHelper.Dash**  \n \t* **DashStyleHelper.DashDot**  \n \t* **DashStyleHelper.DashDotDot**  \n \t* **DashStyleHelper.Dot**  \n \t* **DashStyleHelper.Solid**  \n   \n  Note: Fancier DashStyles like **DashDotDot** will require more resources than simple DashStyles like **Solid**.\n\n---\n\n* width\n* The width of the draw object.\n\n---\n\n* drawOnPricePanel\n* Determines if the draw-object should be on the price panel or a separate panel.\n\n---\n\n* isGlobal\n* Determines if the draw object will be global across all charts which match the instrument.\n\n---\n\n* templateName\n* The name of the drawing tool template the object will use to determine various visual properties (empty string could be used to just use the UI default visuals instead).\n{% /table %}\n\n## Examples\n\n```csharp\n// Draws a vertical line  \nDraw.VerticalLine(this, \"tag1\", 10, Brushes.Black);\n\n```"
  },
  {
    "_id": "c613c7687a303c38a0203a4cdbbd8f9026120afe21b57be0753c3459b1a5e291",
    "_type": "desktopSdkDoc",
    "title": "Ellipse",
    "pathName": "ellipse",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding an Ellipse **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* AreaBrush\n\n* A **Brush** class representing the fill color of the draw object\n\n---\n\n* AreaOpacity\n\n* An **int** value representing the opacity of the area color\n\n---\n\n* OutlineStroke\n\n* The **Stroke** object used to draw the object's outline\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Paint a red ellipse on the current bar\nEllipse myEllipse = Draw.Ellipse(this, \"tag1\", true, 5, Close[5], 0, Close[0], Brushes.Red, Brushes.Red, 5);\n\n// Change the AreaOpacity of the Ellipse\nmyEllipse.AreaOpacity = 0;\n```"
  },
  {
    "_id": "de4c449f725edafc98e5f3737fd1f3c79471c4090b34682cc4d34f71726f4737",
    "_type": "desktopSdkDoc",
    "title": "ExtendedLine",
    "pathName": "extendedline",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding an Extended Line **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* Stroke\n\n* A **Stroke** object used to draw the object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a dotted lime green Extended Line\nExtendedLine myLine = Draw.ExtendedLine(this, \"tag1\", 10, Close[10], 0, Close[0], Brushes.LimeGreen, DashStyleHelper.Dot, 2);\n\n// Make the line a Global Drawing Object\nmyLine.IsGlobalDrawingTool = true;\n```"
  },
  {
    "_id": "1d9d36b268ef318e02439fe5370b790686fc14ac192b9520f5f1fd8cba5a14b3",
    "_type": "desktopSdkDoc",
    "title": "FibonacciCircle",
    "pathName": "fibonaccicircle",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Fibonacci Circle **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An IDrawingTool's ChartAnchor representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An IDrawingTool's ChartAnchor representing the end point of the drawing object\n\n---\n\n* PriceLevels\n\n* A collection of prices calculated by the drawing object\n\n---\n\n* IsTimePriceDividedSeparately\n\n* A bool value which when true determines if the time and price are calculated together as a ratio, or independently\n\n---\n\n* IsTextDisplayed\n\n* A bool value determining if the draw object should display text on the chart.\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp ns |\n// Instantiate a Fibonacci circle\nFibonacciCircle myFibCirc = Draw.FibonacciCircle(this, \"tag1\", true, 10, Low[10], 0, High[0]);\n\n// Ensure that text is being displayed on the Drawing Object\nmyFibCirc.IsTextDisplayed = true;\n```"
  },
  {
    "_id": "8bbe041a1730e4df9aa1d980ef3fda525f7b1674dfbeff0d7d63648aca92c490",
    "_type": "desktopSdkDoc",
    "title": "FibonacciExtensions",
    "pathName": "fibonacciextensions",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Fibonacci Extensions **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* ExtensionAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the extension point of the drawing object\n\n---\n\n* PriceLevels\n\n* A collection of prices calculated by the drawing object\n\n---\n\n* TextLocation\n\n* An enum determining the text location; can be set to **TextLocation.Off** to remove text\n\n---\n\n* IsExtendedLinesLeft\n\n* A bool value determining if the draw object should draw lines to the far left side of the screen\n\n---\n\n* IsExtendedLinesRight\n\n* A bool value determining if the draw object should draw lines to the far right side of the screen\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiates a Fibonacci Extension\nFibonacciExtensions myFibExt = Draw.FibonacciExtensions(this, \"tag1\", true, 4, Low[4], 3, High[3], 1, Low[1]);\n\n// Extend the Fibonacci Extension object's lines to the right\nmyFibExt.IsExtendedLinesRight = true;\n```"
  },
  {
    "_id": "61882adc9fddd659d0b3248c388d81d4e53e142973ebc1af021645400e3fef11",
    "_type": "desktopSdkDoc",
    "title": "FibonacciRetracements",
    "pathName": "fibonacciretracements",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Fibonacci Retracements **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An IDrawingTool's ChartAnchor representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An IDrawingTool's ChartAnchor representing the end point of the drawing object\n\n---\n\n* PriceLevels\n\n* A collection of prices calculated by the drawing object\n\n---\n\n* TextLocation\n\n* An enum determining the text location; can be set to **TextLocation.Off** to remove text\n\n---\n\n* IsExtendedLinesLeft\n\n* A bool value determining if the draw object should draw lines to the far left side of the screen\n\n---\n\n* IsExtendedLinesRight\n\n* A bool value determining if the draw object should draw lines to the far right side of the screen\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a FibonacciRetracements object\nFibonacciRetracements myFibRet = Draw.FibonacciRetracements(this, \"tag1\", true, 10, Low[10], 0, High[0]);\n\n// Set the object's lines to extend to the right\nmyFibRet.IsExtendedLinesRight = true;\n```"
  },
  {
    "_id": "7362653062521fc997d0098bca0c34d1688d13fef8a9c9fb7bea97d2f95957fa",
    "_type": "desktopSdkDoc",
    "title": "FibonacciTimeExtensions",
    "pathName": "fibonaccitimeextensions",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Fibonacci Time Extensions **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* PriceLevels\n\n* A collection of prices calculated by the drawing object\n\n---\n\n* IsTextDisplayed\n\n* A bool value determining if the draw object should display text on the chart.\n\n---\n\n* IsExtendedLinesLeft\n\n* A bool value determining if the draw object should draw lines to the far left side of the screen\n\n---\n\n* IsExtendedLinesRight\n\n* A bool value determining if the draw object should draw lines to the far right side of the screen\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a FibonacciTimeExtensions object\nFibonacciTimeExtensions myFibTime = Draw.FibonacciTimeExtensions(this, \"tag1\", false, 10, Low[10], 0, High[0]);\n\n// Instantiate a new PriceLevel to be used in the step below\nPriceLevel myLevel = new PriceLevel(99, Brushes.Black);\n\n// Change the object's price level at index 3\nmyFibTime.PriceLevels[3] = myLevel;\n```"
  },
  {
    "_id": "5edfe3d1e066b1225b3c6c686305b3a6a504dbcedf5dfc74beb9f72e284c7d96",
    "_type": "desktopSdkDoc",
    "title": "GannFan",
    "pathName": "gannfan",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Gann Fan **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* Anchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* PriceLevels\n\n* A collection of prices calculated by the drawing object\n\n---\n\n* GannFanDirection\n\n* Possible values:\n\n* **GannFanDirection.DownLeft**\n\n* **GannFanDirection.DownRight**\n\n* **GannFanDirection.UpLeft**\n\n* **GannFanDirection.UpRight**\n\n---\n\n* PointsPerBar\n\n* A **double** value representing the number of points per bar\n\n---\n\n* IsTextDisplayed\n\n* A bool value representing if text will be drawn along with the draw object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a GannFan object\nGannFan myFan = Draw.GannFan(this, \"tag1\", true, 0, Low[0]);\n\n// Instantiate a new PriceLevel to be used in the step below\nPriceLevel myLevel = new PriceLevel(99, Brushes.Black);\n\n// Change the object's price level at index 3\nmyFan.PriceLevels[3] = myLevel;\n```"
  },
  {
    "_id": "3ef1a965494cae8dc6faf9c2158ccb4111b4fc4e1aba8a0a375f0e31b38b30fa",
    "_type": "desktopSdkDoc",
    "title": "HorizontalLine",
    "pathName": "horizontalline",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Horizontal Line **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* StartAnchor\n* Stroke\n\n---\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n* A **Stroke** object used to draw the object\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a HorizontalLine object\nHorizontalLine myLine = Draw.HorizontalLine(this, \"tag1\", 1000, Brushes.Black);\n\n// Set a new Stroke for the object\nmyLine.Stroke = new Stroke(Brushes.Green, DashStyleHelper.Dash, 5);\n```"
  },
  {
    "_id": "8c665d8b3d9845e3c80814c68e299cd4cb3296fd300d076757f51e5ff4ad7cb6",
    "_type": "desktopSdkDoc",
    "title": "IDrawingTool",
    "pathName": "idrawingtool",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a drawn chart object.\n\nIDrawingTool Properties are standard properties that are shared by all drawing tools.\n\nEach specific **IDrawingTool** will have its own uniquely named **ChartAnchor** representing where the object was drawn on the chart. The name and number of **ChartAnchors** will be specific to that drawing tool (e.g., **StartAnchor**, **EndAnchor**, etc.), however the fields available will be the same (e.g., **BarsAgo**, **DrawnOnBar**, etc.). Details on those shared fields are outlined in the **ChartAnchor Properties** section toward the bottom of this topic.\n\n{% callout type=\"note\" %}\n\nFor implementing a custom Drawing Tool project, please see the [DrawingTools](drawing_tools) section of this help guide.\n\n{% /callout %}\n\n## IDrawingTool Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* Anchors\n\n* A read-only collection of all of the [IDrawingTool's ChartAnchors](idrawingtool.md#chartanchor)\n\n---\n\n* AttachedTo\n\n* An enum determining where the drawing tool is attached. Possible values are: **AttachedToType.Bars**, **AttachedToType.GlobalInstrument**, **AttachedToType.Indicator**, **AttachedToType.Strategy**\n\n---\n\n* DrawingState\n\n* The current **DrawingState** of the drawing tool\n\n---\n\n* DrawnBy\n\n* An object value indicating which type of **NinjaScript** the drawing tool originated (null if user drawn)\n\n---\n\n* IsAttachedToNinjaScript\n\n* A read-only bool indicating if the drawing tool is attached to an indicator or strategy\n\n---\n\n* IgnoresUserInput\n\n* A read-only bool determining if the drawing tool can be interacted with by the user.\n\n---\n\n* IsGlobalDrawingTool\n\n* A bool determining if the drawing tool displays on all charts of the instrument\n\n---\n\n* IsLocked\n\n* A bool determining if the drawing tool can be moved\n\n---\n\n* IsSeparateZOrder\n\n* A bool determining if the drawing tool will reside on a different ZOrder from the **NinjaScript** object it was drawn\n\n---\n\n* IsUserDrawn\n\n* A read-only bool indicating if drawing tool was manually drawn by a user\n\n---\n\n* PanelIndex\n\n* An int value representing the panel the drawing tool resides\n\n---\n\n* SupportsAlerts\n\n* A read-only bool indicating if the drawing tool can be used for creating an alert\n\n---\n\n* Tag\n\n* A string value representing the unique ID of the draw object. (Global draw objects will have an \"@\" added as a prefix to the string)\n\n---\n\n* ZOrderType\n\n* An enum indicating the order in which the drawing tool will be drawn. Possible values are: **DrawingToolZOrder.Normal**, **DrawingToolZOrder.AlwaysDrawnFirst**, **DrawingToolZOrder.AlwaysDrawnLast**\n\n---\n\n{% /table %}\n\n## ChartAnchor Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* <`chartanchor`>.BarsAgo\n\n* An int representing the \"barsAgo\" value that was passed to the Draw method. Note: This value will NOT be set for objects drawn manually\n\n---\n\n* <`chartanchor`>.DisplayName\n\n* A string representing name of the **DrawingTool's** chart anchor that is displaying on the UI\n\n---\n\n* <`chartanchor`>.DrawingTool\n\n* The **IDrawingTool** object which created the **DrawingTool's** chart anchor object\n\n---\n\n* <`chartanchor`>.DrawnOnBar\n\n* An int representing the [CurrentBar](currentbar) value that the **DrawingTool's** chart anchor was drawn\n\n---\n\n* <`chartanchor`>.IsNinjaScriptDrawn\n\n* A bool indicating the object was drawn programmatically\n\n---\n\n* <`chartanchor`>.Price\n\n* A double representing the price the **DrawingTool's** chart anchor was drawn\n\n---\n\n* <`chartanchor`>.SlotIndex\n\n* A double representing the **DrawingTool's** chart anchor index value the anchor was drawn\n\n---\n\n* <`chartanchor`>.Time\n\n* A DateTime representing the time value the **DrawingTool's** chart anchor was drawn\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\nText myText;\nprotected override void OnBarUpdate()\n{   \n    if(CurrentBar == 50)\n        myText = Draw.Text(this, \"tag\", \"test\", 0, High[0]);     \n  \n    if(myText != null)\n    {           \n        Print(myText.Anchor.DrawnOnBar); // drawn on bar 50\n    }\n}\n```"
  },
  {
    "_id": "91109cb3e58eefee70119f2b6dbcc5f49f14deaabf8216a0f064408033ca6706",
    "_type": "desktopSdkDoc",
    "title": "Draw.Line()",
    "pathName": "draw_line",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Line **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* Stroke\n\n* A **Stroke** object used to draw the object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Line object\nNinjaTrader.NinjaScript.DrawingTools.Line myLine = Draw.Line(this, \"tag1\", false, 10, 1000, 0, 1001, Brushes.LimeGreen, DashStyleHelper.Dot, 2);\n\n// Set a new Stroke for the object\nmyLine.Stroke = new Stroke(Brushes.Green, DashStyleHelper.Dash, 5);\n```\n\n{% callout type=\"note\" %}\n\nTo differentiate between **NinjaTrader.NinjaScript.DrawingTools.Line** and **NinjaTrader.Gui.Line** when assigning a Line object, you will need to invoke the former path explicitly, as seen in the example above.\n\n{% /callout %}"
  },
  {
    "_id": "538e39eefcbf3366c23baacf62fec056da835b6dad73a2bb849b1e428c659205",
    "_type": "desktopSdkDoc",
    "title": "PathTool",
    "pathName": "pathtool",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a PathTool **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* Stroke\n\n* A **Stroke** object used to draw the object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a PathTool object\nPathTool myPathTool = Draw.PathTool(this, \"tag1\", false, 20, 194, 10, 184, 13, 176, 25, 182);\n```"
  },
  {
    "_id": "2b3b181209241d3f3cc2fb32428a2d442cbb8265589891dbe8d2f8572cd08ebf",
    "_type": "desktopSdkDoc",
    "title": "Polygon",
    "pathName": "polygon",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a **Polygon** **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* Stroke\n\n* A **Stroke** object used to draw the object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Polygon object\nPolygon myPolygon = Draw.Polygon(this, \"tag1\", false, 20, 194, 10, 184, 13, 176, 25, 182);\n\n// Set a new area brush for the object\nmyPolygon.AreaBrush = Brushes.Green;\n```"
  },
  {
    "_id": "a2c7dc395e1908d0a25b12363700e227264a982984b81858572420bb692e1f4d",
    "_type": "desktopSdkDoc",
    "title": "PriceLevels Collection",
    "pathName": "pricelevels_collection",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of PriceLevel objects defining lines for multi-price-level **Drawing Tools** (Fibonacci tools, etc.). Each PriceLevel within the collection can be configured programmatically or analyzed to obtain the parameters of user-drawn objects.\n\n{% callout type=\"note\" %}\n\nPriceLevels is only used with the following pre-built Drawing Tools, but it can be used with custom Drawing Tools, as well:\n\n* [AndrewsPitchfork](draw_andrewspitchfork)\n* [FibonacciCircle](draw_fibonaccicircle)\n* [FibonacciExtensions](draw_fibonacciextensions)\n* [FibonacciRetracements](draw_fibonacciretracements)\n* [FibonacciTimeExtensions](draw_fibonaccitimeextensions)\n* [GannFan](draw_gannfan)\n* [TrendChannel](draw_trendchannel)\n{% /callout %}\n\n## Syntax\n\n**PriceLevels[int idx]**  \n**PriceLevels[int idx].GetPrice(double startPrice, double totalPriceRange, bool isInverted)**  \n**PriceLevels[int idx].GetY(ChartScale chartScale, double startPrice, double totalPriceRange, bool isInverted)**\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* **GetPrice()**\n* Returns a double which represents the price value at the specified price level\n\n---\n\n* **GetY()**\n* Returns a float representing the y-pixel coordinate at the specified price level\n\n---\n\n* **Name**\n* The Name property of the specified PriceLevel. Set to a formatted version of Value by default.\n\n---\n\n* **Stroke**\n* The Stroke used to draw the line associated with the specified PriceLevel\n\n---\n\n* **Tag**\n* A tag used to identify the specified PriceLevel. Null by default.\n\n---\n\n* **Value**\n* The value of the PriceLevel in percentage terms\n{% /table %}\n\n## Examples\n\n```csharp\n// Define a FibonacciRetracements object outside of OnBarUpdate(), so the same object can be re-used**\nFibonacciRetracements myRetracements;\n\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 20)\n        return;\n\n    // Instantiate myRetracements\n    myRetracements = Draw.FibonacciRetracements(this, \"fib\", true, 20, High[20], 2, Low[2]);\n\n    // Print each price level and the corresponding value in the PriceLevels collection contain in myRetracements\n    // setting isInverted correctly is important for the Fibonacci Retracements since it will define which starting point is used, as it changes based\n    // on the anchors, i.e. if the Fibonacci is drawn from 100% to 0% (default) or the other inverted way (0% to 100%).\n    foreach (PriceLevel p in myRetracements.PriceLevels)\n    {\n        Print(p.Value);\n        Print(p.GetPrice(myRetracements.StartAnchor.Price, myRetracements.EndAnchor.Price - myRetracements.StartAnchor.Price, false));\n    }\n}\n```\n\n```csharp\n// Define a TrendChannel object outside of OnBarUpdate(), so the same object can be re-used\nTrendChannel myTCh;\n\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 20)\n        return;\n\n    // Instantiate myTrendChannel\n    myTCh = Draw.TrendChannel(this, \"tc\", true, 10, Low[10], 0, High[0], 10, High[10] + 5 * TickSize);\n\n    // Print each price level and the corresponding value in the PriceLevels collection contain in myTrendChannel\n    // For the TrendChannel the 0% is the Trend anchor, the 100% the Parallel anchor\n    foreach (PriceLevel p in myTCh.PriceLevels)\n    {\n        Print(p.Value);\n        Print(p.GetPrice(myTCh.TrendStartAnchor.Price, myTCh.ParallelStartAnchor.Price - myTCh.TrendStartAnchor.Price, false));\n    }\n}\n\n```"
  },
  {
    "_id": "c04bc270f965db4d7ab365b3b865b743e35e13e295c7b15fb795e2a01d24a639",
    "_type": "desktopSdkDoc",
    "title": "Ray",
    "pathName": "ray",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Ray **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* Stroke\n\n* A **Stroke** object used to draw the object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Ray object\nRay myRay = Draw.Ray(this, \"tag1\", 10, 1000, 0, 1001, Brushes.LimeGreen);\n \n// Set a new Stroke for the object\nmyRay.Stroke = new Stroke(Brushes.Green, DashStyleHelper.DashDot, 3);\n```"
  },
  {
    "_id": "32dfed947e8bca93c393bba8525ecad6b7d623d9aaad23078343783f8e3603ff",
    "_type": "desktopSdkDoc",
    "title": "Rectangle",
    "pathName": "rectangle",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Rectangle **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* AreaBrush\n\n* A **Brush** object representing the fill color of the draw object\n\n---\n\n* AreaOpacity\n\n* An **int** value representing the opacity of the area color\n\n---\n\n* OutlineStroke\n\n* The **Stroke** object used to draw the object's outline\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Rectangle object\nRectangle myRec = Draw.Rectangle(this, \"tag1\", 10, Low[10] - TickSize, 5, High[5] + TickSize, Brushes.Blue);\n\n// Set the object's AreaBrush to Blue\nmyRec.AreaBrush = Brushes.Blue;\n```"
  },
  {
    "_id": "c697d2981bf416569a16cfbcdec1542b5398f3cc77d2b905819aa99c46ecf6f6",
    "_type": "desktopSdkDoc",
    "title": "Region",
    "pathName": "region",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a **Region** [**IDrawingTool**](idrawingtool).\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An [**IDrawingTool's ChartAnchor**](idrawingtool.htm#chartanchor) representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An [**IDrawingTool's ChartAnchor**](idrawingtool.htm#chartanchor) representing the starting point of the drawing object\n\n---\n\n* AreaOpacity\n\n* An int value representing the opacity of the area color\n\n---\n\n* AreaBrush\n\n* A [**Brush**](http://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) object representing the fill color of the draw object\n\n---\n\n* OutlineStroke\n\n* A Stroke used for the outline of the region\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Region object\nRegion myRegion = Draw.Region(this, \"tag1\", CurrentBar, 0, Bollinger(2, 14).Upper, Bollinger(2, 14).Lower, null, Brushes.Blue, 50); \n\n// Set the object's OutlineStroke to a new Stroke\nmyRegion.OutlineStroke = new Stroke(Brushes.Red, DashStyleHelper.Solid, 3);\n```"
  },
  {
    "_id": "bcd910248581647054e8f7de1bb7a51f4c9cc26e616224df57336b13a490a122",
    "_type": "desktopSdkDoc",
    "title": "RegionHighlightX",
    "pathName": "regionhighlightx",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Region Highlight X **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* AreaBrush\n\n* A **Brush** class representing the fill color of the draw object\n\n---\n\n* AreaOpacity\n\n* An **int** value representing the opacity of the area color\n\n---\n\n* OutlineStroke\n\n* The **Stroke** object used to draw the object's outline\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a RegionHighlightX object\nRegionHighlightX myReg = Draw.RegionHighlightX(this, \"tag1\", 10, 0, Brushes.Blue);\n \n// Change the object's opacity\nmyReg.AreaOpacity = 25;\n```"
  },
  {
    "_id": "99ec1461b1c3af16a0b238e25c5a51bb5203ea4e9d27c635ddd175038ebb2f94",
    "_type": "desktopSdkDoc",
    "title": "RegionHighlightY",
    "pathName": "regionhighlighty",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Region Highlight Y **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* AreaBrush\n\n* A **Brush** class representing the fill color of the draw object\n\n---\n\n* AreaOpacity\n\n* An **int** value representing the opacity of the area color\n\n---\n\n* OutlineStroke\n\n* The **Stroke** object used to draw the object's outline\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a RegionHighlightX object\nRegionHighlightY myReg = Draw.RegionHighlightY(this, \"tag1\", 10, 0, Brushes.Blue);\n \n// Change the object's opacity\nmyReg.AreaOpacity = 25;\n```"
  },
  {
    "_id": "beacd81372e6e86e60cd7c81f9612dd929239134520aa5d95d17c64f45e380d8",
    "_type": "desktopSdkDoc",
    "title": "RegressionChannel",
    "pathName": "regressionchannel",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Regression Channel **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* RegressionStroke\n\n* The **Stroke** object used to draw the middle line of the object\n\n---\n\n* LowerChannelStroke\n\n* The **Stroke** object used to draw the lower line of the object\n\n---\n\n* UpperChannelStroke\n\n* The **Stroke** object used to draw the upper line of the object\n\n---\n\n* PriceType\n\n* Possible values are:\n\n \t* **PriceType.Close**\n \n \t* **PriceType.High**\n \n \t* **PriceType.Low**\n \n \t* **PriceType.Median**\n \n \t* **PriceType.Open**\n \n \t* **PriceType.Typical**\n\n---\n\n* ChannelType\n\n* An enum value representing if the object will use standard deviations calculations for the upper/lower lines. Possible values are:\n\n* **RegressionChannelType.Segment**\n\n* **RegressionChannelType.StandardDeviation**\n\n---\n\n* ExtendLeft\n\n* A bool value representing if the object will extend to the left\n\n---\n\n* ExtendRight\n\n* A bool value representing if the object will extend to the right\n\n---\n\n* StandardDeviationLowerDistance\n\n* A double value representing the standard deviation distance to the lower line\n\n---\n\n* StandardDeviationUpperDistance\n\n* A double value representing the standard deviation distance to the upper line\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a RegressionChannel object\nNinjaTrader.NinjaScript.DrawingTools.RegressionChannel myRegChan = Draw.RegressionChannel(this, \"tag1\", 10, 0, Brushes.Blue);\n\n// Change the object's PriceType\nmyRegChan.PriceType = PriceType.Median;\n```\n\n{% callout type=\"note\" %}\n\nTo differentiate between **DrawingTools.RegressionChannel** and **Indicators.RegressionChannel** when assigning a RegressionChannel object, you will need to invoke the former path explicitly, as seen in the example above.\n\n{% /callout %}"
  },
  {
    "_id": "2509345a2b73cd58230101f5ff35dc0139110690e631a9f01e71a4af0eff87bd",
    "_type": "desktopSdkDoc",
    "title": "RemoveDrawObject()",
    "pathName": "removedrawobject",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRemoves a draw object from the chart based on its tag value.\n\n{% callout type=\"note\" %}\n\nThis method will ONLY remove DrawObjects which were created by a NinjaScript object. User drawn objects CANNOT be removed from via NinjaScript.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**RemoveDrawObject**(string tag)\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **tag**\n* A user defined unique id used to reference the draw object. For example, if you pass in a value of \"myTag\", each time this tag is used, the same draw object is modified. If unique tags are used each time, a new draw object will be created each time.\n{% /table %}\n\n## Examples\n\n```csharp\n// Removes a draw object with the tag \"tag1\"**\nRemoveDrawObject(\"tag1\");\n```"
  },
  {
    "_id": "f876e07770b6ddf2c0a003bef61f233bf978d1fd5a94ece30890e71edae8e505",
    "_type": "desktopSdkDoc",
    "title": "RemoveDrawObjects()",
    "pathName": "removedrawobjects",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRemoves all draw objects originating from the indicator or strategy from the chart.\n\n{% callout type=\"note\" %}\n\nThis method will ONLY remove DrawObjects which were created by a NinjaScript object. User drawn objects CANNOT be removed from via NinjaScript.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**RemoveDrawObjects()**\n\n## Examples\n\n```csharp\n// Removes all draw objects\nRemoveDrawObjects();\n```"
  },
  {
    "_id": "8a1906bc4dad70a136b7a26fff40b89187356df9e54ac94249af7a222ee99844",
    "_type": "desktopSdkDoc",
    "title": "RiskReward",
    "pathName": "riskreward",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Risk Reward **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* EntryAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the entry point of the drawing object\n\n---\n\n* RiskAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the stop loss point of the drawing object\n\n---\n\n* RewardAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the profit target point of the drawing object\n\n---\n\n* Ratio\n\n* An **int** value determining the calculated ratio between the risk or reward based on the entry point\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a RiskReward object\nRiskReward myRR = Draw.RiskReward(this, \"tag1\", false, 0, High[0], 10, Low[0], 2, true);\n\n// Change the object's risk/reward ratio to 2:1\nmyRR.Ratio = 2;\n```"
  },
  {
    "_id": "5972814068a183e232d67415ad8f2919f7633187a22f3f5dcf3d066515dbe556",
    "_type": "desktopSdkDoc",
    "title": "Ruler",
    "pathName": "ruler",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Ruler **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the end point of the drawing object\n\n---\n\n* TextAnchor\n\n* An **IDrawingTool's ChartAnchor** representing the text point of the drawing object\n\n---\n\n* TextColor\n\n* A **Brush** class representing the fill color of the draw object's text area\n\n---\n\n* LineColor\n\n* A **Stroke** object used to draw the object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Ruler object\nRuler myRuler = Draw.Ruler(this, \"tag1\", true, 4, Low[4], 3, High[3], 1, Low[1]);\n\n// Change the object's text color to white\nmyRuler.TextColor = Brushes.White;\n```"
  },
  {
    "_id": "4ba3e8e3765f2970eb37fae535353dd623d40a0507848c3c1dd240a5a7eb995e",
    "_type": "desktopSdkDoc",
    "title": "Square",
    "pathName": "square",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Square **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* Anchor\n\n* An **IDrawingTool's ChartAnchor** representing the point of the drawing object\n\n---\n\n* OutlineBrush\n\n* A **Brush** used for the outline of the square\n\n---\n\n* AreaBrush\n\n* A **Brush** object representing the fill color of the draw object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Square object\nSquare mySquare = Draw.Square(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);\n \n// Change the object's OutlineBrush\nmySquare.OutlineBrush = Brushes.Blue;\n```"
  },
  {
    "_id": "db49c0794f1828a7028d9000c5fb642239092b0b99e751682c8568b897fe0f76",
    "_type": "desktopSdkDoc",
    "title": "Draw.Text()",
    "pathName": "draw_text",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Text **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* Anchor\n\n* An **IDrawingTool's ChartAnchor** representing the point of the drawing object\n\n---\n\n* YPixelOffset\n\n* An **int** value representing the offset value in pixels from within the text box area\n\n---\n\n* Alignment\n\n* Possible values are:\n\n**TextAlignment.Center**,\n\n**TextAlignment.Left**,\n\n**TextAlignment.Right**,\n\n**TextAlignment.Justify** ([reference](https://msdn.microsoft.com/en-us/library/system.windows.textalignment(v=vs.110).aspx))\n\n---\n\n* AreaOpacity\n\n* An **int** value representing the opacity of the area color\n\n---\n\n* AreaBrush\n\n* A **Brush** class representing the fill color of the text box\n\n---\n\n* Text\n\n* A **string** value representing the text to be drawn\n\n---\n\n* TextBrush\n\n* A **Brush** class representing the color of the text\n\n---\n\n* Font\n\n* A **Font** object representing the font for the text\n\n---\n\n* OutlineStroke\n\n* The **Stroke** object used to outline the text box\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Text object\nText myText = Draw.Text(this, \"tag1\", \"Text to draw\", 10, High[10] + (5 * TickSize), Brushes.Black);\n\n// Change the object's DisplayText\nmyText.DisplayText = \"New Display Text\";\n```"
  },
  {
    "_id": "f8bbd2dec5009e1aa37a09a16d483ede2f6b1e60ecf54caae66229d8ded27b57",
    "_type": "desktopSdkDoc",
    "title": "TextFixed",
    "pathName": "textfixed",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Text Fixed **IDrawingTool**.\n\n## Methods and Properties\n\n{% table %}\n\n* Anchor\n* YPixelOffset\n* Alignment\n* AreaOpacity\n* AreaBrush\n* DisplayText\n* TextBrush\n* Font\n* OutlineStroke\n* TextPosition\n\n---\n\n* An **IDrawingTool's ChartAnchor** representing the point of the drawing object\n* An **int** value representing the offset value in pixels from within the text box area\n* Possible values are:\n  \n  **TextAlignment.Center**  \n  **TextAlignment.Far**  \n  **TextAlignment.Near**  \n  **TextAlignment.Justify**  \n  ([reference](https://msdn.microsoft.com/en-us/library/system.windows.textalignment%28v=vs.110%29.aspx))\n* An **int** value representing the opacity of the area color\n* A **Brush** class representing the fill color of the text box\n* A **string** value representing the text to be drawn\n* A **Brush** class representing the color of the text\n* A **Font** object representing the font for the text\n* The **Stroke** object used to outline the text box\n* Possible values are:\n  \n  **TextPosition.BottomLeft**  \n  **TextPosition.BottomRight**  \n  **TextPosition.Center**  \n  **TextPosition.TopLeft**  \n  **TextPosition.TopRight**\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a TextFixed object\nTextFixed myTF = Draw.TextFixed(this, \"tag1\", \"Text to draw\", TextPosition.TopRight);\n \n// Change the object's TextPosition\nmyTF.TextPosition = TextPosition.Center;\n```"
  },
  {
    "_id": "7df829fcdd542ec6562773701bbde8672042e21a6493308d92a60cb74738c22e",
    "_type": "desktopSdkDoc",
    "title": "TimeCycles",
    "pathName": "timecycles",
    "parent": "drawing",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a TimeCycles **IDrawingTool**.\n\n## Methods and Properties\n\n{%able %}\n\n* Anchor\n* OutlineStroke\n* AreaBrush\n\n---\n\n* An **IDrawingTool's ChartAnchor** representing the point of the drawing object\n* A Stroke used for the outline of the region\n* A **Brush** object representing the fill color of the draw object\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a Time Cycles object\nTimeCycles myTimeCycles = (this, \"tag1\", 0, 10, Brushes.CornflowerBlue, Brushes.CornflowerBlue, 40);\n\n// Change the object's OutlineBrush\nmyTimeCycles.OutlineStroke = new Stroke(Brushes.Red);\n```"
  },
  {
    "_id": "27f3282691613a41f159fe0fb8f3791f3b99fa00fc62df29edeeafe496eb0fdd",
    "_type": "desktopSdkDoc",
    "title": "Drawing",
    "pathName": "drawing",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "You can use **NinjaScript** to draw custom shapes, lines, text and colors on price and indicator panels from both [Indicators](indicators) and [Strategies](strategies).\n\n## Draw Methods and Associated Return Types\n\n{% table %}\n\n* Draw Method\n* Return Type\n\n---\n\n* [Draw.AndrewsPitchfork()](draw_andrewspitchfork)\n* [AndrewsPitchfork](andrewspitchfork)\n\n---\n\n* [Draw.Arc()](draw_arc)\n* [Arc](arc)\n\n---\n\n* [Draw.ArrowDown()](draw_arrowdown)\n* [ArrowDown](arrowdown)\n\n---\n\n* [Draw.ArrowLine()](draw_arrowline)\n* [ArrowLine](arrowline.md)\n\n---\n\n* [Draw.ArrowUp()](draw_arrowup)\n* [ArrowUp](arrowup)\n\n---\n\n* [Draw.Diamond()](draw_diamond)\n* [Diamond](diamond)\n\n---\n\n* [Draw.Dot()](draw_dot)\n* [Dot](dot)\n\n---\n\n* [Draw.Ellipse()](draw_ellipse)\n* [Ellipse](ellipse)\n\n---\n\n* [Draw.ExtendedLine()](draw_extendedline)\n* [ExtendedLine](extendedline)\n\n---\n\n* [Draw.FibonacciCircle()](draw_fibonaccicircle)\n* [FibonacciCircle](fibonaccicircle)\n\n---\n\n* [Draw.FibonacciExtensions()](draw_fibonacciextensions)\n* [FibonacciExtensions](fibonacciextensions)\n\n---\n\n* [Draw.FibonacciRetracements()](draw_fibonacciretracements)\n* [FibonacciRetracements](fibonacciretracements)\n\n---\n\n* [Draw.FibonacciTimeExtensions()](draw_fibonaccitimeextensions)\n* [FibonacciTimeExtensions](fibonaccitimeextensions)\n\n---\n\n* [Draw.GannFan()](draw_gannfan)\n* [GannFan](gannfan)\n\n---\n\n* [Draw.HorizontalLine()](draw_horizontalline)\n* [HorizontalLine](horizontalline)\n\n---\n\n* [Draw.Line()](draw_line)\n* [Line](line)\n\n---\n\n* [Draw.Pathtool()](draw_pathtool)\n* [Pathtool](pathtool)\n\n---\n\n* [Draw.Polygon()](draw_polygon)\n* [Polygon](polygon)\n\n---\n\n* [Draw.Ray()](draw_ray)\n* [Ray](ray)\n\n---\n\n* [Draw.Rectangle()](draw_rectangle)\n* [Rectangle](rectangle)\n\n---\n\n* [Draw.Region()](draw_region)\n* [Region](region)\n\n---\n\n* [Draw.RegionHighlightX()](draw_regionhighlightx)\n* [RegionHighlightX](regionhighlightx)\n\n---\n\n* [Draw.RegionHighlightY()](draw_regionhighlighty)\n* [RegionHighlightY](regionhighlighty)\n\n---\n\n* [Draw.RegressionChannel()](draw_regressionchannel)\n* [RegressionChannel](regressionchannel)\n\n---\n\n* [Draw.RiskReward()](draw_riskreward)\n* [RiskReward](riskreward)\n\n---\n\n* [Draw.Ruler()](draw_ruler)\n* [Ruler](ruler)\n\n---\n\n* [Draw.Square()](draw_square)\n* [Square](square)\n\n---\n\n* [Draw.Text()](draw_text)\n* [Text](text)\n\n---\n\n* [Draw.TextFixed()](draw_textfixed)\n* [TextFixed](textfixed)\n\n---\n\n* [Draw.TimeCycles()](draw_timecycles)\n* [TimeCycles](timecycles)\n\n---\n\n* [Draw.TrendChannel()](draw_trendchannel)\n* [TrendChannel](trendchannel.md)\n\n---\n\n* [Draw.Triangle()](draw_triangle)\n* [Triangle](triangle.md)\n\n---\n\n* [Draw.TriangleDown()](draw_triangledown)\n* [TriangleDown](triangledown.md)\n\n---\n\n* [Draw.TriangleUp()](draw_triangleup)\n* [TriangleUp](triangleup.md)\n\n---\n\n* [Draw.VerticalLine()](draw_verticalline)\n* [VerticalLine](verticalline.md)\n{% /table %}\n\n## Drawing Methods and Properties\n\n{% table %}\n\n* Property\n* Description\n\n---\n\n* [AllowRemovalOfDrawObjects](allowremovalofdrawobjects)\n* Determines if programmatically drawn DrawObjects can be manually removed from the chart\n\n---\n\n* [BackBrush](backbrush)\n* Sets the brush used for painting the chart panel's background color for the current bar\n\n---\n\n* [BackBrushAll](backbrushall)\n* Sets the brush used for painting the chart's background color for the current bar\n\n---\n\n* [BackBrushes](backbrushes)\n* A collection of historical brushes used for the background colors for the chart panel\n\n---\n\n* [BackBrushesAll](backbrushesall)\n* A collection of historical brushes used for the background colors for all chart panels\n\n---\n\n* [BarBrush](barbrush)\n* Sets the brush used for painting the color of a price bar's body\n\n---\n\n* [BarBrushes](barbrushes)\n* A collection of historical brushes used for painting the color of a price bar's body\n\n---\n\n* [Brushes](brushes)\n* A collection of static, predefined Brushes supplied by the .NET Framework\n\n---\n\n* [CandleOutlineBrush](candleoutlinebrush)\n* Sets the outline Brush of a candlestick\n\n---\n\n* [CandleOutlineBrushes](candleoutlinebrushes)\n* A collection of historical outline brushes for candlesticks\n\n---\n\n* [DrawObjects](drawingtools_drawobjects)\n* A collection holding all of the drawn chart objects for the primary bar series\n\n---\n\n* [IDrawingTool](idrawingtool)\n* Represents an interface that exposes information regarding a drawn chart object\n\n---\n\n* [RemoveDrawObject()](removedrawobject)\n* Removes a draw object from the chart based on its tag value\n\n---\n\n* [RemoveDrawObjects()](removedrawobjects)\n* Removes all draw objects originating from the indicator or strategy from the chart\n\n---\n\n* [SimpleFont Class](simplefont_class)\n* Defines a particular font configuration\n{% /table %}\n\n1. Custom graphics for custom indicators can be painted on either the price panel or indicator panel. You could for example have a custom indicator displayed in an indicator panel yet have associated custom graphics painted on the price panel. The \"**DrawOnPricePanel**\" property is set to true by default, which means that custom graphics will always be painted on the price panel, even if the indicator is plotted in a separate panel. If you want your custom graphics to be plotted on the indicator panel, set this property to false in the **OnStateChange()** method of your custom indicator.\n2. Set unique tag values for each draw object, unless you intend for new draw objects to replace existing objects with the same tag. A common trick is to incorporate the bar number as part of the unique tag identifier. For example, if you wanted to draw a dot that indicated a buying condition above a bar, you could express it:\n**Draw.Dot(this, CurrentBar.ToString() + \"Buy\", false, 0, High[0] + TickSize, Brushes.ForestGreen);**\n3. Draw methods will not work if they are called from the **OnStateChange()** method."
  },
  {
    "_id": "0132c7fa2f258bedb27a1e233705befc023a89e19cdc7bb86108a755b64ebbec",
    "_type": "desktopSdkDoc",
    "title": "System Indicator Methods",
    "pathName": "system_indicator_methods",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "The \"Indicators\" reference provides definitions, syntax, parameter definitions and examples for **NinjaTrader** system indicator methods.\n\n* [Valid Input Data for Indicator Methods](valid_input_data_for_indicator)\n* [Accumulation/Distribution (ADL)](accumulation_distribution_adl)\n* [Adaptive Price Zone (APZ)](adaptive_price_zone_apz)\n* [Aroon](aroon)\n* [Aroon Oscillator](aroon_oscillator)\n* [Average Directional Index (ADX)](average_directional_index_adx)\n* [Average Directional Movement Rating (ADXR)](average_directional_movement_r)\n* [Average True Range (ATR)](average_true_range_atr)\n* [Balance of Power (BOP)](balance_of_power_bop)\n* [Block Volume](block_volume)\n* [Bollinger Bands](bollinger_bands)\n* [BuySell Pressure](buysellpressure)\n* [BuySell Volume](buysellvolume)\n* [Camarilla Pivots](camarilla_pivots)\n* [CandleStickPattern](candlestickpattern)\n* [Chaikin Money Flow](chaikin_money_flow)\n* [Chaikin Oscillator](chaikin_oscillator)\n* [Chaikin Volatility](chaikin_volatility)\n* [Chande Momentum Oscillator (CMO)](chande_momentum_oscillator_cmo)\n* [Choppiness Index](choppiness_index)\n* [Commodity Channel Index (CCI)](commodity_channel_index_cci)\n* [Correlation](correlation)\n* [Current Day OHL](current_day_ohl)\n* [Darvas](darvas)\n* [Directional Movement (DM)](directional_movement_dm)\n* [Directional Movement Index (DMI)](directional_movement_index_dmi)\n* [Disparity Index](disparity_index)\n* [Donchian Channel](donchian_channel)\n* [Double Stochastics](double_stochastics)\n* [Dynamic Momentum Index (DMIndex)](dynamic_momentum_index_dmindex)\n* [Ease of Movement](ease_of_movement)\n* [Fibonacci Pivots](fibonacci_pivots)\n* [Fisher Transform](fisher_transform)\n* [Forecast Oscillator (FOSC)](forecast_oscillator_fosc)\n* [Keltner Channel](keltner_channel)\n* [KeyReversalDown](keyreversaldown)\n* [KeyReversalUp](keyreversalup)\n* [Linear Regression](linear_regression)\n* [Linear Regression Intercept](linear_regression_intercept)\n* [Linear Regression Slope](linear_regression_slope)\n* [MA Envelopes](maenvelopes)\n* [Maximum (MAX)](maximum_max)\n* [Minimum (MIN)](minimum_min)\n* [Momentum](momentum)\n* [Money Flow Index (MFI)](money_flow_index_mfi)\n* [Moving Average - Double Exponential (DEMA)](moving_average_-_double_expone)\n* [Moving Average - Exponential (EMA)](moving_average_-_exponential_e)\n* [Moving Average - Hull (HMA)](moving_average_-_hull_hma)\n* [Moving Average - Kaufman's Adaptive (KAMA)](moving_average_-_kaufmans_adap)\n* [Moving Average - Mesa Adaptive (MAMA)](moving_average_-_mesa_adaptive)\n* [Moving Average - Simple (SMA)](moving_average_-_simple_sma)\n* [Moving Average - T3 (T3)](moving_average_-_t3_t3)\n* [Moving Average - Triangular (TMA)](moving_average_-_triangular_tm)\n* [Moving Average - Triple Exponential (TEMA)](moving_average_-_triple_expone)\n* [Moving Average - Triple Exponential (TRIX)](moving_average_-_triple_expon2)\n* [Moving Average - Variable (VMA)](moving_average_-_variable_vma)\n* [Moving Average - Volume Weighted (VWMA)](moving_average_-_volume_weight)\n* [Moving Average - Weighted (WMA)](moving_average_-_weighted_wma)\n* [Moving Average - Zero Lag Exponential (ZLEMA)](moving_average_-_zero_lag_expo)\n* [Moving Average Convergence-Divergence (MACD)](moving_average_convergence-divergence_macd)\n* [Moving Average Ribbon](moving_average_ribbon)\n* [Net Change Display](net_change_display)\n* [n Bars Down](n_bars_down)\n* [n Bars Up](n_bars_up)\n* [On Balance Volume (OBV)](on_balance_volume_obv)\n* [Order Flow Cumulative Delta](order_flow_cumulative_delta2)\n* [Order Flow Volumetric Bars](order_flow_volumetric_bars2)\n* [Order Flow VWAP](order_flow_vwap2)\n* [Parabolic SAR](parabolic_sar)\n* [Percentage Price Oscillator (PPO)](percentage_price_oscillator_pp)\n* [Pivots](pivots)\n* [Polarized Fractal Efficiency (PFE)](polarized_fractal_efficiency_p)\n* [Price Oscillator](price_oscillator)\n* [Prior Day OHLC](prior_day_ohlc)\n* [Psychological Line](psychological_line)\n* [Range](range)\n* [Range Indicator (RIND)](range_indicator_rind)\n* [Rate of Change (ROC)](rate_of_change_roc)\n* [Regression Channel](regression_channel)\n* [Relative Spread Strength (RSS)](relative_spread_strength_rss)\n* [Relative Strength Index (RSI)](relative_strength_index_rsi)\n* [Relative Vigor Index](relative_vigor_index)\n* [Relative Volatility Index (RVI)](relative_volatility_index_rvi)\n* [R-squared](r_squared)\n* [Standard Deviation (StdDev)](standard_deviation_stddev)\n* [Standard Error (StdError)](standard_error_stderror)\n* [Stochastics](stochastics)\n* [Stochastics Fast](stochastics_fast)\n* [Stochastics RSI (StochRSI)](stochastics_rsi_stochrsi)\n* [Summation (SUM)](summation_sum)\n* [Swing](swing)\n* [Time Series Forecast (TSF)](time_series_forecast_tsf)\n* [Trend Lines](trend-lines)\n* [True Strength Index (TSI)](true_strength_index_tsi.md)\n* [Ultimate Oscillator](ultimate_oscillator.md)\n* [Volume (VOL)](volume.md)\n* [Volume Moving Average (VOLMA)](volume_moving_average_volma.md)\n* [Volume Oscillator](volume_oscillator.md)\n* [Volume Rate of Change (VROC)](volume_rate_of_change_vroc.md)\n* [Volume Up Down](volume_up_down.md)\n* [Vortex](vortex)\n* [Williams %R](williams_r.md)\n* [Wiseman Alligator](wiseman_alligator)\n* [Wiseman Awesom Oscillator](wiseman_awesome_oscillator)\n* [Woodies CCI](woodies_cci.md)\n* [Woodies Pivots](woodies_pivots.md)\n* [ZigZag](zigzag.md)"
  },
  {
    "_id": "ab27b729d9cc4cb1c00960700446924159e9298d0f952aee3d55408b8e0b1b71",
    "_type": "desktopSdkDoc",
    "title": "Exchange",
    "pathName": "exchange",
    "parent": "instrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the current exchange of an instrument\n\n## Property Value\n\nRepresents the exchange which is selected for the current instrument.\n\n## Syntax\n\n**Instrument.Exchange**\n\n## Examples\n\n```csharp\n\nprotected override void OnBarUpdate()\n{\n    // Print the exchange of the currently configured instrument\n    Print(String.Format(\"Configured instrument is on the {0} exchange\", Instrument.Exchange));\n}\n\n```\n\n## Additional Access Information\n\nThis property can be accessed without a null reference check in the **OnBarUpdate()** event handler. When the **OnBarUpdate()** event is triggered, there will always be an **Instrument** object. Should you wish to access this property elsewhere, check for null reference first. e.g. if (**Instrument** != null)"
  },
  {
    "_id": "c955506fc1ccc8df3d686e53ba359c25653dc80e3459d4a7373a02ffbbf182e5",
    "_type": "desktopSdkDoc",
    "title": "Expiry",
    "pathName": "expiry",
    "parent": "instrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the expiration month of a futures contract.\n\n## Property Value\n\nA **DateTime** structure representing the expiration month of a futures contract.\n\n## Syntax\n\n**Instrument.Expiry**\n\n## Examples\n\n```csharp\n\nprotected override void OnBarUpdate()\n{\n   // Print the expiry of the currently configured futures instrument\n   Print(String.Format(\"You are viewing the {0} contract\", Instrument.Expiry));\n}\n```\n\n## Additional Access Information\n\nThis property can be accessed without a null reference check in the **OnBarUpdate()** event handler. When the **OnBarUpdate()** event is triggered, there will always be an **Instrument** object. Should you wish to access this property elsewhere, check for null reference first. e.g. if (**Instrument** != null)"
  },
  {
    "_id": "6a0589a6eeaea1c6e3b87f30bb518cb7dedd6b261d02c730e2588b6ee94355af",
    "_type": "desktopSdkDoc",
    "title": "GetInstrument()",
    "pathName": "getinstrument",
    "parent": "instrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns an **Instrument** object by the master instrument name configured in the database.\n\n{% callout type=\"note\" %}\n\nThis method does NOT add additional data for real-time or historical processing. For adding additional data to your script, please see the **AddDataSeries()** method.\n\n{% /callout %}\n\n## Method Return Value\n\nAn **Instrument** object\n\n## Syntax\n\n**Instrument.GetInstrument(string instrumentName)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **instrumentName**\n* A **string** value representing a name of an instrument\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Historical)\n    {\n        Instrument myInstrument = Instrument.GetInstrument(\"AAPL\");\n\n        Print(\"AAPL's tick size is \" + myInstrument.MasterInstrument.TickSize.ToString());\n    }\n}\n```"
  },
  {
    "_id": "7244b466327ec6f5f8be71a92f31dbddd8ce41f344ce3b1754fa10cbc326f218",
    "_type": "desktopSdkDoc",
    "title": "FullName",
    "pathName": "fullname",
    "parent": "instrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the full NinjaTrader name of an instrument. For futures, this would include the expiration date. The September S&P 500 Emini contract full name is \"ES 09-16\".\n\n## Property Value\n\nA string representing the full name of the instrument.\n\n## Syntax\n\n**Instrument.FullName**\n\n## Examples\n\n```csharp\n\nprotected override void OnBarUpdate()\n{\n   // Print the full name (including contract month) of the configured instrument\n   Print(String.Format(\"{0} is being used as the input series\", Instrument.FullName));\n}\n```\n\n## Additional Access Information\n\nThis property can be accessed without a null reference check in the **OnBarUpdate()** event handler. When the **OnBarUpdate()** event is triggered, there will always be an **Instrument** object. Should you wish to access this property elsewhere, check for null reference first. e.g. if (**Instrument** != null)"
  },
  {
    "_id": "55ee5d5d25dcdd51f2f827aeb737dce3bc478a5d7d4473d63995220d5efa0944",
    "_type": "desktopSdkDoc",
    "title": "RoundDownToTickSize()",
    "pathName": "rounddowntoticksize",
    "parent": "instrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a value that is rounded down to the nearest valid value evenly divisible by the instrument's tick size.\n\n## Method Return Value\n\nA **double** value.\n\n## Syntax\n\n**Instrument.MasterInstrument.RoundDownToTickSize(double price)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **price**\n* A **double** value representing a price\n{% /table %}\n\n## Examples\n\n```csharp\n//Takes the last 3 closes, divides them by 3, and rounds the value down to the nearest valid tick size**\nValue[0] = Instrument.MasterInstrument.RoundDownToTickSize((Close[0] + Close[1] + Close[2]) / 3);\n```"
  },
  {
    "_id": "c53e21e795fb1794a3e4740265fd23eb5ebb2ab16068cc17ac297bd24abd0fd9",
    "_type": "desktopSdkDoc",
    "title": "RoundToTickSize()",
    "pathName": "roundtoticksize",
    "parent": "instrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a value that is rounded up to the nearest valid value evenly divisible by the instrument's tick size.\n\n## Method Return Value\n\nA **double** value.\n\n## Syntax\n\n**Instrument.MasterInstrument.RoundToTickSize(double price)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **price**\n* A **double** value representing a price\n{% /table %}\n\n## Examples\n\n```csharp\n//Takes the last 3 closes, divides them by 3, and rounds the value up to the nearest valid tick size\nValue[0] = Instrument.MasterInstrument.RoundToTickSize((Close[0] + Close[1] + Close[2]) / 3);\n```"
  },
  {
    "_id": "d3e43f83d066d0cc621c971c101d990224e9a9e387b6cd47e8eea834192129aa",
    "_type": "desktopSdkDoc",
    "title": "Instrument",
    "pathName": "instrument",
    "parent": "instruments",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA tradable symbol. Represents an instance of a **Master Instrument**.\n\n{% callout type=\"note\" %}\n\nWarning: The properties in this class should NOT be accessed within the **OnStateChange()** method before the State has reached State.DataLoaded.\n\n{% /callout %}\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [Exchange](exchange)\n* Exchange of the current instrument\n\n---\n\n* [Expiry](expiry)\n* Expiration date of the futures contract\n\n---\n\n* [FullName](instrument_fullname)\n* Full name of the instrument\n\n---\n\n* [GetInstrument()](getinstrument)\n* Returns an Instrument object by the master instrument name configured in the database.\n\n---\n\n* [MasterInstrument](masterinstrument)\n* An instrument's configuration settings. These are settings and properties which are defined in the **Instrument** window.\n\n---\n\n* FundamentalData\n* Instrument thread specific **FundamentalData** events\n\n---\n\n* MarketData\n* Instrument thread specific **MarketData** events\n\n---\n\n* MarketDepth\n* Instrument thread specific **MarketDepth** events\n\n---\n\n* Dispatcher\n* A Dispatcher used for subscribing to Instrument related events. See **Multi-Threading Considerations**.\n{% /table %}"
  },
  {
    "_id": "1241626eb8ca542931d74f9ac0f6b294e791ff041ab106789b514331e74c9830",
    "_type": "desktopSdkDoc",
    "title": "Compare()",
    "pathName": "compare",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nCompares two price values with respect to the Instrument **TickSize** to ensure accuracy when dealing with floating point math.\n\n## Method Return Value\n\nAn **int** value.\n\n* A value of \"1\" is returned if price1 is greater than price2.\n* A value of \"-1\" is returned if price1 is less than price2.\n* A value of \"0\" if price1 is equal to price2.\n\n## Syntax\n\n**Instrument.MasterInstrument.Compare(double price1, double price2)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* price1\n* A **double** value representing a price.\n\n---\n\n* price2\n* A **double** value representing a price.\n{% /table %}\n\n## Examples\n\n```csharp\ndouble newPrice = Close[0] + High[0] + Open[0];\nif (Instrument.MasterInstrument.Compare(newPrice, Close[1]) == 1)\n     // Do something since price1 is greater than price2\n\n```"
  },
  {
    "_id": "f4b4e11fd32b8ad59b6eee5fae6fe22ffdc1c3d9ea30ccd7708d9166ba216940",
    "_type": "desktopSdkDoc",
    "title": "Dividends",
    "pathName": "dividends",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn collection of Dividends configured for the **Master Instrument properties** used in for stocks.\n\n## Property Value\n\nA collection of Dividends configured for the current instrument.\n\nPossible values are:\n\n{% table %}\n\n* Amount\n* Date\n\n---\n\n* A **double** value representing the amount in dollars which was paid on the date of the dividend\n* A DateTime structure representing the date of the dividend\n{% /table %}\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.Dividends**\n\n## Examples\n\n```csharp\nforeach(Dividend dividends in Bars.Instrument.MasterInstrument.Dividends)\n{\n   Print(dividends.Amount);\n   Print(dividends.Date);\n}\n```"
  },
  {
    "_id": "25bc5635d0949775306dd16e4d7b06f3c7185bd7b5c251b2986679a5e166df4b",
    "_type": "desktopSdkDoc",
    "title": "Exchanges",
    "pathName": "exchanges",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of exchange(s) configured for the **Master Instrument properties**.\n\n## Property Value\n\nA collection of Exchanges which represent the exchanges configured for the current instrument.\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.Exchanges**\n\n## Examples\n\n```csharp\nforeach(Exchange exchange in Bars.Instrument.MasterInstrument.Exchanges)\n{\n Print(exchange); // Default, Nasdaq, NYSE\n}\n```"
  },
  {
    "_id": "9692f90c41e06821e3ae25a545d1e37deeddee3bc53ddba91ef21edbb9f36a7f",
    "_type": "desktopSdkDoc",
    "title": "FormatPrice()",
    "pathName": "formatprice",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns a price value as a string which will be formatted to the nearest tick size.\n\n{% callout type=\"note\" %}\n\nThis is useful as the standard format specifier will only use the minimum number of digits for a decimal by default; however you can use this method to ensure that your data is always formatted per the instrument tick size for easier readability. For example, a value of 1985.50 would Print() as 1985.5, while using **FormatPrice()**, we can expect the value to be formatted as 1985.50.\n\n{% /callout %}\n\n## Property Value\n\nA **string** value which will ensure the price data is always formatted to the nearest tick size.\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.FormatPrice(double price, [bool round])**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **price**\n* A **double** value representing a price\n\n---\n\n* **round**\n* An optional bool when true (default) will round the price value to the nearest tick size\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // called without setting the optional bool parameter, which is defaulted to true then\n   Print(Bars.Instrument.MasterInstrument.FormatPrice(Close[0]));\n}\n\nprotected override void OnMarketData(MarketDataEventArgs marketDataUpdate)\n{\n   Print(marketDataUpdate.Instrument.MasterInstrument.FormatPrice(marketDataUpdate.Price));\n```"
  },
  {
    "_id": "4fe0455549f163432f4b338f09ee52435f06dc55aee0bfc5fb495c5eacae3aca",
    "_type": "desktopSdkDoc",
    "title": "GetNextExpiry()",
    "pathName": "getnextexpiry",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the current futures expiry compared to the time of the input value used for the method.\n\n## Method Return Value\n\nA **DateTime** structure\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.GetNextExpiry(DateTime afterDate)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **afterDate**\n* A **DateTime** value representing to be compared\n{% /table %}\n\n## Examples\n\n```csharp\n// Indicates what the current expiry is in the bottom right of the chart\nDraw.TextFixed(this, \"tag1\", \"The current expiry is \" + Bars.Instrument.MasterInstrument.GetNextExpiry(DateTime.Now).ToString(\"MM-yy\"), TextPosition.BottomRight);\n```"
  },
  {
    "_id": "68bee3a3bb454b2c36f6ad63241d04638a2680fd096b50bdc928ea3917ef3dc4",
    "_type": "desktopSdkDoc",
    "title": "InstrumentType",
    "pathName": "instrumenttype",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the type of instrument.\n\n## Property Value\n\nAn **InstrumentType** representing the type of an instrument.\n\nPossible values are:\n\n* **InstrumentType.Future**\n* **InstrumentType.Stock**\n* **InstrumentType.Index**\n* **InstrumentType.Forex**\n* **InstrumentType.Cfd**\n* **InstrumentType.Cryptocurrency**\n\n## Syntax\n\n**Instrument.MasterInstrument.InstrumentType**\n\n## Examples\n\n```csharp\nif (Instrument.MasterInstrument.InstrumentType == InstrumentType.Future)\n{\n // Do something\n}\nelse\n{\n // Do something else\n}\n```\n\n## Additional Access Information\n\nThis property can be accessed without a null reference check in the **OnBarUpdate()** event handler. When the **OnBarUpdate()** event is triggered, there will always be an **Instrument** object. Should you wish to access this property elsewhere, check for null reference first. e.g. if (**Instrument** != null)"
  },
  {
    "_id": "466e5b9cd57fa444cceaa8e5b053ddd58d05cbbcf162a54d6ccd08492ef36dfd",
    "_type": "desktopSdkDoc",
    "title": "Currency",
    "pathName": "currency",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the currency configured for the **Master Instrument properties**.\n\n## Property Value\n\nA type of Currency which is configured for the current master instrument.\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.Currency**\n\n## Examples\n\n```csharp\nif (Bars.Instrument.MasterInstrument.Currency != Currency.UsDollar)\n{\n    //Prints if the currency is not UsDollar and indicates what currency it is\n    Print (\"Warning: Instruments base currency is not UsDollar, it is \" + Bars.Instrument.MasterInstrument.Currency);\n}\n```"
  },
  {
    "_id": "c9046f7a37ad0ea7cee73355984fa5428982f8b37c8f7bcec91f7ac71a7cd104",
    "_type": "desktopSdkDoc",
    "title": "Description",
    "pathName": "description",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the description configured for the **Master Instrument properties**.\n\n## Property Value\n\nA **string** value which is configured for the current master instrument.\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.Description**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Displays the master instrument's description at the bottom right of the chart\n    Draw.TextFixed(this, \"tag1\", Bars.Instrument.MasterInstrument.Description, TextPosition.BottomRight);\n}\n```"
  },
  {
    "_id": "cf77067e385c34391a9d70c493ea0ff320889a2548ee49707c2f3f635c1a7d13",
    "_type": "desktopSdkDoc",
    "title": "Name",
    "pathName": "masterinstrument",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the NinjaTrader database name of an instrument. For example, \"MSFT\", \"ES\", \"NQ\" etc...\n\n## Property Value\n\nA string representing the name of the instrument.\n\n## Syntax\n\n**Instrument.MasterInstrument.Name**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Displays the master instrument's name at the bottom right of the chart**\n    Draw.TextFixed(this, \"tag1\", Bars.Instrument.MasterInstrument.Name, TextPosition.BottomRight);\n}\n```\n\n## Additional Access Information\n\nThis property can be accessed without a null reference check in the **OnBarUpdate()** event handler. When the **OnBarUpdate()** event is triggered, there will always be an **Instrument** object. Should you wish to access this property elsewhere, check for null reference first. e.g. **if (Instrument != null)**"
  },
  {
    "_id": "4d3c1be0b4f2fa41aa176eb5c2ba129f148fcbf5eed9f5624bd818ad486a318d",
    "_type": "desktopSdkDoc",
    "title": "TickSize",
    "pathName": "ticksize",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the tick size configured for the **Master Instrument properties**.\n\n## Property Value\n\nA **double** value representing the tick size configured for the current master instrument.\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.TickSize**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Displays the master instrument's tick size at the bottom right of the chart\n    Draw.TextFixed(this, \"tag1\", Bars.Instrument.MasterInstrument.TickSize.ToString(), TextPosition.BottomRight);\n\n}\n```"
  },
  {
    "_id": "51213853e78fedf29d07da4a1ac6bba92f6c2efa265ac9fd2d5db0eaaf2018ba",
    "_type": "desktopSdkDoc",
    "title": "MergePolicy",
    "pathName": "mergepolicy",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the Merge Policy configured for the **Master Instrument properties**.\n\n## Property Value\n\nRepresents the MergePolicy that is configured for the current master instrument.\n\nPossible values are:\n\n{% table %}\n\n* Value\n* Description\n\n---\n\n* **DoNotMerge**\n* No merge policy is applied\n\n---\n\n* **MergeBackAdjusted**\n* Merge policy is applied between contracts along with rollover offsets\n\n---\n\n* **MergeNonBackAdjusted**\n* Merge policy is applied between contracts without offsets\n\n---\n\n* **UseGlobalSettings**\n* Uses the value configured from Tools -> Options -> Market Data\n{% /table %}\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.MergePolicy**\n\n## Examples\n\n```csharp\n//Prints a warning, indicating what merge policy is in use if not using global settings**\nif (Bars.Instrument.MasterInstrument.MergePolicy != MergePolicy.UseGlobalSettings)\n{\n Print(\"Warning: Instrument has merge policy of \" + Bars.Instrument.MasterInstrument.MergePolicy);\n}\n```"
  },
  {
    "_id": "83333c879c15822e8b4a880332ccbfd38e396da8da850ef9c30d0c623659f8df",
    "_type": "desktopSdkDoc",
    "title": "PointValue",
    "pathName": "pointvalue",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the currency value of 1 full point of movement. For example, 1 point in the **S&P 500 Emini** futures contract (ES) is $50 USD which is equal to $12.50 USD per tick.\n\n## Property Value\n\nA **double** value representing the currency value of 1 point of movement.\n\n## Syntax\n\n**Instrument.MasterInstrument.PointValue**\n\n## Examples\n\n```csharp\n// protected override void OnBarUpdate()\n{\n    // Displays the master instrument's point value at the bottom right of the chart\n    Draw.TextFixed(this, \"Point value: \", Bars.Instrument.MasterInstrument.PointValue.ToString(), TextPosition.BottomRight);\n}\n```\n\n## Additional Access Information\n\nThis property can be accessed without a null reference check in the **OnBarUpdate()** event handler. When the **OnBarUpdate()** event is triggered, there will always be an **Instrument** object. Should you wish to access this property elsewhere, check for null reference first. e.g. if (**Instrument** != null)"
  },
  {
    "_id": "774e38f721b88b14dd1198b01c362451aa9179dc7afc73666cdd49eaf32510b2",
    "_type": "desktopSdkDoc",
    "title": "RolloverCollection",
    "pathName": "rollovercollection",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the rollovers that have been configured for the **Master Instrument properties** used in for futures.\n\n## Property Value\n\nA **RolloversCollection** configured for the current instrument.\n\nPossible values are:\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* ContractMonth\n\n* A DateTime structure representing the expiry month of a futures contract\n\n---\n\n* Date\n\n* A DateTime structure representing the date of the rollover\n\n---\n\n* Offset\n\n* A double value representing the number of points between contracts\n\n---\n\n{% /table %}\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.RolloverCollection**\n\n## Examples\n\n```csharp\nforeach(var rollover in Bars.Instrument.MasterInstrument.RolloverCollection)\n{\n     Print(rollover.ContractMonth);\n     Print(rollover.Date);\n     Print(rollover.Offset);\n}\n```"
  },
  {
    "_id": "6e83555522ef6908d810dcc89278eb84df36e2c4fae58b0c8357720f2be83848",
    "_type": "desktopSdkDoc",
    "title": "Splits",
    "pathName": "splits",
    "parent": "masterinstrument",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the Splits that have been configured for the **Master Instrument properties** used in for stocks.\n\n## Property Value\n\nA collection of Splits configured for the current instrument.\n\nPossible values are:\n\n{% table %}\n\n* Date\n* Factor\n\n---\n\n* A DateTime structure representing the date of the split\n* A **double** value representing the number of points the stock split\n{% /table %}\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.Splits**\n\n## Examples\n\n```csharp\n foreach (Split split in Bars.Instrument.MasterInstrument.Splits)\n{\n     Print(split.Date);\n     Print(split.Factor);\n}\n```"
  },
  {
    "_id": "cf77067e385c34391a9d70c493ea0ff320889a2548ee49707c2f3f635c1a7d13",
    "_type": "desktopSdkDoc",
    "title": "MasterInstrument",
    "pathName": "masterinstrument",
    "parent": "instruments",
    "order": 5,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn instrument's configuration settings. These are settings and properties which are defined in the **Instrument** window.\n\n{% callout type=\"warning\" %}\nWarning: The properties in this class should NOT be accessed within the **OnStateChange()** method before the State has reached State.DataLoaded.\n{% /callout %}\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [Compare()](compare)\n* Returns An **int** value compares two price values with respect to the Instrument tick size\n\n---\n\n* [Currency](currency)\n* The currency that the instrument traded in\n\n---\n\n* [Description](masterinstrument_description)\n* A written representation of a given instrument\n\n---\n\n* [Dividends](dividends)\n* A collection of dividends for stock instruments\n\n---\n\n* [Exchanges](exchanges)\n* A collection of exchanges configured for an instrument\n\n---\n\n* [FormatPrice()](formatprice)\n* Returns a string representing the price formatted to the nearest tick size\n\n---\n\n* [InstrumentType](instrumenttype)\n* The type of instrument\n\n---\n\n* [MergePolicy](mergepolicy)\n* The Merge Policy that is configured for the current master instrument.\n\n---\n\n* [Name](masterinstrument_name)\n* The name of the instrument.\n\n---\n\n* [GetNextExpiry()](getnextexpiry)\n* Returns a DateTime structure representing the next futures expiry for a given date\n\n---\n\n* [PointValue](pointvalue)\n* Currency value of 1 full point of movement\n\n---\n\n* [RolloverCollection](rollovercollection)\n* A collection of expiration dates and offsets for futures instruments\n\n---\n\n* [RoundToTickSize()](roundtoticksize)\n* Rounds the value up to the nearest valid value\n\n---\n\n* [RoundDownToTickSize()](rounddowntoticksize)\n* Rounds the value down to the nearest valid value\n\n---\n\n* [Splits](splits)\n* A collection of splits for stock instruments\n\n---\n\n* [TickSize](ticksize)\n* The smallest movement in price configured\n\n---\n\n* [Url](url.md)\n* A web url where contract details have been collected\n{% /table %}"
  },
  {
    "_id": "17603f34a1ce99cae9e306b8ce28a0849046de02c695242352560c451029d93b",
    "_type": "desktopSdkDoc",
    "title": "Instruments",
    "pathName": "instruments",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of **Instrument** objects currently used by a script.\n\n## Property Value\n\nAn array of **Instrument** objects\n\n## Syntax\n\n**Instruments[]**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.DataLoaded)\n   {\n       // Print all instruments which have been loaded\n       foreach (Instrument i in Instruments)\n       {\n           Print(i.FullName);\n       }\n   }\n}\n```"
  },
  {
    "_id": "310ff200149b44a32f124023d7caba19a1a890763a980606813d3a3d4a085d36",
    "_type": "desktopSdkDoc",
    "title": "Close",
    "pathName": "close",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical bar close prices.\n\n## Property Value\n\nA **ISeries`<double>`** type object. Accessing this property via an index value **int barsAgo** returns A **double** value representing the price of the referenced bar.\n\n{% callout type=\"note\" %}\n\nWhen an indicator uses another indicator as input series, Close will represent the closing price of the input series' input series. For example, if MyCustomIndicator uses an ADX as input series, then referencing **Close[0]** in MyCustomIndicator will provide the Close price for the ADX's input series.\n\n{% /callout %}\n\n## Syntax\n\n**Close**  \n\n**Close[int barsAgo]**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     // Evaluates if the current close is greater than the prior bar close\n     if (Close[0] > Close[1])\n         Print(\"We had an up day\");\n}\n```"
  },
  {
    "_id": "b2850942ea43f30e0a572605d8fe5f83046a7fcedf27a271dd3916c13a3c4239",
    "_type": "desktopSdkDoc",
    "title": "Closes",
    "pathName": "closes",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries`<double>`** objects holding historical bar close prices. A **ISeries`<double>`** object is added to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the closing prices of all **Bars** objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of **ISeries`<double>`** objects.\n\n## Syntax\n\n**Closes[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Adds a 5-minute Bars object to the strategy and is automatically assigned\n         // a Bars object index of 1 since the primary data the strategy is run against\n         // set by the UI takes the index of 0.\n         AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);\n     }\n}\n\nprotected override void OnBarUpdate()\n{\n     // Compares the primary bar's close price to the 5-minute bar's close price\n     if (Closes[0][0] > Closes[1][0])\n         Print(\"The primary bar's close price is greater\");\n}\n```"
  },
  {
    "_id": "6ef7c9b15ecdd69083724b84cfdc2100351963488b51b4ea2fcbddf493fbec94",
    "_type": "desktopSdkDoc",
    "title": "High",
    "pathName": "high",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical bar high prices.\n\n## Property Value\n\nAn **ISeries`<double>`** type object. Accessing this property via an index value **int barsAgo** returns A **double** value representing the price of the referenced bar.\n\n## Syntax\n\n**High**  \n\n**High[int barsAgo]**\n\n## Examples\n\n```csharp\n// OnBarUpdate method\nprotected override void OnBarUpdate()\n{\n     // Make sure we have at least 20 bars\n     if (CurrentBar < 20)\n         return;\n\n     // Evaluates for higher highs\n     if (High[0] > High[1] && High[1] > High[2])\n         Print(\"Two successive higher highs\");\n\n     // Gets the current value of a 20 period SMA of high prices\n     double value = SMA(High, 20)[0];\n     Print(\"The value is \" + value.ToString());\n}\n```\n\n\\"
  },
  {
    "_id": "1351bfd83437f2e19df06f33f204d6694cd99a1a87f7ddc5a222a7b08acbe441",
    "_type": "desktopSdkDoc",
    "title": "Highs",
    "pathName": "highs",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries`<double>`** objects holding historical bar high prices. A **ISeries`<double>`** object is added to this array when calling the [AddDataSeries()](/adddataseries) method. Its purpose is to provide access to the high prices of all Bars objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of **ISeries`<double>`** objects.\n\n## Syntax\n\n**Highs[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Adds a 5-minute Bars object to the strategy and is automatically assigned\n         // a Bars object index of 1 since the primary data the strategy is run against\n         // set by the UI takes the index of 0.\n         AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);\n     }\n}\n\nprotected override void OnBarUpdate()\n{\n     // Compares the primary bar's high price to the 5-minute bar's high price\n     if (Highs[0][0] > Highs[1][0])\n         Print(\"The primary bar's high price is greater\");\n}\n```"
  },
  {
    "_id": "c96c6d5be8d08a12e7b5cdc1b207fa6b2430974c86803d8891675e76fd992c20",
    "_type": "desktopSdkDoc",
    "title": "Input",
    "pathName": "input",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe main historical data input. If implemented in the **NinjaScript** object, it allows for more flexibility as non bars based series such as plot series could be passed in and drive the calculation outcomes - an example would be a custom moving average that should have the ability to operate on another moving average (i.e. the **SMA**) as input series.\n\n## Property Value\n\nAn **ISeries`<double>`** type object that implements the **Series<`double`>** interface. Accessing this property via an index value **int barsAgo** returns A **double** value representing the price of the referenced bar.\n\n## Syntax\n\n**Input**\n\n**Input[int barsAgo]**\n\n## Examples\n\n```csharp\n// Prints the the current value of input\nPrint(Input[0].ToString());\n```\n\n```csharp\n// Prints the the current type of input passed to the object, so we can detect if we're working on a price based series such as OHLCV or a derivative such as an SMA indicator\nif (Input is PriceSeries)\n Print(\"Price Series Input\");\nif (Input is Indicator)\n Print(\"Indicator Input\");\n// Prints the the current selected price type for the input series\nelse if (State == State.DataLoaded)\n{\n     PriceSeries priceSeries = Inputs[0] as PriceSeries;\n\n     if (priceSeries != null)\n         Print(\"PriceType selected: \" + priceSeries.PriceType);\n}\n```\n\n{% callout type=\"note\" %}\n\nTip: When working with multi-series indicators, **Input** is not guaranteed to reference the primary **BarsInProgress**. Please be mindful as to when you access **Input[0]** as you will only be able to do so after the contextual **BarsInProgress** has bars. To check to ensure **BarsInProgress** has some bars you can use **CurrentBars** to check.\n\n{% /callout %}"
  },
  {
    "_id": "32381523e63197c929b67f793a8098bed0ae3a6fa902634fdbcc6fa4567f3346",
    "_type": "desktopSdkDoc",
    "title": "Inputs",
    "pathName": "inputs",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries`<double>`** objects holding the main data input. A **ISeries`<double>`** object is added to this array when calling the [**AddDataSeries()**](adddataseries) method. Its purpose is to provide access to the main input all **Bars** objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of **ISeries`<double>`** objects.\n\n## Syntax\n\n**Inputs[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\n\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Adds a 5-minute Bars object to the strategy and is automatically assigned\n         // a Bars object index of 1 since the primary data the strategy is run against\n         // set by the UI takes the index of 0.\n         AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);\n     }\n}\n\nprotected override void OnBarUpdate()\n{\n     // Compares the primary bar's input price to the 5-minute bar's input price\n     if (Inputs[0][0] > Inputs[1][0])\n         Print(\"The primary bar's input is greater\");\n}\n```"
  },
  {
    "_id": "6c35493a2b937829c9815c39e23af964bc84e5430a7dc104c700bbc0de2b59e3",
    "_type": "desktopSdkDoc",
    "title": "Count",
    "pathName": "count",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the number total number of values in the **ISeries** array. This value should always be in sync with the [**CurrentBars**](currentbars) array for that series.\n\n## Method Return Value\n\nA int representing the total size of the series.\n\n## Syntax\n\n**Count**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    Print(\"Input count: \" + Input.Count);\n}\n```"
  },
  {
    "_id": "336074805fc853987abe6f7fe3ad97a6a6f3077a16391fec744f671a015fbd7e",
    "_type": "desktopSdkDoc",
    "title": "Time",
    "pathName": "time",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical bar time stamp values.\n\n## Property Value\n\n**An ISeries<`datetime`> object.**\n\n## Syntax\n\n**Time**  \n\n**Time[int barsAgo]** (returns a [DateTime](datetime) structure)\n\n## Examples\n\n```csharp\n// Prints the current bar time stamp\nPrint(Time[0].ToString());\n\n//Checks if current time is greater than the bar time stamp\nif (DateTime.Now.Ticks > Time[0].Ticks)\n Print(\"Do something\");\n```"
  },
  {
    "_id": "2bf61a3bc850596a77a73c6a9fd279d593974b093bf223fd591e6f052dcaf0e0",
    "_type": "desktopSdkDoc",
    "title": "Times",
    "pathName": "times",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries<`datetime`>** objects holding historical bar times. A **ISeries<`datetime`>** object is `added` to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the times of all Bars objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of **ISeries<`datetime`>** objects.\n\n## Syntax\n\n**Times[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\n\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Adds a 5-minute Bars object to the strategy and is automatically assigned\n         // a Bars object index of 1 since the primary data the strategy is run against\n         // set by the UI takes the index of 0.\n         AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);\n     }\n}\n\nprotected override void OnBarUpdate()\n{\n     // Compares the primary bar's time to the 5-minute bar's time\n     if (Times[0][0].Ticks > Times[1][0].Ticks)\n         Print(\"The current bar's time is greater\");\n}\n```"
  },
  {
    "_id": "62d7a6b1211d627650e2bf0c869b69b564e2cd74290ae1dd78ae4b5e20b0cfe7",
    "_type": "desktopSdkDoc",
    "title": "Volume",
    "pathName": "volume",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical bar volume values.\n\n{% callout type=\"note\" %}\n\nFor working with **Cryptocurrency instruments** which report volume fractional, please use the **VOL()** indicator series, or store the volume for your script in a custom variable and convert alongside our **VOL()** indicator (**Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0]**).\n\n{% /callout %}\n\n## Property Value\n\nAn **ISeries`<double>`** object. Accessing this property via an index **int barsAgo** returns A **double** value representing the volume of the referenced bar.\n\n## Syntax\n\n**Volume**  \n\n**Volume[int barsAgo]**\n\n## Examples\n\n{% table %}\n\n```csharp\n// OnBarUpdate method**\nprotected override void OnBarUpdate()\n{\n     // Is current volume greater than twice the prior bar's volume\n     if (Volume[0] > Volume[1] * 2)\n         Print(\"We have increased volume\");\n\n     // Is the current volume greater than the 20 period moving average of volume\n\n     if (Volume[0] > SMA[Volume, 20](0))\n\n         Print(\"Increasing volume\");\n}\n```"
  },
  {
    "_id": "5d2d96b881a94aa3768cb66421aa5f3095a4a7c090a765693db5545070eb482a",
    "_type": "desktopSdkDoc",
    "title": "Volumes",
    "pathName": "volumes",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries`<double>`** objects holding historical bar volumes. An **ISeries`<double>`** object is added to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the volumes of all Bars objects in a multi-instrument or multi-time frame script.\n\n{% callout type=\"note\" %}\n\nFor working with [Cryptocurrency instruments](instrumenttype) which report volume fractional, please use the [VOL()](volume.md) indicator series, or store the volume for your script in a custom variable and convert alongside our [VOL()](volume.md) indicator (**Instrument.MasterInstrument.InstrumentType == InstrumentType.CryptoCurrency ? Core.Globals.ToCryptocurrencyVolume((long)Volume[0]) : Volume[0]**).\n\n{% /callout %}\n\n## Property Value\n\nAn array of **ISeries`<double>`** objects.\n\n## Syntax\n\n**Volumes[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Adds a 5-minute Bars object to the strategy and is automatically assigned\n         // a Bars object index of 1 since the primary data the strategy is run against\n         // set by the UI takes the index of 0.\n         AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);\n     }\n} \n\nprotected override void OnBarUpdate()\n{ \n     // Compares the primary bar's volume to the 5-minute bar's volume\n     if (Volumes[0][0] > Volumes[1][0])\n         Print(\"The primary bar's volume is greater\");\n}\n```"
  },
  {
    "_id": "ad419b56c6f8bf2b3db8a8a531b4c805a504a4c4d9f81130771c49bed5956c70",
    "_type": "desktopSdkDoc",
    "title": "IsValidDataPoint()",
    "pathName": "isvaliddatapoint",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the specified input is set at a barsAgo value relative to the current bar. Please also see the **[Reset()](reset)** method for more information.\n\n{% table %}\n\n* Notes\n\n---\n\n* If called directly from the instance of the **NinjaScript** object, the value returned corresponds to the Input Series (e.g., Close, High, Low, SMA, etc.)\n* When checking a **[Bar](bars)** or **[PriceSeries](priceseries)**, **IsValidDataPoint()** returns true as long as the barsAgo value falls between 0 and the total count for that series. These are special series which always contain a value set at every slot index for multi-series scripting purposes (e.g., comparing two price series with various session templates, or one series has more ticks than the other)\n* For a **[Value](value.md)** series or custom **[Series<`t`>](seriest)**, **IsValidDataPoint()** returns true or false depending on if you have set a value at that index location\n{% /table %}\n\n## Method Return Value\n\nA bool value, when true indicates that specified data point is set; otherwise false.\n\n## Syntax\n\n**IsValidDataPoint(int barsAgo)**\n\n**ISeries<t`>.IsValidDataPoint(int barsAgo)**\n\n{ %callout type=\"warning\" %}\n\n* Calling **IsValidDataPoint()** will only work on a MaximumBarsLookBackInfinite series. Attempting to check **IsValidDataPoint()** on MaximumBarsLookBack256 series will throw an error. Please check the Log tab of the Control Center. In addition, since this method references barsAgo data, it cannot be used during **[OnRender (see note 5)](onrender)** - instead please use the **[IsValidDataPointAt](isvaliddatapointat)** during OnRender.\n{% /table %}\n\n## Parameters\n\n{% table %}\n\n* barsAgo\n* An int representing from the current bar the number of historical bars the method will check.\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // only set plot value if hosted indicator is not reset\n   if(SMA(20).IsValidDataPoint(0))\n     MyPlot[0] = SMA(20)[0];\n}\n```"
  },
  {
    "_id": "696481d5d8819b8b48dda96a6af86f3001abec62492b4a4a870da95f1a1d7d9e",
    "_type": "desktopSdkDoc",
    "title": "IsValidDataPointAt()",
    "pathName": "isvaliddatapointat",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the specified input is set at a specified bar index value. Please also see the **[Reset()](reset)** method for more information.\n\n{% callout type=\"note\" %}\n\n* If called directly from the instance of the **NinjaScript** object, the value returned corresponds to the Inputs Series (e.g., Close, High, Low, SMA, etc.)\n* When checking a **[Bar](bars)** or **[PriceSeries](priceseries)**, **IsValidDataPoint()** returns true as long as the barIndex value falls between 0 and the total count for that series. These are special series which always contain a value set at every slot index for multi-series scripting purposes (e.g., comparing two price series with various session templates, or one series has more ticks than the other)\n* For a **[Value](value.md)** series or custom **[Series<`t`>](seriest)**, **IsValidDataPoint()** returns true or false depending on if you have set a value at that index location\n{% /callout %}\n\n## Method Return Value\n\nA bool value, when true indicates that specified data point is set; otherwise false.\n\n{% callout type=\"warning\" %}\n\nCalling **IsValidDataPointAt()** will only work on a MaximumBarsLookBackInfinite series. Attempting to check **IsValidDataPointAt()** on MaximumBarsLookBack256 series will throw an error. Please check the Log tab of the Control Center.\n\n{% /callout %}\n\n## Syntax\n\n**IsValidDataPointAt(int barIndex)**\n\n**ISeries<t`>.IsValidDataPointAt(int barIndex)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* barIndex\n* An int representing an absolute bar index value\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // only set plot value if hosted indicator is not reset\n    if(SMA(20).IsValidDataPointAt(CurrentBar))\n        MyPlot[0] = SMA(20)[0];     \n}\n```"
  },
  {
    "_id": "6c1ff09db3a73dc4a854f695d20d174a848d55f2d743bab2ee1f8fc75be454f3",
    "_type": "desktopSdkDoc",
    "title": "Low",
    "pathName": "low",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical bar low prices.\n\n## Property Value\n\nAn **ISeries`<double>`** type object. Accessing this property via an index value **int barsAgo** returns A **double** value representing the price of the referenced bar.\n\n## Syntax\n\n**Low**  \n\n**Low[int barsAgo]**\n\n## Examples\n\n```csharp\n// Current bar low price\ndouble barLowPrice = Low[0];\n\n// Low price of 10 bars ago\ndouble barLowPrice = Low[10];\n\n// Current bar value of a 20 period exponential moving average of low prices**\ndouble value = EMA[Low, 20](0);\n```"
  },
  {
    "_id": "e2b9a700cfe6b11eb791ea921445b33bda9a6b78cff9e2936f1a60439eea377a",
    "_type": "desktopSdkDoc",
    "title": "Lows",
    "pathName": "lows",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries`<double>`** objects holding historical bar low prices. An **ISeries`<double>`** object is added to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the low prices of all **Bars** objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of **ISeries`<double>`** objects.\n\n## Syntax\n\n**Lows[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\n\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Adds a 5-minute Bars object to the strategy and is automatically assigned\n         // a Bars object index of 1 since the primary data the strategy is run against\n         // set by the UI takes the index of 0.\n         AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);\n     }\n}\n\nprotected override void OnBarUpdate()\n{\n     // Compares the primary bar's low price to the 5-minute bar's low price\n     if (Lows[0][0] > Lows[1][0])\n         Print(\"The primary bar's low price is greater\");\n}\n```"
  },
  {
    "_id": "a6ca0ac6913a3e0edb83fd349d4a07893f5a81e6d15b5b8429ea765c08c4ba9e",
    "_type": "desktopSdkDoc",
    "title": "MaximumBarsLookBack",
    "pathName": "maximumbarslookback",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines memory performance of custom **Series`<t>`** objects (such as **Series<`double`>**, **Series<`long`>**, etc.). When using **MaximumBarsLookBack.TwoHundredFiftySix**, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use **MaximumBarsLookBack.Infinite** to allow full access of the series.\n\n{% callout type=\"note\" %}\n\n* **ISeries<`t`>** objects that hold bar data (such as Close, High, Volume, Time, etc) always use **MaximumBarsLookBack.Infinite** which ensures all data points are always accessible during the lifetime of your NinjaScript indicator or strategy.\n* **Series<`double`>** objects that hold indicator **plot values** always use **MaximumBarsLookBack.Infinite** which ensures that charts always display the entire indicator's calculated values.\n{% /callout %}\n\n## Property Value\n\nA **MaximumBarsLookBack** enum value. Default value is **MaximumBarsLookBack.TwoHundredFiftySix**.\n\nPossible values are:\n\n{% table %}\n\n* MaximumBarsLookBack.TwoHundredFiftySix\n* Only the last 256 values of the series object will be stored in memory and accessible for reference (improves memory performance)\n\n---\n\n* MaximumBarsLookBack.Infinite\n* Allow full access of the series, but you will then not be able to utilize the benefits of memory optimization\n{% /table %}\n\n{% callout type=\"note\" %}\n\nA **MaximumBarsLookBack.TwoHundredFiftySix** series works as a circular ring buffer, which will \"loop\" when the series reaches full capacity. Specifically, once there are 256 entries in the series, new data added to the series overwrite the oldest data.\n\n{% /callout %}\n\n## Syntax\n\n**MaximumBarsLookBack**\n\n## Examples\n\n### Setting all custom series to use the default **MaximumBarsLookBack**\n\n```csharp\nSeries<double> myDoubleSeries = null;\nSeries<string> myStringSeries = null;\n\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Example Indicator\";\n     // Store all series values instead of only the last 256 values\n     MaximumBarsLookBack = MaximumBarsLookBack.Infinite;\n   }\n   else if (State == State.DataLoaded)\n   {\n     // The custom Series`<t>` below are all constructed using only the NinjaScriptBase object (i.e., \"this\")\n     // therefore, the Series`<t>` **MaximumBarsLookBack is taken from the NinjaScript's configured MaximumBarsLookBack property\n     myDoubleSeries = new Series<double>(this);\n     myStringSeries = new Series<string>(this);\n   }\n\n```\n\n### Optimizing custom series to use unique **MaximumBarsLookBack** behavior\n\n```csharp\nSeries<double> myDoubleSeries = null;\nSeries<string> myStringSeries = null;\n\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Example Indicator\";\n   }\n   else if (State == State.DataLoaded)\n   {\n     // The custom Series`<t>` below are constructed using MaximumBarsLookBack parameter\n     // therefore, each Series`<t>` will use their uniquely specified MaximumBarsLookBack properties\n     myDoubleSeries = new Series<double>(this, MaximumBarsLookBack.Infinite); // stores all values\n     myStringSeries = new Series<string>(this, MaximumBarsLookBack.TwoHundredFiftySix); // only the last 256 values (better performance)\n   }\n```"
  },
  {
    "_id": "7896a617a785dd968b580c61a2b418ae7ea28ecb713a3650178971519c566c4e",
    "_type": "desktopSdkDoc",
    "title": "Median",
    "pathName": "median",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical bar median prices. Median price = (High + Low) / 2.\n\n## Property Value\n\nAn **ISeries`<double>`** type object. Accessing this property via an index value **int barsAgo** returns A **double** value representing the price of the referenced bar.\n\n## Syntax\n\n**Median**  \n\n**Median[int barsAgo]**\n\n## Examples\n\n```csharp\n\n//Current bar median price\ndouble barMedianPrice = Median[0];\n\n//  Median price of 10 bars ago\ndouble barMedianPrice = Median[10];\n\n// Current bar value of a 20 period exponential moving average of median prices\ndouble value = EMA[Median, 20](0);\n```"
  },
  {
    "_id": "afe93ee255e7ec1d5ba68c9975c7b483e9eb15ee322f1fdf86fbc42a2d909c29",
    "_type": "desktopSdkDoc",
    "title": "Medians",
    "pathName": "medians",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries`<double>`** objects holding historical bar median prices. An **ISeries`<double>`** object is added to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the median prices of all Bars objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of **ISeries`<double>`** objects.\n\n## Syntax\n\n**Medians[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\n\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Adds a 5-minute Bars object to the strategy and is automatically assigned\n         // a Bars object index of 1 since the primary data the strategy is run against\n         // set by the UI takes the index of 0.\n         AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);\n     }\n}\n\nprotected override void OnBarUpdate()\n{\n     // Compares the primary bar's median price to the 5-minute bar's median price\n     if (Medians[0][0] > Medians[1][0])\n         Print(\"The primary bar's median price is greater\");\n}\n\n```"
  },
  {
    "_id": "2348f998744212575d85959674f9607ab26f67708a917157472832386337c904",
    "_type": "desktopSdkDoc",
    "title": "Open",
    "pathName": "open",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical bar opening prices.\n\n## Property Value\n\nAn **ISeries`<double>`** type object. Accessing this property via an index value **int barsAgo** returns A **double** value representing the price of the referenced bar.\n\n## Syntax\n\n**Open**  \n\n**Open[int barsAgo]**\n\n## Examples\n\n```csharp\n//Current bar opening price\ndouble barOpenPrice = Open[0];\n\n// Opening price of 10 bars ago\ndouble barOpenPrice = Open[10];\n\n//Current bar value of a 20 period simple moving average of opening prices\ndouble value = SMA[Open, 20](0);\n```"
  },
  {
    "_id": "3359963d8a8deb76071a37183cd82f598291f8bf39144961bfbc9176c963849d",
    "_type": "desktopSdkDoc",
    "title": "Opens",
    "pathName": "opens",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries`<double>`** objects holding historical bar open prices. An **ISeries`<double>`** object is added to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the open prices of all **Bars** objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of **ISeries`<double>`** objects.\n\n## Syntax\n\n**Opens[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\n\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Adds a 5-minute Bars object to the strategy and is automatically assigned\n         // a Bars object index of 1 since the primary data the strategy is run against\n         // set by the UI takes the index of 0.\n         AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);\n     }\n}\n\nprotected override void OnBarUpdate()\n{\n     // Compares the primary bar's open price to the 5-minute bar's open price\n     if (Opens[0][0] > Opens[1][0])\n         Print(\"The primary bar's open price is greater\");\n}\n```"
  },
  {
    "_id": "336edc1509e93c6d546d60165af9c5350eb6fa60586ef4ae64d6ea5015b48406",
    "_type": "desktopSdkDoc",
    "title": "PriceSeries<double>",
    "pathName": "priceseries",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents historical data as an **ISeries`<double>`** interface which can be used for custom NinjaScript object calculations.\n\n{% callout type=\"note\" %}\n\nIn most cases, you will access the historical price series using a core event handler such as **OnBarUpdate**. For more advanced developers, you may find situations where you wish to access historical price series outside of the core event methods, such as your own custom mouse click. In these advanced scenarios, you may run into situations where the **barsAgo** pointer is not in sync with the current bar, which may cause errors when trying to obtain this information. In those cases, please use the **Bars.Get...()** methods with the absolute bar index, e.g., [**Bars.GetClose()**](getclose), [**Bars.GetOpen()**](getopen), etc.\n\n{% /callout %}\n\n## Single ISeries`<double>`\n\n{% table %}\n\n---\n\n* [Close](close)\n* A collection of historical bar close prices.\n\n---\n\n* [High](high)\n* A collection of historical bar high prices.\n\n---\n\n* [Input](input)\n* A collect of the the main historical input values.\n\n---\n\n* [Low](low)\n* A collection of historical bar low prices.\n\n---\n\n* [Median](median)\n* A collection of historical bar median prices.\n\n---\n\n* [Open](open)\n* A collection of historical bar open prices.\n\n---\n\n* [Typical](typical.md)\n* A collection of historical bar typical prices.\n\n---\n\n* [Value](value.md)\n* A collection of historical references to the first object (**Values[0]**) in the indicator.\n\n---\n\n* [Weighted](weighted.md)\n* A collection of historical bar weighted prices.\n{% /table %}\n\n## Multi-Time Frame ISeries`<double>`\n\n{% table %}\n\n---\n\n* [Closes](closes)\n* Holds an array of **ISeries`<double>`** objects holding historical bar close prices.\n\n---\n\n* [Highs](highs)\n* Holds an array of **ISeries`<double>`** objects holding historical bar high prices.\n\n---\n\n* [Inputs](inputs)\n* Holds an array of **ISeries`<double>`** objects holding main historical input values.\n\n---\n\n* [Lows](lows)\n* Holds an array of **ISeries`<double>`** objects holding historical bar low prices.\n\n---\n\n* [Medians](medians)\n* Holds an array of **ISeries`<double>`** objects holding historical bar median prices.\n\n---\n\n* [Opens](opens)\n* Holds an array of **ISeries`<double>`** objects holding historical bar open prices.\n\n---\n\n* [Typicals](typicals.md)\n* Holds an array of **ISeries`<double>`** objects holding historical bar typical prices.\n\n---\n\n* [Values](values.md)\n* Holds an array of **ISeries`<double>`** objects holding the indicator's underlying calculated values.\n\n---\n\n* [Weighteds](weighteds.md)\n* Holds an array of **ISeries`<double>`** objects holding historical bar weighted prices.\n{% /table %}"
  },
  {
    "_id": "01be30bb4a27765c37462e6bf2a0bf8b6c109f9be9d81e6fd56455db1a736a43",
    "_type": "desktopSdkDoc",
    "title": "Reset()",
    "pathName": "reset",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nResets the internal marker which is used for **IsValidDataPoint()** back to false. Calling the **Reset()** method is unique and can be very powerful for custom indicator development. **Series`<t>`** objects will always contain a value which is assigned, however calling **Reset()** simply means you effectively ignore the value of the current bar for plotting purposes. For calculation purposes you will want to use **IsValidDataPoint()** to ensure you are not calculating off of any reset values assigned by the **Reset()** method.\n\n{% table %}\n\n* Series Type\n* Value after Reset()\n\n---\n\n* **Series<`bool`>**\n* false\n\n---\n\n* **Series<`double`>**\n* 0.00\n\n---\n\n* **Series<`datetime`>**\n* DateTime.MinValue\n\n---\n\n* **Series<`float`>**\n* 0\n\n---\n\n* **Series<`int`>**\n* 0\n\n---\n\n* **Series<`long`>**\n* 0\n\n---\n\n* **Series<`string`>**\n* null\n{% /table %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**Reset()**  \n\n**Reset(int barsAgo)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **barsAgo**\n* An int representing from the current bar the number of historical bars the method will check. If no barsAgo value is supplied, the current bar value will be reset instead (barsAgo 0).\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // set MyPlot to Low of current bar minus 1 tick\n    MyPlot[0] = Low[0] - (1 * TickSize);         \n\n    //reset MyPlot every 10 bars\n    if(CurrentBar % 10 == 0)\n        MyPlot.Reset();     \n\n    // only calculate MyPlot value if it has not be reset\n    if(MyPlot.IsValidDataPoint(0))\n        Print(CurrentBar + \" Value is: \" + MyPlot[0]);         \n}\n```"
  },
  {
    "_id": "d656851aad75df4d049b3bf9314c7d06344a6f2f56f120688101d64372c309f6",
    "_type": "desktopSdkDoc",
    "title": "Series<`t`>",
    "pathName": "seriest",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA **Series`<t>`** is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a **Series<`double`>** object with 200 historical values of data, one for each bar. **Series<`double`>** objects can be used as input data for all [indicator methods](indicators).\n\n{% callout type=\"note\" %}\n\nBy default NinjaTrader limits the number of values stored for **Series`<t>`** objects to 256 from the current bar being processed. This drastically improves memory performance by not holding onto old values that are generally not needed. Should you need more values than the last 256 please be sure to create the **Series`<t>`** object so that it stores all values instead through the use of the [MaximumBarsLookBack](maximumbarslookback) property.\n\n{% /callout %}\n\n## Constructors\n\n{% table %}\n\n* Constructor\n* Description\n\n---\n\n* **Series<`t`>(ninjaScriptBase)**\n* Creates a **Series`<t>`** object synchronized to the primary data series of the provided NinjaScript\n\n---\n\n* **Series<`t`>(ninjaScriptBase, maximumBarsLookBack)**\n* Creates a **Series`<t>`** object synchronized to the primary data series of the provided NinjaScript. This constructor also allows controlling the **Series`<t>`**'s [MaximumBarsLookBack](maximumbarslookback)\n\n---\n\n* **Series<`t`>(bars)**\n* Creates a **Series`<t>`** object synchronized to the provided [Bars](bars) object, for Multi Time Frame scripts, this could be given from [BarsArray](barsarray)\n\n---\n\n* **Series<`t`>(bars, maximumBarsLookBack)**\n* Creates a **Series`<t>`** object synchronized to the provided [Bars](bars) object, for Multi Time Frame scripts, this could be given from [BarsArray](barsarray). While this constructor allows controlling the **Series`<t>`**'s [MaximumBarsLookBack](maximumbarslookback), it is forced to MaximumBarsLookBack.Infinite\n{% /table %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **ninjaScriptBase**\n* The NinjaScript object used to create the **Series**\n\n---\n\n* **bars**\n* The [Bars](bars) object used to create the **Series**\n\n---\n\n* **maximumBarsLookBack**\n* A [MaximumBarsLookBack](maximumbarslookback) value used for memory performance\n{% /table %}\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [GetValueAt()](getvalueat.md)\n* Returns the underlying input value at a specified bar index value.\n\n---\n\n* [IsValidDataPoint()](isvaliddatapoint)\n* Determines if the specified input is set at a barsAgo value relative to the current bar.\n\n---\n\n* [Reset()](reset)\n* Resets the internal marker which is used for [IsValidDataPoint()](isvaliddatapoint) back to false.\n\n---\n\n* [Count](count)\n* The total number of bars or data points.\n{% /table %}\n\n## Creating Series<`t`> Objects\n\nWhen creating custom indicators, **Series<`double`>** objects are automatically created for you by calling the [AddPlot()](addplot) method and can be subsequently referenced by the [Value](value.md) and/or [Values](values.md) property. However, you may have a requirement to create a **Series`<t>`** object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.\n\n{% callout type=\"note\" %}\n\nCustom **Series`<t>`** objects will hold the number of values specified by the [MaximumBarsLookBack](maximumbarslookback) property when the custom series object is instantiated.\n\n{% /callout %}\n\nTo create a **Series`<t>`** object:\n\n1. Determine the data type of the **Series`<t>`** object you wish to create. This could be double, bool, int, string or any other object type you want.\n2. Define a variable of type **Series`<t>`** that will hold a **Series`<t>`** object. This example will create \"myDoubleSeries\" as a **Series<`double`>**.\n3. In the [OnStateChange()](onstatechange) method, in the State.DataLoaded create a new **Series`<t>`** object and assign it to the \"myDoubleSeries\" variable.\n\n```csharp\nprivate Series<double> myDoubleSeries; // Define a Series`<t>` variable. In this instance we want it\n                                        // as a double so we created a Series<double> variable.\n\nprivate Series<double> mySecondaryDoubleSeries; // Define a Series`<t>` variable. In this instance we want it\n                                                // as a double so we created a Series<double> variable.\n\n// Create a Series object and assign it to the variable\nprotected override void OnStateChange() \n{\n    if (State == State.Configure)\n    {\n        // Add a secondary data series to sync our Secondary Series<double>\n        AddDataSeries(BarsPeriodType.Minute, 1);\n    }\n    else if (State == State.DataLoaded)\n    {\n        // \"this\" refers to the NinjaScript object itself. This syncs the Series object to historical data bars\n        // MaximumBarsLookBack determines how many values the Series<double> will have access to\n        myDoubleSeries = new Series<double>(this, MaximumBarsLookBack.Infinite);\n\n        // \"BarsArray[1]\" refers to the first data series added to the script with AddDataSeries.\n        mySecondaryDoubleSeries = new Series<double>(BarsArray[1]);\n    }\n}\n```\n\n## Setting Values\n\nYou can set the value for the current bar being evaluated by choosing a \"barsAgo\" value of \"0\" or, for historical bars, by choosing a \"barsAgo\" value that represents the number of bars ago that you want the value to be stored at.\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    myDoubleSeries[0] = Close[0];\n}\n```\n\n{% callout type=\"note\" %}\n\nThe \"barsAgo\" value is only guaranteed to be in sync with the recent current bar during core data event methods, such as OnBarUpdate(), OnMarketUpdate(), and during strategy related order events such as OnOrderUpdate(), OnExecutionUpdate(), OnPositionUpdate(). For scenarios where you may need to set a value outside of a core data/order event, such as OnRender() or a custom event, you must first synchronize the \"barsAgo\" pointer via the [TriggerCustomEvent()](triggercustomevent.md) method.\n\n{% /callout %}\n\n## Checking for Valid Values\n\nIt is possible that you may use a **Series`<t>`** object but decide not to set a value for a specific bar. However, you should not try to access a **Series`<t>`** value that has not been set. Internally, a dummy value does exist, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations. Please see [IsValidDataPoint()](isvaliddatapoint) for more information.\n\n{% callout type=\"warning\" %}\n\nCalling [IsValidDataPoint()](isvaliddatapoint) will only work on a [MaximumBarsLookBackInfinite](maximumbarslookback) series. Attempting to check [IsValidDataPoint()](isvaliddatapoint) on a MaximumBarsLookBack256 series will throw an error. Please check the Log tab of the Control Center.\n\n{% /callout %}\n\n## Getting Values\n\nYou can access **Series`<t>`** object values using the syntax **Series<`t`>[int barsAgo]** where barsAgo represents the data value n (number of bars ago).\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Prints the current and last bar value\n    Print(\"The values are \" + myDoubleSeries[0] + \" \" + myDoubleSeries[1]);\n}\n```\n\nAlternatively, you can access a value at an absolute bar index using the [GetValueAt()](getvalueat.md) method.\n\n{% callout type=\"note\" %}\n\nIn most cases, you will access the historical price series using a core data event handler such as OnBarUpdate(). For more advanced developers, you may find situations where you wish to access historical price series outside of the core data event methods, such as OnRender(), or your own custom event. In these advanced scenarios, you may run into situations where the \"barsAgo\" pointer is not in sync with the current bar, and may result in errors when trying to obtain this information. In those cases, please use the Bars.Get...() methods with the absolute bar index, e.g., [GetValueAt()](getvalueat.md).\n\n{% /callout %}\n\n## Methods that Accept ISeries<`t`> as Arguments\n\nAll [indicator methods](indicators) accept **ISeries`<double>`** objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    // Calculate the range of the current bar and set the value\n    myDoubleSeries[0] = (High[0] - Low[0]);\n\n    // Print the current 10 period SMA of range\n    Print(\"Value is \" + SMA(myDoubleSeries, 10)[0]);         \n}\n```"
  },
  {
    "_id": "b179e7515844f557e9d5d3a4607e41e001f43646459dad9a8ab2cb0b674e6a62",
    "_type": "desktopSdkDoc",
    "title": "TimeSeries<datetime>",
    "pathName": "timeseries",
    "parent": "iseriest",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents historical time stamps as an **ISeries<`datetime`>** interface which can be used for custom NinjaScript object calculations.\n\n{% callout type=\"note\" %}\n\nNote: In most cases, you will access the historical time series using a core event handler such as **OnBarUpdate**. For more advanced developers, you may find situations where you wish to access historical time series outside of the core event methods, such as your own custom mouse click. In these advanced scenarios, you may run into situations where the **barsAgo** pointer is not in sync with the current bar, which may cause errors when trying to obtain this information. In those cases, use the **Bars.Get...()** methods with the absolute bar index, e.g., [**Bars.GetTime()**](gettime).\n\n{% /callout %}\n\n## Single ISeries<`datetime`>\n\n{% table %}\n\n* Time\n* A collection of historical bar time stamp values.\n{% /table %}\n\n## Multi-Time Frame ISeries<`datetime`>\n\n{% table %}\n\n* Times\n* Holds an array of **ISeries<`datetime`>** objects holding historical bar times.\n{% /table %}"
  },
  {
    "_id": "4320f382efcb0b575c217679061b4d7cc4a06647cac6e990d9e76e692534ac79",
    "_type": "desktopSdkDoc",
    "title": "ISeries",
    "pathName": "iseries",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\n**ISeries** is an interface that is implemented by all NinjaScript classes that manage historical data as an **ISeries`<double>`** (Open, High, Low, Close, etc), used for indicator input, and other object data. Please see the help guide article on [Working with Price Series](working_with_price_series) for a basic overview on how to access this information.\n\n## Types of ISeries\n\n{% table %}\n\n* [Series<`t`>](seriest)\n* Represents a generic custom data structure for custom development\n\n---\n\n* [PriceSeries](priceseries)\n* Historical price data structured as an **ISeries`<double>`** interface (Close[0], High[0], Low[0], etc)\n\n---\n\n* [TimeSeries](timeseries)\n* Historical time stamps structured as an **ISeries<`datetime`>** interface (Time[0])\n\n---\n\n* [VolumeSeries](volumeseries)\n* Historical volume data structured as an **ISeries`<double>`** interface (Volume[0])\n{% /table %}\n\n## Methods and Properties\n\n{% table %}\n\n---\n\n* [GetValueAt()](getvalueat)\n* Returns the underlying input value at a specified bar index value.\n\n---\n\n* [IsValidDataPoint()](isvaliddatapoint)\n* Indicates if the specified input is set at a barsAgo value relative to the current bar.\n\n---\n\n* [IsValidDataPointAt()](isvaliddatapointat)\n* Indicates if the specified input is set at a specified bar index value.\n\n---\n\n* [Count](iseries_count)\n* Return the number total number of values in the **ISeries** array\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips: (see examples below)\n\n1. By specifying a parameter of type **ISeries`<double>`**, you can then pass in an array of closing prices, an indicator, or a user defined data series.\n2. When working with **ISeries`<double>`** objects in your code you may come across situations where you are not sure if the value being accessed is a valid value or just a \"placeholder\" value. To check if you are using valid values for your logic calculations that have been explicitly set, please use **.IsValidDataPoint(int barsAgo)** to check.\n{% /callout %}\n\n## Examples\n\n### Using **ISeries** as a method parameter\n\n```csharp\n\nprivate double DoubleTheValue(ISeries`<double>` priceData)\n{\n    return priceData[0] * 2;\n}\n\nprotected override void OnBarUpdate()\n{\n    Print(DoubleTheValue(Close));\n    Print(DoubleTheValue(SMA(20)));\n}\n\n```\n\n### Checking **ISeries** value before accessing\n\n```csharp\n\nprotected override void OnBarUpdate()\n{\n    if (Input.IsValidDataPoint(0))\n        Plot0[0] = Input[0];\n}\n\n```"
  },
  {
    "_id": "51061b8289e4a16ba83e660839ec0a3a10ba76aea04ec822e0483fd3d1b59a0c",
    "_type": "desktopSdkDoc",
    "title": "IsVisible",
    "pathName": "isvisible",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines if the current **NinjaScript** object should be visible on the chart. When an object's **IsVisible** property is set to false, the object will NOT be displayed on the chart and will not be calculated to save resources.\n\n{% callout type=\"note\" %}\n\nStrategies intentionally contain no **IsVisible** property.\n\n{% /callout %}\n\n{% callout type=\"warning\" %}\n\nWarning: This property should NOT be set on indicators which add a panel or own their own panel. Panel addition/removal is determined when an indicator is added/removed to a chart and is not modified through the **IsVisible** property.\n\n{% /callout %}\n\n## Property Value\n\nA bool value when true will be displayed on the chart; otherwise false; default value is true.\n\n## Syntax\n\n**IsVisible**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Loops through the DrawObjects collection via a threadsafe list copy\n   foreach (DrawingTool draw in DrawObjects.ToList())\n   {\n     // Detect all manual drawn line objects and change their visibility\n     if (draw is DrawingTools.Line && draw.IsUserDrawn)\n     {\n         draw.IsVisible = false;\n     }\n   }             \n}\n```"
  },
  {
    "_id": "82a3537ff0dbce7eec35d69edc3a189ee6f17d82f353a553f9aa96cb0be3ce89",
    "_type": "desktopSdkDoc",
    "title": "Name",
    "pathName": "name",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines the listed name of the NinjaScript object.\n\n## Property Value\n\nA **string** value.\n\n## Syntax\n\n**Name**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n   \n   if (State == State.SetDefaults)\n   {\n     Name                 = \"Examples indicator\";\n     Description           = @\"An example of an indicator used for documentation purposes\";      \n   }\n```"
  },
  {
    "_id": "2fd4cef1f90bc04e4e130a2e2dd3fdbef9109ce60fe07e1f7812132e832a4e04",
    "_type": "desktopSdkDoc",
    "title": "BarsPeriod",
    "pathName": "barsperiod",
    "parent": "onbarupdate",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe primary Bars object time frame (period type and interval).\n\n{% callout type=\"warning\" %}\n\nThis property should NOT be accessed within the [OnStateChange](onstatechange) method before the State has reached State.DataLoaded\n\n{% /callout %}\n\n## Property Value\n\nA [Bars](bars) series object representing the time frame of the Bars.\n\n## Syntax\n\n{% table %}\n\n* BarsPeriod.BarsPeriodType\n* The type of bars used for the period, as well as the enumeration value under which the any of the 14 default NinjaTrader types are registered. Possible values include:\n\n---\n\n* BarsPeriodType.Tick\n* 0\n\n---\n\n* BarsPeriodType.Volume\n* 1\n\n---\n\n* BarsPeriodType.Range\n* 2\n\n---\n\n* BarsPeriodType.Second\n* 3\n\n---\n\n* BarsPeriodType.Minute\n* 4\n\n---\n\n* BarsPeriodType.Day\n* 5\n\n---\n\n* BarsPeriodType.Week\n* 6\n\n---\n\n* BarsPeriodType.Month\n* 7\n\n---\n\n* BarsPeriodType.Year\n* 8\n\n---\n\n* BarsPeriodType.HeikenAshi\n* 9\n\n---\n\n* BarsPeriodType.Kagi\n* 10\n\n---\n\n* BarsPeriodType.Renko\n* 11\n\n---\n\n* BarsPeriodType.PointAndFigure\n* 12\n\n---\n\n* BarsPeriodType.LineBreak\n* 13\n\n---\n\n* BarsPeriodType.Volumetric\n* 14\n{% /table %}\n\n{% callout type=\"note\" %}\n\nWhen creating custom [BarsTypes](bars_type), it is recommended to pick high, unique enumeration value to avoid conflict from other BarsTypes that may be used by a single installation.\n\nBarsPeriod = new BarsPeriod { BarsPeriodType = (BarsPeriodType)123456, BarsPeriodTypeName = \"MyCustomBars\", Value = 1 };\n\n{% /callout %}\n\n{% table %}\n\n* BarsPeriod.BaseBarsPeriodType\n* Only relevant for [HeikenAshi](addheikenashi), [Kagi](addkagi), [LineBreak](addlinebreak), [PointAndFigure](addpointandfigure) and [Volumetric](addvolumetric) Bars objects. Same possible values as BarsPeriod.BarsPeriodType\n\n---\n\n* BarsPeriod.BaseBarsPeriodValue\n* Only relevant for [HeikenAshi](addheikenashi), [Kagi](addkagi), [LineBreak](addlinebreak), [PointAndFigure](addpointandfigure) and [Volumetric](addvolumetric) Bars objects. Determines an integer value representing the basePeriodTypeValue parameter\n\n---\n\n* BarsPeriod.MarketDataType\n* The data type used to build the bars. Possible values:\n \t* MarketDataType.Ask\n \t* MarketDataType.Bid\n \t* MarketDataType.Last\n\n---\n\n* BarsPeriod.PointAndFigurePriceType\n* Only relevant for PointAndFigure Bars objects. Possible values:\n \t* PointAndFigurePriceType.Close\n \t* PointAndFigurePriceType.HighsAndLows\n\n---\n\n* BarsPeriod.ReversalType\n* Only relevant for Kagi Bars objects. Possible values:\n \t* ReversalType.Percent\n \t* ReversalType.Tick\n\n---\n\n* BarsPeriod.Value\n* Determines an integer value representing the period parameter. When using Kagi Bars objects this represents the \"reversal\" parameter. When using LineBreak Bars objects this represents the \"lineBreakCount\" parameter. When using PointAndFigure Bars objects this represents the \"boxSize\" parameter. When using Renko Bars objects this represents the \"brickSize\" parameter\n\n---\n\n* BarsPeriod.Value2\n* Only relevant for PointAndFigure Bars objects. Determines an integer value representing the \"reversal\" parameter.\n{% /table %}\n\n## Examples\n\n```csharp\n// Checking BarsPeriod values\n// Calculate only if there is a 100 tick chart or greater\nprotected override void OnBarUpdate() \n{ \n     if (BarsPeriod.BarsPeriodType == BarsPeriodType.Tick && BarsPeriod.Value >= 100)\n     {\n         // Indicator calculation logic here\n     }\n}\n```\n\n```csharp\n// Creating a new BarsPeriod object\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {      \n           // add a 1440 minute apple bars object using the RTH session template\n           AddDataSeries(\"AAPL\", new BarsPeriod { BarsPeriodType = BarsPeriodType.Minute, Value = 1440 }, \"US Equities RTH\");                \n     }\n\n     else if (State == State.DataLoaded)\n     {\n           // Print out the loaded bars period \n           Print(Instrument.FullName + \" \" + BarsPeriod); // MSFT 1 Minute\n           Print(BarsArray[1].Instrument.FullName + \" \" + BarsArray[1].BarsPeriod); // AAPL 1440 Minute\n     }\n}\n```"
  },
  {
    "_id": "edca249d8d1f9a5b7d1a0f3ef54e3969bf3acb65499aaea1316cc43a98315502",
    "_type": "desktopSdkDoc",
    "title": "Calculate",
    "pathName": "calculate",
    "parent": "onbarupdate",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines how often **OnBarUpdate()** is called for each bar. **OnBarClose** means once at the close of the bar. **OnEachTick** means on every single tick. **OnPriceChange** means once for each price change. If there were two ticks in a row with the same price, the second tick would not trigger **OnBarUpdate()**. This can improve performance if calculations are only needed when new values are possible.\n\n{% callout type=\"note\" %}\n\nNotes:  \n\n1. On a historical data set, only the OHLCVT of the bar is known and not each tick that made up the bar. As a result, **State.Historical** data processes **OnBarUpdate()** only on the close of each historical bar even if this property is set to **OnEachTick** or **OnPriceChange**. You can use **TickReplay** or a **Multi-time frame script** to obtain intrabar data.  \n2. When set to **Calculate.OnPriceChange**, the **OnBarUpdate()** method is ONLY called when the price has changed intrabar OR when the bar has closed.\n{% /callout %}\n\n## Property Value\n\nAn enum value determining how frequently **OnBarUpdate()** will be called. Default value is set to **Calculate.OnBarClose**.\n\n{% callout type=\"warning\" %}\n\nWarning:  \n\n* This property should ONLY be set from the **OnStateChange()** method during **State.SetDefaults** or **State.Configure**.  \n* If your script relies on volume updates, **OnPriceChange** should NOT be used since it can potentially miss volume updates if they occur at the same price.\n{% /callout %}\n\n## Syntax\n\n**Calculate.OnBarClose**\n\n**Calculate.OnEachTick**\n\n**Calculate.OnPriceChange**\n\n{% callout type=\"note\" %}\n\nTips:  \n\n1. Calculating indicators or systems for each incoming tick can be CPU intensive. Only calculate indicators on each incoming tick if you have a requirement to calculate it intra-bar.  \n2. For an example of how to separate some logic to be **Calculate = Calculate.OnBarClose** and other logic to be **.OnEachTick**, please see this [reference sample](http://www.ninjatrader.com/support/forum/showthread.php?t=19387).  \n3. Embedded scripts within a calling parent script should not use a different **Calculate** property since it is already utilizing the **Calculate** property of the parent script (i.e. the strategy your indicator is called from).  \n4. Since the parent **NinjaScript** therefore governs this setting, it should be set to the highest needed setting satisfying all its children.\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n     if (State == State.SetDefaults)\n     {\n         // Calculate on the close of each bar\n         Calculate = Calculate.OnBarClose;\n     }\n}\n```"
  },
  {
    "_id": "6c35493a2b937829c9815c39e23af964bc84e5430a7dc104c700bbc0de2b59e3",
    "_type": "desktopSdkDoc",
    "title": "Count",
    "pathName": "count",
    "parent": "onbarupdate",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThe total number of bars or data points.\n\n## Property Value\n\nAn **int** value representing the total number of bars.\n\n## Syntax\n\n**Count**\n\n## Examples\n\n```csharp\n//If there are less than 365 bars on the chart, text indicates how many bars are on the chart\nif (Count < 365)\n{\n  Draw.TextFixed(this, \"tag1\", \"There are \" + Count + \" bars on the chart\", TextPosition.BottomRight);\n}\n```\n\n{ %callout type=\"note\" %}\n\n[CurrentBar](currentbar) value is guaranteed to be <= Count - 1. This is because of the NinjaTrader multi-threaded architecture, the Count value can have additional bars as inflight ticks come in to the system.\n\n{% /callout %}"
  },
  {
    "_id": "3ba7aced7d3fb374b8021ed587f906bbd09584be98d0205133bfbe56f8beada0",
    "_type": "desktopSdkDoc",
    "title": "CurrentBar",
    "pathName": "currentbar",
    "parent": "onbarupdate",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA number representing the current bar in a Bars object that the **OnBarUpdate()** method in an indicator or strategy is currently processing. For example, if a chart has 100 bars of data, the very first bar of the chart (left most bar) will be number 0 (zero) and each subsequent bar from left to right is incremented by 1.\n\n{% callout type=\"note\" %}\n\nIn [multi series](multi-time_frame__instruments) processing, the **CurrentBars** starting value will be -1 until all series have processed the first bar.\n\n{% /callout %}\n\n## Property Value\n\nAn **int** value that represents the current bar.\n\n## Syntax\n\n**CurrentBar**\n\n## Examples\n\n```csharp\n// OnBarUpdate method\nprotected override void OnBarUpdate()\n{\n     // Evaluates to make sure we have at least 20 or more bars\n     if (CurrentBar < 20)\n         return;\n\n     // Indicator logic calculation code...\n}\n```"
  },
  {
    "_id": "718b43a31008a4a0dcd9a2a61c5bee9350111f379dd68b301ad1c60219a29bc7",
    "_type": "desktopSdkDoc",
    "title": "IsDataSeriesRequired",
    "pathName": "isdataseriesrequired",
    "parent": "onbarupdate",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines if a Data Series is required for calculating this **NinjaScript** object. When set to false, data series related properties will not be displayed on the UI when configuring.\n\n{% callout type=\"note\" %}\n\nWhen set to false, methods and properties which are dependent on Bars will NOT be used. This means you will not receive any calls to **OnBarUpdate()** or be able to access historical bar prices.\n\n{% /callout %}\n\n## Property Value\n\nThis property returns true if the **NinjaScript** requires a Data Series; otherwise, false. Default value is true.\n\n{% callout type=\"warning\" %}\n\nWarning: This property should ONLY be set from the **OnStateChange()** method during **State.SetDefaults** or **State.Configure**.\n\n{% /callout %}\n\n## Syntax\n\n**IsDataSeriesRequired**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.SetDefaults)\n    {\n        IsDataSeriesRequired = false;\n    }\n}\n```"
  },
  {
    "_id": "39914eae9afa27397b2701f1b1864e859cc7e3d71b4e4f868e711644094e816f",
    "_type": "desktopSdkDoc",
    "title": "IsFirstTickOfBar",
    "pathName": "isfirsttickofbar",
    "parent": "onbarupdate",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates if the incoming tick is the first tick of a new bar. This property is only of value in scripts that run tick by tick which is when the **Calculate** property is set to **Calculate.OnEachTick** or **Calculate.OnPriceChange**.\n\n{% callout type=\"warning\" %}\n\nThis property should NOT be accessed outside of the **OnBarUpdate()** method.\n\n{% /callout %}\n\n{% callout type=\"note\" %}\n\nIf a bar type is set up to **remove the last bar** on a chart, **IsFirstTickOfBar** will automatically be set to True.\n\n{% /callout %}\n\n## Property Value\n\nThis property returns true if the incoming tick is the first tick of a new bar; otherwise, false.\n\n## Syntax\n\n**IsFirstTickOfBar**\n\n{% callout type=\"note\" %}\n\nIn NinjaTrader's event driven framework, bar closures are signaled by the tick that opens the next bar. The price of the last tick of a bar can be referenced by checking **Close[1]** on **IsFirstTickOfBar**. For volume and tick based bars, **Bars.TickCount** and **Volume[0]** can be referenced to see if the number of ticks / volume meet the criteria to build a new bar.\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// On a tick by tick strategy the only way you know when a bar is closed is when\n// the IsFirstTickOfBar is true.\nprotected override void OnBarUpdate()\n{\n     // Only process entry signals on a bar by bar basis (not tick by tick)\n     if (IsFirstTickOfBar)\n     {\n         if (CCI(20)[1] < -250)\n               EnterLong();\n         return;\n     }\n\n     // Process exit signals tick by tick\n     if (CCI(20)[0] > 250)\n         ExitLong();\n}\n```"
  },
  {
    "_id": "b3054d916ca6649398f6e6841e02713384350daaa7aaf3dd60da41f04aa3ddd5",
    "_type": "desktopSdkDoc",
    "title": "IsResetOnNewTradingDays",
    "pathName": "isresetonnewtradingdays",
    "parent": "onbarupdate",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDetermines if the specified bar series iusing Break at EOD\n\n{% callout type=\"note\" %}\n\nThe property available on the UI will override any values set in code. Please see the help guide topic on using **Break at EOD** for more information.\n\n{% /callout %}\n\n## Property Value\n\nA **bool[]** when true, indicates the specified [BarsArray](barsarray) is setup to run Break at EOD; otherwise false. Default value is false.\n\n## Syntax\n\n**IsResetOnNewTradingDays**[int idx]\n\n{% callout type=\"warning\" %}\n\nThis property should NOT be accessed within the [OnStateChange()](onstatechange) method before the State has reached State.DataLoaded.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n   if (State == State.SetDefaults)\n   {\n     Name = \"Examples Indicator\";\n   }\n\n   else if (State == State.Configure)\n   {\n     //Add AAPL 1 minute with RTH trading hours, set to break EOD\n     AddDataSeries(\"AAPL\", new BarsPeriod() { BarsPeriodType = BarsPeriodType.Minute, Value = 1 }, 50, \"US Equities RTH\", true);\n   }\n\n}\nprotected override void OnBarUpdate()\n{\n //Print out the current bars series name and break EOD setting on start up\n //   IsResetOnNewTradingDays[0]  Primary\n //   IsResetOnNewTradingDays[1]  AAPL\n\n if (CurrentBar == 0)\n   Print(BarsArray[BarsInProgress].ToChartString() + \" \" + IsResetOnNewTradingDays[BarsInProgress]);\n\n //Output:  \n //ES 03-15 (1 Minute) True\n //AAPL (1 Minute) False\n```"
  },
  {
    "_id": "726d754b78c9b0f978e0bdc0aa03199899426b928f8dc90735dc671c9ac69ac7",
    "_type": "desktopSdkDoc",
    "title": "IsTickReplays",
    "pathName": "istickreplays",
    "parent": "onbarupdate",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates the specified bar series is using Tick Replay. Please see the help guide topic on using [Tick Replay](tick_replay) for general information on this mode.\n\n{% callout type=\"note\" %}\n\nFor a primary series, the Tick Replay option must be configured from the UI before a NinjaScript object can take use of this property. The setting on the Chart's Data Series menu will always take precedence for an object series which already exists on the user's chart.\n\n{% /callout %}\n\n{% callout type=\"warning\" %}\n\nWarning: This property should NOT be accessed within the **OnStateChange()** method before the State has reached **State.DataLoaded**.\n\n{% /callout %}\n\n## Property Value\n\nA **bool[]** when true, indicates the specified [BarsArray](barsarray) is setup to run Tick Replay; otherwise false. Default value is false.\n\n## Syntax\n\n**IsTickReplays[int idx]**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if(State == State.SetDefaults)\n    {\n        Name = \"Examples Indicator\";\n    }\n    \n    else if (State == State.Configure)\n    {\n        AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 1);   \n    }\n    else if (State == Data.Loaded)\n    {\n        // IsTickReplays[0] = true; \n        // Programmatically setting this option here for Primary [0] does not have any effect       \n        // Primary series must be configured from UI\n                \n        // It is not possible to combine Tick Replay series and non Tick Replay series in a single chart or script\n        // The assignment below would not be necessary if the primary series were set to True via the UI\n        // IsTickReplays[1] = true;\n    }\n}\n\nprotected override void OnBarUpdate()\n{                     \n    //Print out the current bars series name and tick replays setting on start up\n    if (CurrentBar == 0)           \n        Print(BarsArray[BarsInProgress].ToChartString() + \" \" + IsTickReplays[BarsInProgress]);\n}\n```"
  },
  {
    "_id": "c11bd92ab5f4c3fd3fe7f5f36b75139170bac06f827832f53f5183f754a39f38",
    "_type": "desktopSdkDoc",
    "title": "OnBarUpdate()",
    "pathName": "onbarupdate",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn event driven method which is called whenever a bar is updated. The frequency in which **OnBarUpdate** is called will be determined by the \"[Calculate](calculate)\" property. **OnBarUpdate()** is the method where all of your script's core bar based calculation logic should be contained.\n\n{% callout type=\"note\" %}\n\nNotes:  \n\n* For [multi-timeframe and instrument scripts](multi-time_frame__instruments), the **OnBarUpdate** method is called for each Bars object of a strategy. You MUST filter for the exact bar update events using the \"[BarsInProgress](barsinprogress)\" property you want your system logic to execute against.\n* Hosted indicators will need to be accessed by the hosting script to ensure **OnBarUpdate** functionality. This can be done by:\n  1) Calling [Update](update.md) on the hosted indicator within the host script,\n  2) Including a plot in the hosted indicator and accessing the plot in the host script,\n  3) Including a plot in the hosted indicator and adding the indicator to the chart with [AddChartIndicator](addchartindicator) (strategies only)\n{% /callout %}\n\n## Related Methods and Properties\n\n{% table %}\n\n* Method\n* Description\n\n---\n\n* [BarsPeriod](barsperiod)\n* The primary Bars object time frame (period type and interval).\n\n---\n\n* [Calculate](calculate)\n* Determines how often **OnBarUpdate()** is called for each bar.\n\n---\n\n* [Count](count)\n* The total number of bars or data points.\n\n---\n\n* [CurrentBar](currentbar)\n* A number representing the current bar in a Bars object that the **OnBarUpdate()** method in an indicator or strategy is currently processing.\n\n---\n\n* [IsDataSeriesRequired](isdataseriesrequired)\n* Determines if a Data Series is required for calculating this NinjaScript object.\n\n---\n\n* [IsFirstTickOfBar](isfirsttickofbar)\n* Indicates if the incoming tick is the first tick of a new bar.\n\n---\n\n* [IsResetOnNewTradingDays](isresetonnewtradingdays)\n* Determines if the specified bar series is using Break at EOD.\n\n---\n\n* [IsTickReplays](istickreplays)\n* Indicates the specified bar series is using Tick Replay.\n\n---\n\n* [Update()](update.md)\n* Forces the **OnBarUpdate()** method to be called so that indicator values are updated to the current bar.\n{% /table %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\nYou must override this method with the following syntax:\n\n**protected override void OnBarUpdate()**\n\n{% callout type=\"note\" %}\n\nTip: The NinjaScript code wizards automatically generates the method syntax for you.\n\n{% /callout %}\n\n## Parameters\n\nThis method does not take any parameters.\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     if (CurrentBar < 1)\n         return;\n\n     // Compares the primary bar's low price to the 5-minute bar's low price\n     if (Low[0] > Lows[1])\n         Print(\"The current bar's low price is greater\");\n}\n```"
  },
  {
    "_id": "bb65af2610b8d8ae0f95fa06b3ec069d3f93ef515ab690f5c05d3e458571bca8",
    "_type": "desktopSdkDoc",
    "title": "ConnectionStatusEventArgs",
    "pathName": "onconnectionstatusupdate",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\n**ConnectionStatusEventArgs** contains **Connection**-related information to be passed as an argument to the **OnConnectionStatusUpdate()** event.\n\n{% callout type=\"note\" %}\n\nFor a complete, working example of this class in use, download framework example located on our [Developing AddOns Overview](addon_development_overview_overview).\n\n{% /callout %}\n\nThe properties listed below are accessible from an instance of **ConnectionStatusEventArgs**:\n\n{% table %}\n\n* Property\n* Description\n\n---\n\n* **Connection**\n* The Connection object for which **OnConnectionStatusUpdate()** was called\n\n---\n\n* **Error**\n* An **ErrorCode** thrown by the Connection object in question\n\n---\n\n* **NativeError**\n* A string representing an error thrown by the connectivity provider\n\n---\n\n* **PreviousStatus**\n* A **ConnectionStatus** object representing the status of the connection before this call to **OnConnectionStatusUpdate()**\n\n---\n\n* **Status**\n* A **ConnectionStatus** object representing the new status of the connection\n\n---\n\n* **PreviousPriceStatus**\n* A **ConnectionStatus** object representing the status of the connection's price feed before this call to **OnConnectionStatusUpdate()**\n\n---\n\n* **PriceStatus**\n* A **ConnectionStatus** object representing the new status of the connection's price feed\n{% /table %}\n\n## Examples\n\n```csharp\n// This method is fired on connection status events\nprivate void OnConnectionStatusUpdate(object sender, ConnectionStatusEventArgs e)\n{\n    // For multi-threading reasons, work with a copy of the ConnectionStatusEventArgs to prevent situations in which the EventArgs may already be ahead of us while in the middle processing it.\n    // This accomplishes the same goal as locking a collection to prevent in-flight changes from affecting outcomes\n    ConnectionStatusEventArgs eCopy = e;\n\n    /* Dispatcher.InvokeAsync() is needed for multi-threading considerations. When processing events outside of the UI thread, and we want to\n     influence the UI .InvokeAsync() allows us to do so. It can also help prevent the UI thread from locking up on long operations. */\n    Dispatcher.InvokeAsync(() =>\n    {\n        outputBox.AppendText(string.Format(\"{1} Status: {2}\",\n                Environment.NewLine,\n                eCopy.Connection.Options.Name,\n                eCopy.Status));\n    });   \n}\n```"
  },
  {
    "_id": "bb65af2610b8d8ae0f95fa06b3ec069d3f93ef515ab690f5c05d3e458571bca8",
    "_type": "desktopSdkDoc",
    "title": "OnConnectionStatusUpdate()",
    "pathName": "onconnectionstatusupdate",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn event driven method used which is called for every change in connection status.\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\nYou must override the method in your indicator with the following syntax:\n\n**protected override void OnConnectionStatusUpdate(ConnectionStatusEventArgs connectionStatusUpdate)**\n\n## Method Parameters\n\n{% table %}\n\n---\n\n* **connectionStatusUpdate**\n* A **ConnectionStatusEventArgs** object representing the most recent update in connection.\n\n---\n\n* **Status**\n* Represents the status of the key adapter functionality. If the adapter supports live orders it will set Status to Disconnected when its order system is not connected.\n\n---\n\n* **PriceStatus**\n* Represents the status of the price feed.\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnConnectionStatusUpdate(ConnectionStatusEventArgs connectionStatusUpdate)\n{\n   if(connectionStatusUpdate.Status == ConnectionStatus.Connected)\n   {\n     Print(\"Connected for orders at \" + DateTime.Now);\n   }\n\n   else if(connectionStatusUpdate.Status == ConnectionStatus.ConnectionLost)\n   {\n     Print(\"Connection for orders lost at: \" + DateTime.Now);\n   }\n}\n```\n\n```csharp\n\nprotected override void OnConnectionStatusUpdate(ConnectionStatusEventArgs connectionStatusUpdate)\n\n{\n\n   if(connectionStatusUpdate.PriceStatus == ConnectionStatus.Connected)\n\n   {\n\n     Print(\"Connected to price feed at \" + DateTime.Now);\n\n   }\n\n   else if(connectionStatusUpdate.PriceStatus == ConnectionStatus.ConnectionLost)\n\n   {\n\n     Print(\"Connection to price feed lost at: \" + DateTime.Now);\n\n   }\n\n}\n\n```"
  },
  {
    "_id": "bbc04ca3e1548839fff5e57aa26191ea590390e12b2070506353df13f13c3814",
    "_type": "desktopSdkDoc",
    "title": "FundamentalDataEventArgs",
    "pathName": "fundamentaldataeventargs",
    "parent": "onfundamentaldata",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents a change in fundamental data and is passed as a parameter in the **OnFundamentalData()** method.\n\n## Methods and Parameters\n\n{% table %}\n\n* DateTimeValue\n* DoubleValue\n* FundamentalDataType\n* IsReset\n* LongValue\n* ToString()\n\n---\n\n* A **DateTime** value representing the time\n* A **double** value representing fundamental data\n* Possible values:\n  * AverageDailyVolume\n  * Beta\n  * CalendarYearHigh\n  * CalendarYearHighDate\n  * CalendarYearLow\n  * CalendarYearLowDate\n  * CurrentRatio\n  * DividendAmount\n  * DividendPayDate\n  * DividendYield\n  * EarningsPerShare\n  * FiveYearsGrowthPercentage\n  * High52Weeks\n  * High52WeeksDate\n  * HistoricalVolatility\n  * Low52Weeks\n  * Low52WeeksDate\n  * MarketCap\n  * NextYearsEarningsPerShare\n  * PercentHeldByInstitutions\n  * PriceEarningsRatio\n  * RevenuePerShare\n  * SharesOutstanding\n  * ShortInterest\n  * ShortInterestRatio\n  * VWAP\n\n---\n\n* A bool value representing if a UI reset is needed after a manual disconnect. Note: This is only relevant for columns. Whenever this property is true, the UI needs to be reset.\n* A long value representing fundamental data\n* A string representation of the FundamentalDataEventArgs object\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnFundamentalData(FundamentalDataEventArgs fundamentalDataUpdate)\n{\n    // Print some data to the Output window\n    if (fundamentalDataUpdate.FundamentalDataType == FundamentalDataType.AverageDailyVolume)\n        Print(\"Average Daily Volume = \" + fundamentalDataUpdate.LongValue);\n    else if (fundamentalDataUpdate.FundamentalDataType == FundamentalDataType.PriceEarningsRatio)\n        Print(\"P/E Ratio = \" + fundamentalDataUpdate.DoubleValue);\n}\n```\n\n{% callout type=\"note\" %}\n\n* Not all connectivity providers support all FundamentalDataTypes.\n* **EarningsPerShare** on eSignal is a trailing twelve months value. On IQFeed it is the last quarter's value.\n* **RevenuePerShare** is a trailing twelve months value.\n\n{% /callout %}"
  },
  {
    "_id": "ebec9295206b73ad293f25c549afa0ab48b0dd3a7f426691353bd4756f9b27f2",
    "_type": "desktopSdkDoc",
    "title": "OnFundamentalData()",
    "pathName": "onfundamentaldata",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn event driven method which is called for every change in fundamental data for the underlying instrument.\n\n{% callout type=\"note\" %}\n\nThis method is NOT called on historical data (backtest).\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\nYou must override the method in your strategy or indicator with the following syntax.\n\n**protected override void OnFundamentalData(FundamentalDataEventArgs fundamentalDataUpdate)**\n\n{% callout type=\"note\" %}\n\nThe NinjaScript code wizards can automatically generate the method syntax for you when creating a new script.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **fundamentalDataUpdate**\n* [FundamentalDataEventArgs](fundamentaldataeventargs) representing the recent change in fundamental data\n\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnFundamentalData(FundamentalDataEventArgs fundamentalDataUpdate)\n{\n    // Print some data to the Output window\n    if (fundamentalDataUpdate.FundamentalDataType == FundamentalDataType.AverageDailyVolume)\n        Print(\"The current ADV is \" + fundamentalDataUpdate.LongValue);\n}\n```\n\n{% callout type=\"note\" %}\n\n1. With [multi-time frame and instrument strategies](multi-time_frame__instruments), OnFundamentalData() will be called for all unique instruments in your strategy. Use the [BarsInProgress](barsinprogress) to filter the OnFundamentalData() method for a specific instrument.\n2. Do not leave an unused OnFundamentalData() method declared in your NinjaScript object. This will unnecessarily attach a data stream to your script which uses unnecessary CPU cycles.\n{% /callout %}"
  },
  {
    "_id": "4fddc49dd5da4074685d84c3ca1f1bd5162e9d6405815fb77b73f149558750dc",
    "_type": "desktopSdkDoc",
    "title": "MarketDataEventArgs",
    "pathName": "marketdataeventargs",
    "parent": "onmarketdata",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents a change in level one market data and is passed as a parameter in the **OnMarketData()** method.\n\n## Methods and Parameters\n\n{% table %}\n\n* Ask\n* Bid\n* Instrument\n* IsReset\n* MarketDataType\n* Price\n* Time\n* ToString()\n* Volume\n\n---\n\n* A **double** value representing the ask price\n* A **double** value representing the bid price\n* A Instrument object representing the instrument of the market data\n* A bool value representing if a UI reset is needed after a manual disconnect. Note: This is only relevant for columns. Whenever this property is true, the UI needs to be reset. Possible values are:\n \t* MarketDataType.Ask\n \t* MarketDataType.Bid\n \t* MarketDataType.DailyHigh\n \t* MarketDataType.DailyLow\n \t* MarketDataType.DailyVolume\n \t* MarketDataType.Last\n \t* MarketDataType.LastClose (prior session close)\n \t* MarketDataType.Opening\n \t* MarketDataType.OpenInterest (supported by IQFeed, Kinetick)\n \t* MarketDataType.Settlement\n* A **double** value representing the price\n* A **DateTime** structure representing the time\n* A string representation of the MarketDataEventArgs object\n* A long value representing volume\n{% /table %}\n\n{% callout type=\"note\" %}\n\nCritical: If used with **TickReplay**, please keep in mind Tick Replay ONLY replays the Last market data event, and only stores the best inside bid/ask price at the time of the last trade event. You can think of this as the equivalent of the bid/ask price at the time a trade was reported. Please also see **Developing for Tick Replay**.\n\n{% /callout %}\n\n{% callout type=\"note\" %}\n\nTips\n\n* Not all connectivity providers support all MarketDataTypes.\n* For an example of how to use IsReset please see **MarketAnalyzerColumns\\AskPrice.cs**.\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnMarketData(MarketDataEventArgs marketDataUpdate)\n{\n    // Print some data to the Output window\n    if (marketDataUpdate.MarketDataType == MarketDataType.Last)\n        Print(\"Last = \" + marketDataUpdate.Price + \" \" + marketDataUpdate.Volume);\n    else if (marketDataUpdate.MarketDataType == MarketDataType.Ask)\n        Print(\"Ask = \" + marketDataUpdate.Price + \" \" + marketDataUpdate.Volume);\n    else if (marketDataUpdate.MarketDataType == MarketDataType.Bid)\n        Print(\"Bid = \" + marketDataUpdate.Price + \" \" + marketDataUpdate.Volume);\n}\n```"
  },
  {
    "_id": "037aac706466c231875e2d5a8d114291f03eda8e982405f850447ff0b56f5b19",
    "_type": "desktopSdkDoc",
    "title": "OnMarketData()",
    "pathName": "onmarketdata",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn event driven method which is called and guaranteed to be in the correct sequence for every change in level one market data for the underlying instrument. **OnMarketData()** can include but is not limited to the bid, ask, last price and volume.\n\n{% callout type=\"note\" %}\n\n1. This is a real-time data stream and can be CPU intensive if your program code is compute intensive (not optimal).\n2. By default, this method is not called on historical data (backtest), however it can be called historically by using [TickReplay](tick_replay).\n3. If used with [TickReplay](tick_replay), please keep in mind Tick Replay ONLY replays the Last market data event, and only stores the best inside bid/ask price at the time of the last trade event. You can think of this as the equivalent of the bid/ask price at the time a trade was reported. As such, historical bid/ask market data events (i.e., bid/ask volume) DO NOT work with Tick Replay. To obtain those values, you need to use a [historical bid/ask series](using_historical_bid_ask_serie) separately from TickReplay through **OnBarUpdate()**. More information can be found under [Developing for Tick Replay](developing_for__tick_replay).\n4. With [multi-time frame and instrument strategies](multi-time_frame__instruments), a subscription will be created on all bars series added in your indicator or strategy (even if the instrument is the same). The market data subscription behavior occurs both in real-time and during [TickReplay](tick_replay) historical.\n5. Do not leave an unused **OnMarketData()** method declared in your NinjaScript object. This will unnecessarily attach a data stream to your strategy which uses unnecessary CPU cycles.\n6. Should you wish to run comparisons against prior values you will need to store and update local variables to track the relevant values.\n7. The **OnMarketData()** method is expected to be called after [OnBarUpdate()](onbarupdate).\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\nYou must override the method in your strategy or indicator with the following syntax.\n\n**protected override void OnMarketData(MarketDataEventArgs marketDataUpdate)**\n\n{% callout type=\"note\" %}\n\nThe NinjaScript code wizards can automatically generate the method syntax for you when creating a new script.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **marketDataUpdate**\n* [MarketDataEventArgs](marketdataeventargs) representing the recent change in market data\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnMarketData(MarketDataEventArgs marketDataUpdate)\n{\n     // Print some data to the Output window\n     if (marketDataUpdate.MarketDataType == MarketDataType.Last) \n           Print(string.Format(\"Last = {0} {1} \", marketDataUpdate.Price, marketDataUpdate.Volume));\n     else if (marketDataUpdate.MarketDataType == MarketDataType.Ask)\n         Print(string.Format(\"Ask = {0} {1} \", marketDataUpdate.Price, marketDataUpdate.Volume));\n     else if (marketDataUpdate.MarketDataType == MarketDataType.Bid)\n         Print(string.Format(\"Bid = {0} {1}\", marketDataUpdate.Price, marketDataUpdate.Volume));\n}\n```"
  },
  {
    "_id": "3da82bf1ac6afc01e1f9245544959b819d0e75afa98eda54c47b94a86afc7005",
    "_type": "desktopSdkDoc",
    "title": "MarketDepthEventArgs",
    "pathName": "marketdeptheventargs",
    "parent": "onmarketdepth",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents a change in level two market data also known as market depth and is passed as a parameter in the **OnMarketDepth()** method.\n\n## Methods and Parameters\n\n{% table %}\n\n* Instrument\n* IsReset\n* MarketDataType\n* MarketMaker\n* Operation\n* Position\n* Price\n* Time\n* ToString()\n* Volume\n\n---\n\n* A **Instrument** object representing the instrument of the market data\n* A bool value representing if a UI reset is needed after a manual disconnect.  \nNote: This is only relevant for columns. Whenever this property is true, the UI needs to be reset.\n* Possible values are:  \n**MarketDataType.Ask**  \n**MarketDataType.Bid**\n* A string representing the market maker id\n* Represents the action you should take when building a level two book.  \nPossible values are:  \n**Operation.Add**  \n**Operation.Update**  \n**Operation.Remove**\n* An **int** value representing the zero based position in the depth ladder.\n* A **double** value representing the price\n* A **DateTime** structure representing the time\n* A string representation of the **MarketDataEventArgs** object\n* A long value representing volume\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnMarketDepth(MarketDepthEventArgs marketDepthUpdate)\n{\n     // Print some data to the Output window\n     if (marketDepthUpdate.MarketDataType == MarketDataType.Ask && marketDepthUpdate.Operation == Operation.Update)\n         Print(\"The most recent ask change is \" + marketDepthUpdate.Price + \" \" + marketDepthUpdate.Volume);\n}\n```\n\n{% callout type=\"note\" %}\n\nTip: For an example of how to use **IsReset** please see \\MarketAnalyzerColumns\\AskPrice.cs\n\n{% /callout %}"
  },
  {
    "_id": "1796e5e550d0281676755ae7a2e3fe6c28507f4f72fee564e4751c2f8a7ef52a",
    "_type": "desktopSdkDoc",
    "title": "OnMarketDepth()",
    "pathName": "onmarketdepth",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn event driven method which is called and guaranteed to be in the correct sequence for every change in level two market data (market depth) for the underlying instrument. The **OnMarketDepth()** method can be used to build your own level two book.\n\n{% table %}\n\n* Notes\n\n---\n\n* 1. This is a real-time data stream and can be CPU intensive if your program code is compute intensive (not optimal)\n* 2. This method is not called on historical data (backtest)\n{% /table %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\nYou must override the method in your strategy or indicator with the following syntax:\n\n**protected override void OnMarketDepth(MarketDepthEventArgs marketDepthUpdate)**\n\n{% callout type=\"note\" %}\n\nThe NinjaScript code wizards can automatically generate the method syntax for you when creating a new script.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n---\n\n* marketDepthUpdate\n* **MarketDepthEventArgs** representing the recent change in market data\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnMarketDepth(MarketDepthEventArgs marketDepthUpdate)\n{\n     // Print some data to the Output window\n     if (marketDepthUpdate.MarketDataType == MarketDataType.Ask && marketDepthUpdate.Operation == Operation.Update)\n         Print(string.Format(\"The most recent ask change is {0} {1}\", marketDepthUpdate.Price, marketDepthUpdate.Volume));\n}\n```\n\n{% callout type=\"note\" %}\n\n* 1. With [multi-time frame and instrument strategies](multi-time_frame__instruments), **OnMarketDepth** will be called for all unique instruments in your strategy. Use the [BarsInProgress](barsinprogress) to filter the **OnMarketDepth()** method for a specific instrument. (BarsInProgress will return the first BarsInProgress series that matches the instrument for the event)\n* 2. Do not leave an unused **OnMarketDepth()** method declared in your NinjaScript object. This will unnecessarily attach a data stream to your strategy which uses unnecessary CPU cycles.\n* 3. Should you wish to run comparisons against prior values you will need to store and update local variables to track the relevant values.\n* 4. With NinjaTrader being multi-threaded, you should not rely on any particular sequence of events like **OnMarketDepth()** always being called before **OnMarketData()** or vice versa.\n{% /table %}"
  },
  {
    "_id": "7ea827ff63e4640e87e79da2f09dd0c4ea5528f2c95c935612a1392e5432c241",
    "_type": "desktopSdkDoc",
    "title": "SetState()",
    "pathName": "setstate",
    "parent": "onstatechange",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nThis method is used for changing the **State** of any running NinjaScript object.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* Attempting to set a State earlier than the current State will be ignored.\n* Calling **SetState()** multiple times will be ignored to prevent the object from erroneously setting states unexpectedly.\n* Setting State to **State.Terminated** is meant as a way to abort the strategy as it is running. Doing this in a Strategy Analyzer backtest will abort the backtest entirely, and no partial backtest results will be shown.\n* After setting **State.Terminated**, you should return from the calling method to help ensure subsequent logic is not processed asynchronously to **OnStateChange()**.\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**SetState(State state)**\n\n{% callout type=\"warning\" %}\n\nThis method should only be called after the **State** reaches **State.DataLoaded**.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **state**\n* The **State** to be set\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // Terminate strategy at 2PM\n   if (ToTime(Time[0]) == 140000)\n   {\n     SetState(State.Terminated);\n     return;\n   }\n}\n```"
  },
  {
    "_id": "4ba69735ca53765ed6a709edb56c6ea236b7193a3b29a6b390c346f0f4340e4e",
    "_type": "desktopSdkDoc",
    "title": "State",
    "pathName": "state",
    "parent": "onstatechange",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nRepresents the current progression of the object as it advances from setup, processing data, to termination. These states can be used for setting up or declaring various resources and properties.\n\n{% callout type=\"note\" %}\n\nMore detailed explanation of various states along with examples can be found in the **OnStateChange()** method section of this help guide. You can also attempt to set a new State using the **SetState()** method.\n\n{% /callout %}\n\n## Property Value\n\nAn enum value representing the current state of the object. Possible values are:\n\n{% table %}\n\n* State\n* Description\n\n---\n\n* **SetDefaults**\n* Default values are set (pushed to UI).\n\n---\n\n* **Configure**\n* User the presses the OK or Apply button.\n\n---\n\n* **Active**\n* Object is configured and is ready to receive instructions.\n\n---\n\n* **DataLoaded**\n* All data series have been loaded.\n\n---\n\n* **Historical**\n* Begins to process historical data.\n\n---\n\n* **Transition**\n* Finished processing historical data.\n\n---\n\n* **Realtime**\n* Begins to process realtime data.\n\n---\n\n* **Terminated**\n* Begins to shut down.\n{% /table %}\n\n## Syntax\n\n**State**\n\n## Examples\n\n### **Understanding the sequence of States**\n\n ```csharp\nprotected override void OnStateChange()\n{\n   Print(DateTime.Now + \": Current State is State.\" + State);\n}\n```\n\n### **Using State to only process real-time data**\n\n```csharp\nprotected override void OnBarUpdate()\n{\n   // only process real-time OnBarUpdate events\n   if (State == State.Historical)\n     return;\n       \n   //rest of logic           \n}\n```"
  },
  {
    "_id": "e6524ae98d2d4fc0f70257cf525b98c5649d091485d8791fb4f1778689e5eae6",
    "_type": "desktopSdkDoc",
    "title": "OnStateChange()",
    "pathName": "onstatechange",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAn event driven method which is called whenever the script enters a new **State**. The **OnStateChange()** method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* Viewing any UI element which lists NinjaScript classes (such as the Indicators or Strategies window, a chart's Chart Style dropdown menu, etc.) will initialize all classes of that Type when it is opened, which causes each script to enter **State.SetDefaults**, even if it is not actively configured or running in any window. It is important to keep this in mind when adding logic within **State.SetDefaults** in **OnStateChange()**, as this logic will be processed each time the script is initialized. For example, opening the Indicators window will trigger **State.SetDefaults** for all indicators in the system, and closing the Indicators window will trigger **State.Terminated** for all Indicators. In addition, disconnecting or connecting to a data provider can cause State transitions for any currently active scripts. Further discussion of this aspect of the state change model can be found via [Understanding the lifecycle of your NinjaScript objects](understanding_the_lifecycle_of).\n* When an indicator is configured on a chart while a Compile is taking place in the NinjaScript Editor, it can appear that the script passes through **State.Terminated**. However, this is the result of a copy of the script being initialized at compile-time, NOT the result of the indicator on the chart being disabled and re-initialized.\n{% /callout %}\n\n## Related Methods and Properties\n\n{% table %}\n\n---\n\n* [SetState()](setstate)\n* Method is used for changing the State of any running NinjaScript object.\n\n---\n\n* [State](state)\n* Represents the current progression of the object as it advances from setup, processing data, to termination.\n\n{% /table %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\nSee example below. The NinjaScript wizards automatically generate the method syntax for you.\n\nPossible states are:\n\n{% table %}\n\n* State Name\n* This state is called when\n* This state is where you should\n\n---\n\n* **State.SetDefaults**\n* SetDefaults is always called when displaying objects in a UI list such as the Indicators dialogue window since temporary objects are created for the purpose of UI display\n* * Keep as lean as possible * Set default values (pushed to UI)\n\n---\n\n* **State.Configure**\n* Configure is called after a user adds an object to the applied list of objects and presses the OK or Apply button. This state is called only once for the life of the object.\n* * Add additional data series via [AddDataSeries()](adddataseries) *Declare custom resources* Override and configure values set by the UI\n\n---\n\n* **State.Active**\n* Active is called once after the object is configured and is ready to process data (DrawingTools could see multiple calls as internally an object for hit testing is cloned)\n* * Used for objects such as [Share Service](share_service) which do not process price series data * Indicate the object is ready to being processing information\n\n---\n\n* **State.DataLoaded**\n* DataLoaded is called only once after all data series have been loaded.\n* * Use for logic that needs to access data related objects like Bars, Instruments, BarsPeriod, TradingHours or instantiating indicators *Notify that all data series have been loaded* Initialize any class level variables (including custom [Series<`t`>](seriest) objects)\n\n---\n\n* **State.Historical**\n* Historical is called once the object begins to process historical data. This state is called once when running an object in real-time. This object is called multiple times when running a backtest optimization and the property [IsInstantiatedOnEachOptimizationIteration](isinstantiatedoneachoptimizationiteration) is true (default behavior)\n* * Notify that the object is processing historical data\n\n---\n\n* **State.Transition**\n* Transition is called once as the object has finished processing historical data but before it starts to process realtime data.\n* * Notify that the indicator or strategy is transitioning to realtime data * Prepare realtime related resources\n\n---\n\n* **State.Realtime**\n* Realtime is called once when the object begins to process realtime data.\n* * Notify that the indicator or strategy is processing realtime data * Execute realtime related logic\n\n---\n\n* **State.Terminated**\n* Terminated is called once when the object terminates.\n* * Notify the object is shutting down * Use to clean up/dispose of resources\n{% /table %}\n\n## Active States vs Data Processing States\n\nAfter **State.Configure**, each type of NinjaScript type has its own state management system which can be classified under two categories:\n\n* Active state: **State.Active**\n\n* Data Processing states: **State.DataLoaded**, **State.Historical**, **State.Transition**, **State.Realtime**\n\nThe table below lists each NinjaScript type and its designed state management system:\n\n{% table %}\n\n* NinjaScript Type\n* State Management System\n\n---\n\n* AddOns*\n* Active state\n\n---\n\n* BarTypes\n* Active state\n\n---\n\n* ChartStyles\n* Active state\n\n---\n\n* DrawingTools\n* Active state\n\n---\n\n* Indicators\n* Data Processing states\n\n---\n\n* ImportTypes\n* Active state\n\n---\n\n* Market Analyzer Columns\n* Data Processing states\n\n---\n\n* OptimizationFitnesses\n* Active state\n\n---\n\n* Optimizers\n* Active state\n\n---\n\n* PerformanceMetrics\n* Active state\n\n---\n\n* ShareServices\n* Active state\n\n---\n\n* Strategies\n* Data Processing states\n\n---\n\n* SuperDOM Columns\n* Active state\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips:\n\n* Resources created in **State.Configure** and not disposed of immediately will be kept and utilized if the NinjaScript object resides in grids (e.g. Strategy tab on Control Center), even if it is not enabled. Try to create resources in **State.Historical** or **State.DataLoaded** instead, if possible.\n* **State.Historical** is called multiple times when running a backtest [optimization](optimize_a_strategy) on a strategy and the property \"[IsInstantiatedOnEachOptimizationIteration](isinstantiatedoneachoptimizationiteration)\" is true (default behavior).\n* Embedded scripts within a calling parent script should not use a different Calculate property since it is already utilizing the Calculate property of the parent script (i.e. the strategy your indicator is called from).\n* Since the parent NinjaScript therefore governs this setting, it should be set to the highest needed setting satisfying all its children.\n* When instantiating indicators in a [Multi-Series script](multi-time_frame__instruments) in **OnStateChange**, the input any hosted indicator is running on should be explicitly stated (since a specific [BarsInProgress](barsinprogress) is not guaranteed)\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.SetDefaults)\n    {\n        // Calculate once at the end of every single bar\n        Calculate = Calculate.OnBarClose;   \n\n        // Add two plots\n        AddPlot(Brushes.Blue, \"Upper\");\n        AddPlot(Brushes.Orange, \"Lower\");\n    }\n    else if (State == State.Configure)\n    { \n        // Adds a 5-minute Bars object to the strategy and is automatically assigned\n        // a Bars object index of 1 since the primary data the strategy is run against\n        // set by the UI takes the index of 0.        \n        AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);     \n    }\n}\n```"
  },
  {
    "_id": "b20acf68fc8aaa8a58b857ebc7e9ed403176894273378405f4338b992d6ef078",
    "_type": "desktopSdkDoc",
    "title": "ActualSessionBegin",
    "pathName": "actualsessionbegin",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nObtains the sessions start date and start time converted to the user's configured Time Zone.\n\n{% callout type=\"note\" %}\n\nIn order to obtain historical ActualSessionBegin information, you must call [GetNextSession](getnextsession) from a stored SessionIterator object.\n\n{% /callout %}\n\n## Property Value\n\nA **DateTime** structure that represents beginning of a trading session.\n\n## Syntax\n\n**SessionIterator.ActualSessionBegin**\n\n## Example\n\n```csharp\nSessionIterator sessionIterator;\n\nprotected override void OnStateChange()\n{\n    if (State == State.Historical)\n    {\n        sessionIterator = new SessionIterator(Bars);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // on new bars session, find the next trading session\n    if (Bars.IsFirstBarOfSession)\n    {\n        // use the current bar time to calculate the next session\n        sessionIterator.GetNextSession(Time[0], true);\n\n        Print(\"The current session start time is \" + sessionIterator.ActualSessionBegin);\n    }\n}\n```"
  },
  {
    "_id": "a337d4015d2d7a56bdafa82010393dd7fad3cb2d3339f8216862d63130b2786e",
    "_type": "desktopSdkDoc",
    "title": "ActualSessionEnd",
    "pathName": "actualsessionend",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nObtains the session's end date and end time converted to the user's configured Time Zone.\n\n{% callout type=\"note\" %}\n\nIn order to obtain historical ActualSessionEnd information, you must call [GetNextSession](getnextsession) from a stored SessionIterator object.\n\n{% /callout %}\n\n## Property Value\n\nA **DateTime** structure that represents end of a trading session.\n\n## Syntax\n\n**SessionIterator.ActualSessionEnd**\n\n## Example\n\n```csharp\nSessionIterator sessionIterator;\n\nprotected override void OnStateChange()\n{\n   if (State == State.Historical)\n   {\n     sessionIterator = new SessionIterator(Bars);\n   }\n}\n\nprotected override void OnBarUpdate()\n{\n   // on new bars session, find the next trading session\n   if (Bars.IsFirstBarOfSession)\n   {\n     // use the current bar time to calculate the next session\n     sessionIterator.GetNextSession(Time[0], true);\n\n     Print(\"The current session end time is \" + sessionIterator.ActualSessionEnd);\n   }\n}\n```"
  },
  {
    "_id": "e217b52cddc5b415e2656b1c7108867e963a4e1d6f196e65ea7fb144b26ef557",
    "_type": "desktopSdkDoc",
    "title": "ActualTradingDayEndLocal",
    "pathName": "actualtradingdayendlocal",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the session's End-Of-Day (EOD) in the user's configured timezone.\n\n{% callout type=\"note\" %}\n\nIn order to obtain historical ActualTradingDayEndLocal information, you must call [GetNextSession](getnextsession) from a stored SessionIterator object.\n\n{% /callout %}\n\n## Property Value\n\nA DateTime structure that represents end of a trading day (EOD).\n\n## Syntax\n\n**SessionIterator.ActualTradingDayEndLocal**\n\n## Example\n\n```csharp\nSessionIterator sessionIterator;\n\nprotected override void OnStateChange()\n{\n    if (State == State.Historical)\n    {\n        sessionIterator = new SessionIterator(Bars);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // on new bars session, find the next trading session\n    if (Bars.IsFirstBarOfSession)\n    {\n        // use the current bar time to calculate the next session\n        sessionIterator.GetNextSession(Time[0], true);\n\n        Print(\"The current session end of day is \" + sessionIterator.ActualTradingDayEndLocal);\n    }\n}\n```"
  },
  {
    "_id": "4d9eeaa0805cf1bbee6688c5c397dcc335dfc32a5e330d490ffa5f7cf5406dec",
    "_type": "desktopSdkDoc",
    "title": "ActualTradingDayExchange",
    "pathName": "actualtradingdayexchange",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nObtains the date of a trading session defined by the exchange.\n\n{% callout type=\"note\" %}\n\n1. In order to obtain historical ActualTradingDayExchange information, you must call [GetNextSession](getnextsession) from a stored SessionIterator object.\n2. The calculated value may differ from the current date as some trading sessions will begin before the actual calendar date changes. For example, the \"CME US Index Futures ETH\" [actual session](accumulation_distribution_adl) started on 3/30/2015 at 5:00PM Central Time, however the actual exchange trading day would be considered 3/31/2015 12:00:00AM.\n{% /callout %}\n\n## Property Value\n\nA DateTime structure that represents the trading day.\n\n## Syntax\n\n**SessionIterator.ActualTradingDayExchange**\n\n## Example\n\n```csharp\nSessionIterator sessionIterator;\n\nprotected override void OnStateChange()\n{\n    if (State == State.Historical)\n    {\n        sessionIterator = new SessionIterator(Bars);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // on new bars session, find the next trading session\n    if (Bars.IsFirstBarOfSession)\n    {\n        // use the current bar time to calculate the next session\n        sessionIterator.GetNextSession(Time[0], true);\n\n        Print(\"The current exchange trading day is \" + sessionIterator.ActualTradingDayExchange);\n    }\n}\n```"
  },
  {
    "_id": "e3936644037078d0d4aa38479e1df288899e090a035b86b6c3f09203473339a4",
    "_type": "desktopSdkDoc",
    "title": "CalculateTradingDay()",
    "pathName": "calculatetradingday",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nCalculates the trading date of the time value passed in as the **timeLocal** argument. This method may need to be used before you can accurately determine various session properties such as [ActualSessionBegin](actualsessionbegin) or [ActualTradingDayEndLocal](source_markdown_files/todo/actualtradingdayendlocal), etc. **CalculateTradingDay()** also checks the local date/time against the exchange's current date/time to ensure that the script is in sync with the exchange's current day.\n\n{% callout type=\"warning\" %}\n\nWarning:  This method is resource intensive and should ONLY be reserved for situations when calculations would be limited to a few specific use cases.\n\n{% /callout %}\n\n## Property Value\n\nThis method does not return a value.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **timeLocal**\n* The DateTime value used to calculate the trading day.\n\n---\n\n* **includesEndTimeStamp**\n* A bool determining if a timestamp of <`n`>:00 should fall into the current session. (e.g., used for time based intraday series such as minute or second).\n{% /table %}\n\n## Syntax\n\n**<`sessioniterator`>.CalculateTradingDay(DateTime timeLocal, bool includesEndTimeStamp)**\n\n## Examples\n\n```csharp\nprotected override void OnDataPoint(Bars bars, double open, double high, double low, double close, DateTime time, long volume, bool isBar, double bid, double ask)\n{\n   // build the bars type session iterator from the bars object provided\n   if (SessionIterator == null)\n     SessionIterator = new SessionIterator(bars);\n \n   // calculate the trading day of the time value provided\n   SessionIterator.CalculateTradingDay(time, false);\n \n   // add a new bar using the sessions exchanges date\n   AddBar(bars, open, high, low, close, SessionIterator.ActualTradingDayExchange, volume);\n}\n```"
  },
  {
    "_id": "3cf2a959738bad345e525c82d421c5e9ffcade705da9f032f441cc3c6c362d2a",
    "_type": "desktopSdkDoc",
    "title": "GetNextSession()",
    "pathName": "getnextsession",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nCalculates the next available session relative to the \"timeLocal\" value used in the method's input.\n\n{% callout type=\"note\" %}\n\nThis method needs to be used before you can accurately determine various session properties such as **ActualSessionBegin** or **ActualTradingDayEndLocal**, etc.\n\n{% /callout %}\n\n## Property Value\n\nA bool value when true indicates the method was able to successfully calculate the next trading session; otherwise false.\n\n{% callout type=\"warning\" %}\n\nThis method is resource intensive and should ONLY be reserved for situations when calculations would be limited to a few specific use cases. For example, calling this method for each bar in the **OnBarUpdate()** method would NOT be recommended.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* timeLocal\n* includesEndTimeStamp\n\n---\n\n* The DateTime value used to calculate the next trading day.\n* A bool determining if a timestamp of **<`n>:00** should fall into the current session. (e.g., used for time based intraday series such as minute or second).\n{% /table %}\n\n## Syntax\n\n**<`sessioniterator>**.GetNextSession(DateTime timeLocal, bool includesEndTimeStamp);\n\n## Examples\n\n### Getting Next Session of the Primary Bars Object\n\n```csharp\nSessionIterator sessionIterator;\nprotected override void OnStateChange()\n{\n    if (State == State.Historical)\n    {\n        sessionIterator = new SessionIterator(Bars);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // on new bars session, find the next trading session\n    if (Bars.IsFirstBarOfSession)\n    {\n        // use the current bar time to calculate the next session\n        sessionIterator.GetNextSession(Time[0], true);\n    }\n\n```\n\n### csharp Getting Next Session of a Secondary Time Series\n\n```csharp\nSessionIterator rthSessionIterator;\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        // add a 1440 minute bar using the RTH hours\n        AddDataSeries(Instrument.FullName, new BarsPeriod { BarsPeriodType = BarsPeriodType.Minute, Value = 1440 }, \"CME US Index Futures RTH\");\n    }\n    else if (State == State.Historical)\n    {\n        // store a session iterator built from the secondary (RTH) bars\n        rthSessionIterator = new SessionIterator(BarsArray[1]);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // on the primary bars session, find the next trading session for the RTH bars\n    if (Bars.IsFirstBarOfSession)\n    {\n        // use the current bar time to calculate the next RTH session\n        rthSessionIterator.GetNextSession(Time[0], true);\n    }\n```"
  },
  {
    "_id": "50e5ff3b93b281b6f8e270378e0b79a90a14232f34556f7359df0fe69329b4df",
    "_type": "desktopSdkDoc",
    "title": "GetTradingDay()",
    "pathName": "gettradingday",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the actual trading date based on the exchange, calculated from a DateTime object passed with the local time. **GetTradingDay()** calls **CalculateTradingDay()** on a custom **SessionIterator** object created by passing in a **Bars** object as an argument.\n\n{% callout type=\"warning\" %}\n\nWarning: This method can ONLY be called when a **SessionIterator** was created with a 'Bars' parameter.\n\n{% /callout %}\n\n## Property Value\n\nA **DateTime** object representing the [ActualTradingDayExchange](actualtradingdayexchange).\n\n## Syntax\n\n**<`sessioniterator`>.GetTradingDay(DateTime timeLocal)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* timeLocal\n* The **DateTime** value used to calculate the next trading day.\n{% /table %}\n\n## Examples\n\n```csharp\n// Declare a new custom SessionIterator\nSessionIterator mySessionIterator;\n\nprotected override void OnStateChange()\n{\n    if (State == State.Historical)\n    {\n        // Instantiate mySessionIterator once in State.Configure\n        mySessionIterator = new SessionIterator(BarsArray[0]);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // Obtain the ActualTradingDayExchange value for mySessionIterator, based on today's date\n    Print(mySessionIterator.GetTradingDay(DateTime.Now).ToString());\n}\n```"
  },
  {
    "_id": "1c9dc0a89fa2510170deca8cdcd78710f5bf48818e4666db963db610d7438332",
    "_type": "desktopSdkDoc",
    "title": "GetTradingDayBeginLocal()",
    "pathName": "gettradingdaybeginlocal",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nConverts the trading day begin time from the exchange timezone to local time, and returns a DateTime object in the local timezone. The **ActualTradingDayExchange** property can be passed into **GetTradingDayBeginLocal()** for a quick timezone conversion.\n\n## Property Value\n\nA DateTime object representing the exchange-based trading day begin time converted to local time.\n\n## Syntax\n\n**<`sessioniterator`>.GetTradingDayBeginLocal(DateTime tradingDayExchange)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* tradingDayExchange\n* The DateTime value used to calculate the trading day.\n{% /table %}\n\n## Examples\n\n```csharp\nprivate SessionIterator sessionIterator;\n\nprotected override void OnStateChange()\n{\n    if (State == State.DataLoaded)\n    {\n        //stores the sessions once bars are ready, but before OnBarUpdate is called\n        sessionIterator = new SessionIterator(Bars);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // Only process strategy logic starting three hours after trading begins at the exchange\n    if (Core.Globals.Now >= sessionIterator.GetTradingDayBeginLocal(sessionIterator.ActualTradingDayExchange).AddHours(3))\n    {\n        // Strategy logic here\n    }\n}\n```"
  },
  {
    "_id": "26ffddf2002ea054e4f73a3c51a4a93658c387f0d73cec711895654c410e917c",
    "_type": "desktopSdkDoc",
    "title": "GetTradingDayEndLocal()",
    "pathName": "gettradingdayendlocal",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nConverts the trading day end time from the exchange timezone to local time, and returns a DateTime object in the local timezone. The **ActualTradingDayExchange** property can be passed into **GetTradingDayEndLocal()** for a quick timezone conversion.\n\n## Property Value\n\nA DateTime object representing the exchange-based trading day end time converted to local time.\n\n## Syntax\n\n**<`sessioniterator`>.GetTradingDayEndLocal(DateTime tradingDayExchange)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* tradingDayExchange\n* The DateTime value used to calculate the trading day.\n{% /table %}\n\n## Examples\n\n```csharp\nprivate SessionIterator sessionIterator;\nprotected override void OnStateChange()\n{\n    if (State == State.DataLoaded)\n    {\n        //stores the sessions once bars are ready, but before OnBarUpdate is called\n        sessionIterator = new SessionIterator(Bars);\n    }\n}\nprotected override void OnBarUpdate()\n{\n    // Only process strategy logic up until three hours prior to the end of the trading day at the exchange\n    if (Core.Globals.Now <= sessionIterator.GetTradingDayEndLocal(sessionIterator.ActualTradingDayExchange).AddHours(-3))\n    {\n        // Strategy logic here\n    }\n}\n```"
  },
  {
    "_id": "c4f9e28ff23ccce021fc3c611a8cb7ee5cadfbc7ee3ea99375fc0e839d611dbb",
    "_type": "desktopSdkDoc",
    "title": "IsInSession()",
    "pathName": "isinsession",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates a specified date is within the bounds of the current session, according to the configured Trading Hours template.\n\n{% callout type=\"note\" %}\n\nAdditionally this method will internally trigger a **GetNextSession()** call to calculate the next available session relative to the \"timeLocal\" value used in the method's input.\n\n{% /callout %}\n\n## Property Value\n\nA bool value when true indicates the specified time is within the current trading session; otherwise false.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **timeLocal**\n* The DateTime value used to calculate the next trading day.\n\n---\n\n* **includesEndTimeStamp**\n* A bool determining if a timestamp of <`n`>:00 should fall into the current session. (e.g., used for time based intraday series such as minute or second).\n\n---\n\n* **isIntraDay**\n* A bool determining if **IsInSession()** considers the time of day (when true) or only the date (when false).\n{% /table %}\n\n## Syntax\n\n**<`sessioniterator`>.IsInSession(DateTime timeLocal, bool includesEndTimeStamp, bool isIntraDay)**\n\n## Examples\n\n```csharp\nprivate SessionIterator sessionIterator;\n\nprotected override void OnStateChange()\n{\n    if (State == State.Historical)\n    {\n        //stores the sessions once bars are ready, but before OnBarUpdate is called\n        sessionIterator = new SessionIterator(Bars);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // Only place an order if the time three hours from now will still be within the current session\n    if (sessionIterator.IsInSession(DateTime.Now.AddHours(3), true, true) /* && additional conditions here */)\n        EnterLongStopMarket(CurrentDayOHL().High[0] + TickSize);\n}\n```"
  },
  {
    "_id": "62e8adf6d0b3198e67216349b585755f2f0c2eadee8d4d4e0265c960204fc90d",
    "_type": "desktopSdkDoc",
    "title": "IsNewSession()",
    "pathName": "isnewsession",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates a specified time is greater than the **ActualSessionEnd** property on the configured Trading Hours template.\n\n## Property Value\n\nA bool value when true indicates the specified time is later than **ActualSessionEnd**; otherwise false.\n\n## Parameters\n\n{% table %}\n\n---\n\n* **time**\n* The DateTime value used to compare\n\n---\n\n* **includesEndTimeStamp**\n* A bool determining if a timestamp of <`n`>:00 should fall into the current session. (e.g., used for time based intraday series such as minute or second).\n{% /table %}\n\n## Syntax\n\n**<`sessioniterator``>.IsNewSession(DateTime time, bool includesEndTimeStamp)**\n\n## Examples\n\n```csharp\nbool takeTrades;\n\nprotected override void OnBarUpdate()\n{\n    // Switch a bool named takeTrades to false when IsNewSession() returns true. \n    if (Bars.SessionIterator.IsNewSession(DateTime.Now, true)) ;\n    {\n        Alert(\"EOS\", Priority.Medium, String.Format(\"New session beginning. Waiting until {0} to begin trading again\"), \" \", 5, Brushes.Black, Brushes.White);\n        takeTrades = false;\n    }\n\n    // Set the bool back to true on the first bar of the new session\n    if (Bars.IsFirstBarOfSession)\n        takeTrades = true;\n}\n```"
  },
  {
    "_id": "1100de9c920203999c13b7fd2f629e3467ac37c0da115dc7e6fe5bb85f6b2406",
    "_type": "desktopSdkDoc",
    "title": "IsTradingDayDefined()",
    "pathName": "istradingdaydefined",
    "parent": "sessioniterator",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates a trading day is defined for a specific date.\n\n## Property Value\n\nA **bool** value when true indicates that the date passed in as an argument is defined as a full or partial trading day in the configured Trading Hours template; otherwise false. Also returns false if the specified date is marked as a full-day exchange holiday.\n\n## Parameters\n\n{% table %}\n\n---\n\n* date\n* The DateTime value representing the date to check\n{% /table %}\n\n## Syntax\n\n**<`sessioniterator>.IsTradingDayDefined(DateTime time);**\n\n## Examples\n\n```csharp\nDateTime thanksGivingDay = new DateTime(2017, 11, 23);\n\n// Determine if the current instrument's exchange is open for trading on Thanksgiving day in 2017\nif(Bars.SessionIterator.IsTradingDayDefined(thanksGivingDay))\n    Print(String.Format(\"{0} will be open for trading on Thanksgiving day, {1}\", Instrument.MasterInstrument.Name, thanksGivingDay.Date));\n```"
  },
  {
    "_id": "f3eb567dc540ced3b0aad8886a2a84ef6d01306293c0ec87569149322a395449",
    "_type": "desktopSdkDoc",
    "title": "SessionIterator",
    "pathName": "sessioniterator",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nAllows you to traverse through various trading hours data elements which apply to a segment of bars.\n\n{% callout type=\"note\" %}\n\nShould you wish to obtain trading hours information for historical bar values, you need to construct and store your own session iterator object based of the desired bars series array.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* bars\n* The **Bars** object used to create the SessionIterator\n{% /table %}\n\n{% callout type=\"warning\" %}\n\nWarning: The properties in this class should NOT be accessed within the **OnStateChange()** method before the State has reached State.DataLoaded.\n\n{% /callout %}\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n* Description\n\n---\n\n* [ActualSessionBegin](actualsessionbegin)\n* Obtains the sessions start day and start time converted to the PC's local time zone\n\n---\n\n* [ActualSessionEnd](actualsessionend)\n* Obtains the sessions end day and end time converted to the PC's local time zone\n\n---\n\n* [ActualTradingDayEndLocal](actualtradingdayendlocal)\n* Returns the sessions End-Of-Day (EOD) in the local timezone\n\n---\n\n* [ActualTradingDayExchange](actualtradingdayexchange)\n* Obtains the date of a session representing the trading date of the exchange\n\n---\n\n* [CalculateTradingDay()](calculatetradingday)\n* Calculates the current trading date of a specified date\n\n---\n\n* [GetNextSession()](getnextsession)\n* Calculates the next available session relative to a specified date\n\n---\n\n* [GetTradingDay()](gettradingday)\n* Returns the actual trading date based on the exchange\n\n---\n\n* [GetTradingDayBeginLocal()](gettradingdaybeginlocal)\n* Converts the trading day begin time from the exchange timezone to local time\n\n---\n\n* [GetTradingDayEndLocal()](gettradingdayendlocal)\n* Converts the trading day end time from the exchange timezone to local time\n\n---\n\n* [IsInSession()](isinsession)\n* Indicates if a specified date is within the bounds of the current session\n\n---\n\n* [IsNewSession()](isnewsession)\n* Indicates if a specified time is greater than the actual session end of the current session\n\n---\n\n* [IsTradingDayDefined()](istradingdaydefined)\n* Indicates if a trading day is defined for a specific date\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: In order to calculate a session information for another multi-instrument or multi-time frame script, you can pass in the desired **BarsArray** array value as the SessionIterator bars object.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprivate SessionIterator sessionIterator;\n\nprotected override void OnStateChange()\n{\n    if (State == State.DataLoaded)\n    {\n        //stores the sessions once bars are ready, but before OnBarUpdate is called\n        sessionIterator = new SessionIterator(Bars);\n    }\n}\n\nprotected override void OnBarUpdate()\n{\n    // on new bars session, find the next trading session\n    if (Bars.IsFirstBarOfSession)\n    {\n        Print(\"Calculating trading day for \" + Time[0]);\n        // use the current bar time to calculate the next session\n        sessionIterator.GetNextSession(Time[0], true);\n\n        // store the desired session information\n        DateTime tradingDay   = sessionIterator.ActualTradingDayExchange;\n        DateTime beginTime    = sessionIterator.ActualSessionBegin;\n        DateTime endTime      = sessionIterator.ActualSessionEnd;\n\n        Print(string.Format(\"The Current Trading Day {0} starts at {1} and ends at {2}\",\n                            tradingDay.ToShortDateString(), beginTime, endTime));\n        // Output:\n        // Calculating trading day from 9/30/2015 4:01:00 PM\n        //The Current Trading Day 10/1/2015 starts at 9/30/2015 4:00:00 PM and ends at 10/1/2015 3:00:00 PM\n    }\n}\n```"
  },
  {
    "_id": "4bc72e4df9a94556c4ef463e80cf469e6b81264cc5f136d79181ad88dc93331f",
    "_type": "desktopSdkDoc",
    "title": "ApplyTo()",
    "pathName": "applyto",
    "parent": "simplefont",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nApplies a custom **SimpleFont** object's properties (family, size, and style) to a [Windows Control](windowscontrol).\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n<simplefont`>.ApplyTo(DependencyObject target)\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* target\n* The [DependencyObject](https://msdn.microsoft.com/en-us/library/system.windows.dependencyobject(v=vs.110).aspx) to apply the SimpleFont object\n{% /table %}\n\n## Examples\n\n```csharp\n// Define the custom button control object\nSystem.Windows.Controls.Button myButton = new System.Windows.Controls.Button\n{\n    Name = \"myButton\",\n    Content = \"Buy\",\n    Foreground = Brushes.White,\n    Background = Brushes.Green,\n};\n\n// Create a custom SimpleFont object and then apply it to the button\nSimpleFont myFont = new SimpleFont(\"Consolas\", 22);\n\nmyFont.ApplyTo(myButton);\n```"
  },
  {
    "_id": "cee9a1625cd00b2e3017e7a870b642c12e98176c87adb06366e8bf6a014f88b5",
    "_type": "desktopSdkDoc",
    "title": "SimpleFont",
    "pathName": "simplefont",
    "parent": "common",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nDefines a particular font configuration.\n\n{% callout type=\"note\" %}\n\nNote: SimpleFont objects are used for various **Drawing** methods, and can be used when defining UI element for Add-ons.\n\n{% /callout %}\n\n## Constructors\n\n{% table %}\n\n---\n\n* **SimpleFont()**\n* Creates a SimpleFont object using a family name of \"Arial\" and a size of \"12\"\n\n---\n\n* **SimpleFont(string familyName, int size)**\n* Creates a SimpleFont object using the specified family name and size\n{% /table %}\n\n## Methods and Properties\n\n{% table %}\n\n---\n\n* **Bold**\n* A bool value determining if the Font is bold style\n\n---\n\n* **Family**\n* A [FontFamily](fontfamily) representing a family of Fonts\n\n---\n\n* **Italic**\n* A bool value determining if the Font is italic style\n\n---\n\n* **Size**\n* A **double** value determining the size of font in WPF units (please see the tip below)\n\n---\n\n* **Typeface**\n* A [Typeface](typeface) used to represent the variation of the font used\n\n---\n\n* **ApplyTo()**\n* Applies a custom [SimpleFont](simplefont) object's properties (family, size, and style) to a [Windows Control](windowscontrol)\n\n---\n\n* **ToDirectWriteTextFormat()**\n* Converts a SimpleFont object to a SharpDX compatible font which can be used for chart rendering.\n{% /table %}\n\n{% callout type=\"note\" %}\n\nThe WPF unit used is the default px one, so device independent pixels. With a default system DPI setting of 96, the physical pixel on the screen would be identical in size, but can vary if a custom DPI is employed. Both should not be confused with the points based font sizing known from other familiar Windows applications like Word, the advantage here is that the non points based size measurement will increase / decrease in size if the system DPI is changed - a more detailed discussion is located [here](https://blogs.msdn.microsoft.com/text/2009/12/11/wpf-text-measurement-units/).\n\n{% /callout %}\n\n## Examples\n\n```csharp\n// create custom Courier New, make it big and bold\nNinjaTrader.Gui.Tools.SimpleFont myFont = new NinjaTrader.Gui.Tools.SimpleFont(\"Courier New\", 12) { Size = 50, Bold = true };\n\nDraw.Text(this, \"myTag\", false, \"Hi There!\", 0, Low[0], 5, Brushes.Blue, myFont, TextAlignment.Center, Brushes.Black, null, 1);\n```"
  },
  {
    "_id": "bf68e6fadb17acd81070c5ab3ca50eac0768ff0b43db35c3731220582f2fad5c",
    "_type": "desktopSdkDoc",
    "title": "GetPreviousTradingDayEnd()",
    "pathName": "getprevioustradingdayend",
    "parent": "tradinghours",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nReturns the end date and time of the previous trading session regarding the time passed in the methods parameters.\n\n## Method Return Value\n\nA **DateTime** structure representing the previous trading days end date and time.\n\n## Syntax\n\n**GetPreviousTradingDayEnd(DateTime timeLocal)**\n\n{% callout type=\"warning\" %}\n\nThis method is resource intensive and should ONLY be reserved for situations when calculations would be limited to a few specific use cases. For example, calling this method for each bar in the **OnBarUpdate()** method would NOT be recommended.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **timeLocal**\n* An **DateTime** structure which is used to calculate the current trading day\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n    if (Bars.IsFirstBarOfSession)\n    {\n        DateTime previousEndDate = TradingHours.GetPreviousTradingDayEnd(Time[0]);\n\n        Print(string.Format(\"The current bars date is {0} - the previous trading session ended on {1}\", Time[0], previousEndDate));\n    }\n    //Output:  The current bars date is 2/18/2015 12:35:00 PM - the previous trading session ended on 2/17/2015 3:15:00 PM\n}\n```"
  },
  {
    "_id": "474c12b01f4f765680ac3bb3e0b670b7ac817c9f717997577cac3f12f1b5013a",
    "_type": "desktopSdkDoc",
    "title": "Holidays",
    "pathName": "holidays",
    "parent": "tradinghours",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of full holidays configured for a Trading Hours template. Holidays are days which fall outside of the regular trading schedule.\n\n{% callout type=\"note\" %}\n\nFor more information please see the \"Understanding trading holidays\" section of the [Using the Trading Hours](using_the_trading_hours_window) window.\n\n{% /callout %}\n\n## Property Value\n\nA **Dictionary** holding a collection of holiday Dates and Descriptions of each holiday.\n\n{% table %}\n\n* Date\n* Description\n\n---\n\n* A **DateTime** representing the date of the trading hours holiday\n* A string which is used to describe the holiday (e.g., Christmas)\n{% /table %}\n\n## Syntax\n\n**TradingHours.Holidays**\n\n## Examples\n\n```csharp\n// Print all holidays included in the Bars object's Trading Hours template\nforeach(KeyValuePair<datetime, string> holiday in TradingHours.Holidays)\n{\n    Print(holiday);\n}\n```"
  },
  {
    "_id": "731696e9af9957f3b6581f3eb18fed43dc099311b0c0a5eca35c58ead7a8957d",
    "_type": "desktopSdkDoc",
    "title": "PartialHolidays",
    "pathName": "partialholidays",
    "parent": "tradinghours",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nA collection of partial holidays which are configured for a Trading Hours template. Holidays are days which fall outside of the normal trading schedule, on which data will be excluded. For more information please see the \"Understanding trading holidays\" section of the [Using the Trading Hours](using_the_trading_hours_window) window.\n\n## Property Value\n\nA **Dictionary** holding a collection of holiday Dates and **PartialHoliday** objects for each partial holiday.\n\n{% table %}\n\n* Date\n* PartialHoliday\n\n---\n\n* A DateTime representing the trading date of the Trading Hours holiday\n* An object containing a DateTime representing the date of the early close or late begin, a description of the partial holiday, and two bool properties, **IsEarlyClose** and **IsLateBegin**\n{% /table %}\n\n## Syntax\n\n**TradingHours.PartialHolidays**\n\n## Examples\n\n```csharp\n// Print all partial holidays included in the Bars object's Trading Hours template\nforeach(KeyValuePair<datetime, partialholiday> holiday in TradingHours.PartialHolidays)\n{\n    Print(holiday);\n}\n```"
  },
  {
    "_id": "480b3f6b39e97b4c0b7dc7e0e8cdd8e2584c2dc43066a207b48f266c5e9e495f",
    "_type": "desktopSdkDoc",
    "title": "TimeZoneInfo",
    "pathName": "timezoneinfo",
    "parent": "tradinghours",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nIndicates a time zone that is configured by a Trading Hours template  \n\n## Property Value\n\nA **TimeZoneInfo** object that represents the time zone for a configured Trading Hours template.\n\n## Syntax\n\n**Bars.TradingHours.TimeZoneInfo**\n\n## Examples\n\n```csharp\n// Print the timezone before printing all sessions\nPrint(String.Format(\"All sessions are in {0}\", Bars.TradingHours.TimeZoneInfo));\n\n// Print details for all sessions in the Trading Hours template\nfor (int i = 0; i < TradingHours.Sessions.Count; i++)\n{\n   Print(String.Format(\"Session {0}: {1} at {2} to {3} at {4}\", i, TradingHours.Sessions[i].BeginDay, TradingHours.Sessions[i].BeginTime,\n     TradingHours.Sessions[i].EndDay, TradingHours.Sessions[i].EndTime));\n}\n```"
  }
]