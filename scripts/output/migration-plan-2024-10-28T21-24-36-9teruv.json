[
  {
    "_id": "b6417ba3bb7de85dcad801493a7dcb26049472f320d7ea2b5ef28e33b92b6639",
    "_type": "desktopSdkDoc",
    "title": "Unmanaged Approach",
    "pathName": "unmanaged_approach",
    "parent": "order_methods",
    "order": 0,
    "status": "ready",
    "section": "references",
    "markdown": "The Unmanaged approach is reserved for VERY EXPERIENCED programmers. In place of the convenience layer that the [Managed](managed_approach) approach offered, the Unmanaged approach instead offers ultimate flexibility in terms of order submission and management. This section will discuss some of the basics of working with Unmanaged order methods.\n\n## Getting started with Unmanaged order methods\n\nTo be able to offer you the flexibility required to achieve more complex order submission techniques, NinjaTrader needs to be able to know if you are going to be using the Unmanaged approach beforehand.\n\nIn the OnStateChange() method designating the [IsUnmanaged](isunmanaged) property as true signifies to NinjaTrader that you will be using the Unmanaged approach. Setting this will effectively prevent any of the signal tracking and internal order handling rules that were present in the Managed approach.\n\n```csharp\nprotected override void OnStateChange()  \n{  \n    if (State == State.SetDefaults)  \n    {  \n        IsUnmanaged = true;  \n    }  \n}\n```\n\nPlease note that you will not be able to mix order methods from the two approaches. When setting [IsUnmanaged](isunmanaged) to true, you can only use Unmanaged order methods in the strategy.\n\n## Working with Unmanaged order methods\n\n## Order Submission\n\nOrder submission with the Unmanaged approach is done solely from a single order method. Parameterizing the [SubmitOrderUnmanaged()](submitorderunmanaged) method differently will determine what kind of order you will be submitting. Please note that these orders are live until cancelled. Should you want to cancel these orders you will need to use the CancelOrder() method or wait till the orders expire due to the strategy's time in force setting.\n\nIn the example below, a buy limit order to enter a long position is working at the bid price provided that the close price of the current bar is greater than the current value of the 20 period simple moving average.\n\n```csharp\nprotected override void OnBarUpdate()  \n{  \n    // Entry condition  \n    if (Close[0] > SMA(20)[0] && entryOrder == null)  \n        entryOrder = SubmitOrderUnmanaged(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentBid(), 0, \"\", \"Long Limit\");  \n}\n```\n\nIt is critical to assign an [Order](order) object to keep track of your order or else you will not be able to identify it in your code later since there is no signal tracking when using Unmanaged order methods. Please be aware of the following information about Order objects:\n\n•An Order object returned from calling an order method is dynamic in that its properties will always reflect the current state of an order\n\n•The property <`Order`>.OrderId is NOT a unique value since it can change throughout an order's lifetime\n\n•To check for equality you can compare Order objects directly\n\n## Order Modification\n\nUnlike the Managed approach where you could modify a working order by calling the entry order method again with your new parameters, the Unmanaged approach requires the utilization of the [ChangeOrder()](managed_changeorder) method. The ChangeOrder() method requires you to have access to the Order object you wish to modify so it is important to hold onto those for any active order you have in your strategy.\n\n```csharp\nprotected override void OnBarUpdate()\n{ \n\t// Raise stop loss to breakeven when you are at least 4 ticks in profit\n\tif (stopOrder != null && stopOrder.StopPrice < Position.AveragePrice && Close[0] >= Position.AveragePrice + 4 * TickSize)\n\t  ChangeOrder(stopOrder, stopOrder.Quantity, 0, Position.AveragePrice); \n}\n```\n\n## Order Cancellation\n\nSimilar to the live until canceled technique from the Managed approach, canceling orders can be done through the [CancelOrder()](unmanaged_cancelorder) method.\n\n```csharp\nprotected override void OnBarUpdate()  \n{  \n    // Cancel entry order if price is moving away from our limit price  \n    if (entryOrder != null && Close[0] < entryOrder.LimitPrice - 4 * TickSize)  \n    {  \n        CancelOrder(entryOrder);  \n   \n        // If the entryOrder Order object is no longer needed I should reset it to null in the OnOrderUpdate() method  \n    }  \n}\n```\n\n## Signal Tracking\n\nSince the Unmanaged approach does not utilize NinjaScript's signal tracking the features associated with it will no longer be relevant. The following properties and their associated concept cannot be used with Unmanaged order methods:\n\n[EntriesPerDirection](entriesperdirection)\n\n[EntryHandling](entryhandling)\n\n[SetOrderQuantity](setorderquantity)\n\nMethods utilizing signal names like [BarsSinceEntryExecution()](barssinceentryexecution) and [BarsSinceExitExecution()](barssinceexitexecution) can still be used though.\n\n## Critical considerations when using Unmanaged order methods\n\n|   |   |\n|---|---|\n|[CancelOrder()](unmanaged_cancelorder)|Cancels a specified order.|\n|[ChangeOrder()](unmanaged_changeorder)|Amends a specified [Order](order).|\n|[IgnoreOverfill](ignoreoverfill)|An [unmanaged order property](unmanaged_approach.md) which defines the behavior of a strategy when an overfill is detected.|\n|[IsUnmanaged](isunmanaged)|Determines if the strategy will be using Unmanaged order methods.|\n|[SubmitOrderUnmanaged()](submitorderunmanaged)|Generates an [Unmanaged](isunmanaged) order.|"
  },
  {
    "_id": "8e7f4ca8350c119830bcc91a0737605d058e6ab960325848de5731581a448da2",
    "_type": "desktopSdkDoc",
    "title": "SetPropertyName()",
    "pathName": "setpropertyname",
    "parent": "bars_type",
    "order": 0,
    "status": "updated",
    "section": "references",
    "markdown": "## Definition\n\nSets a default property name to a custom string to be displayed on the UI.\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\n**SetPropertyName**(string propertyName, string displayName)\n\n## Method Parameters\n\n{% table %}\n\n* propertyName\n* displayName\n\n---\n\n* A string representing the property to be renamed. Possible values include:\n  * UpBrush\n  * DownBrush\n  * BarWidth\n  * Stroke\n  * Stroke2\n  * Value\n  * Value2\n  * BaseBarsPeriodType\n  * BaseBarsPeriodValue\n  * PointAndFigurePriceType\n  * ReversalType\n* A string representing the desired property name\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        Properties.Remove(Properties.Find(\"Stroke\", true));\n        Properties.Remove(Properties.Find(\"Stroke2\", true));\n\n        SetPropertyName(\"UpBrush\", \"AdvanceBar\");\n        SetPropertyName(\"DownBrush\", \"DeclineBar\");\n    }\n}\n```\n\n{% callout type=\"note\" %}\nIf you do not wish to use specific properties accessible via **SetPropertyName()**, you will need to remove them from the list via **Properties.Remove**, as shown in the example above.\n{% /callout %}\n\n```"
  },
  {
    "_id": "05631482d4093f37bba7c6f52e0ad3fbea5c0cd3e96cd358e4cd8f9c90275d3a",
    "_type": "desktopSdkDoc",
    "pathName": "tradinghours",
    "parent": "common",
    "order": 0,
    "status": "ready",
    "section": "references",
    "markdown": "## Definition\n\nRepresents the Trading Hours information returned from the current bars series. The Trading Hours object contains several methods and properties for working with various trading sessions.\n\n{% callout = \"warning\" }\n\nThe properties in this class should NOT be accessed within the [OnStateChange()](onstatechange) method before the State has reached State.DataLoaded\n\n{% /callout }\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n\n* Description\n\n---\n\n* [Get()](tradinghoursget)\n\n* Returns the Trading Hours object for the specified Trading Hours template name\n\n---\n\n* [GetPreviousTradingDayEnd()](getprevioustradingdayend)\n\n* Returns the end date and time of the previous trading session relative to the time passed in the methods parameters.\n\n---\n\n* [Holidays](holidays)\n\n* A collection of full holidays which are configured for a Trading Hours template\n\n---\n\n* [Name](tradinghours_name)\n\n* Indicates the name of the trading hours template applied to the Bars series object.\n\n---\n\n* [PartialHolidays](partialholidays)\n\n* A collection of partial holidays which are configured for a Trading Hours template\n\n---\n\n* [Sessions](tradinghours_sessions)\n\n* A collection of session definitions of the trading hours template.\n\n---\n\n* [TimeZoneInfo](timezoneinfo)\n\n* Indicates a time zone that is configured by a Trading Hour template\n\n---\n\n{% /table %}"
  }
]