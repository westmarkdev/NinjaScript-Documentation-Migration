[
  {
    "_id": "d10bd42b51e974de5f2c56889df841566e62da001d67f1b81bb9bf9895d853ed",
    "_type": "desktopSdkDoc",
    "title": "Entering Calculation Logic",
    "pathName": "entering_calculation_logic6",
    "parent": "advanced_custom_drawing",
    "order": 0,
    "section": "guides",
    "markdown": "## Entering Calculation Logic\n\nThe **OnBarUpdate()** method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a **Bars** object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method called for indicator calculation, and we will calculate the CCI value and set the conditions used to draw the CCI plot within this method.\n\nThe **OnStateChange()** method is called once before any bar data is loaded, and is used to configure the indicator (among other things).\n\n## Initializing the Indicator  \n\nThe code below is automatically generated by the wizard and added to the **OnStateChange()** method, within **State.SetDefaults**. It configures the indicator for one plot and five lines, and sets the parameters entered in the wizard:\n\n```csharp\nAddPlot(Brushes.Orange, \"MyPlot\");\nAddLine(Brushes.DimGray, 200, \"Level 2\");\nAddLine(Brushes.DimGray, 100, \"Level 1\");\nAddLine(Brushes.DimGray, 0, \"Zero Line\");\nAddLine(Brushes.DimGray, -100, \"Level -1\");\nAddLine(Brushes.DimGray, -200, \"Level -2\");\n````\n\nTo change the visual properties of the Zero Line, replace the fourth line in the code above with the line below. This will change the color to black and the line style to \"dash:\"\n\n```csharp\nAddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n```\n\nThe code above uses an alternative method overload (an alternative set of arguments passed in to the **AddLine()** method), in order to pass in a **Stroke** object rather than a **Brush**. With a Stroke, not only can we still specify a Brush, but we have additional options to change the dash style (via **DashStyleHelper**) and the line width. After this change, your configured lines and plots should look like this:\n\n```csharp\nAddPlot(Brushes.Orange, \"MyCCI_Plot\");\nAddLine(Brushes.DimGray, 200, \"Level 2\");\nAddLine(Brushes.DimGray, 100, \"Level 1\");\nAddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\nAddLine(Brushes.DimGray, -100, \"Level -1\");\nAddLine(Brushes.DimGray, -200, \"Level -2\");\n```\n\n## Adding Core Indicator Logic\n\nSince this tutorial is meant to cover custom drawing and manually changing properties within an indicator, we will not go too in-depth into the core calculation logic for this custom CCI. Instead, we will copy and paste the core calculation logic from the **@CCI** indicator already built-in to NinjaTrader.\n\nThe **@CCI** indicator uses an **SMA** object in its calculations. To add this, copy the line below from **@CCI** into your custom CCI, directly below the class declaration:\n\n```csharp\nprivate SMA sma;\n```\n\nNext, copy the following initialization for the **SMA** object into the **OnStateChange()** method, within **State.DataLoaded**:\n\n```csharp\n\nsma = SMA(Typical, Period);\n```\n\nNext, copy the core calculation logic from **@CCI** into the **OnBarUpdate()** method of your custom indicator:\n\n```csharp\nif (CurrentBar == 0)\n   Value[0] = 0;\nelse\n{\n   double mean = 0;\n   double sma0 = sma[0];\n\n   for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n       mean += Math.Abs(Typical[idx] - sma0);\n\n   Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n}\n```\n\nThe code for your **MyCCI** class should now look as follows (in addition to the using statements and class declaration):\n\n```csharp\n\npublic class MyCCI : Indicator\n{\n   private SMA sma;\n\n   protected override void OnStateChange()\n   {\n       if (State == State.SetDefaults)\n       {\n           Description = @\"NinjaScript Custom Drawing Indicator Tutorial\";\n           Name = \"MyCCI\";\n           Calculate = Calculate.OnBarClose;\n           IsOverlay = false;\n           DisplayInDataBox = true;\n           DrawOnPricePanel = true;\n           DrawHorizontalGridLines = true;\n           DrawVerticalGridLines = true;\n           PaintPriceMarkers = true;\n           ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;\n           IsSuspendedWhileInactive = true;\n           Period = 14;\n           AddPlot(Brushes.Orange, \"MyPlot\");\n           AddLine(Brushes.DimGray, 200, \"Level 2\");\n           AddLine(Brushes.DimGray, 100, \"Level 1\");\n           AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n           AddLine(Brushes.DimGray, -100, \"Level -1\");\n           AddLine(Brushes.DimGray, -200, \"Level -2\");\n       }\n       else if (State == State.DataLoaded)\n       {\n           sma = SMA(Typical, Period);\n       }\n   }\n\n   protected override void OnBarUpdate()\n   {\n       if (CurrentBar == 0)\n           Value[0] = 0;\n       else\n       {\n           double mean = 0;\n           double sma0 = sma[0];\n\n           for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n               mean += Math.Abs(Typical[idx] - sma0);\n\n           Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n       }\n   }\n}\n```\n\n## Custom Drawing  \n\nAdd the following code into the **OnBarUpdate()** method, directly beneath the core calculation logic:\n\n```csharp\n\n// if the plot value is greater than 100, paint the plot green at that bar index\nif (Value[0] > 100)\n   PlotBrushes[0][0] = Brushes.Green;\n\n// if the plot value is less than -100, paint the plot red at that bar index\nif (Value[0] < -100)\n   PlotBrushes[0][0] = Brushes.Red;\n\n// if the plot value is between 100 and -100, paint the plot orange at that bar index\nif (Value[0] >= -100 && Value[0] <= 100)\n   PlotBrushes[0][0] = Brushes.Orange;\n```\n\nThis will conditionally change the color of the CCI plot (referenced by **Values[0]**) based on its value. By using **PlotBrushes[0][0]**, we are specifying that we wish to change the color of the first plot in the collection at a specific bar index (the current bar index each time the condition is triggered), and we wish for the plot to remain that color at that index, even if the plot value changes in the future. If instead we wished to change the entire plot color, we could use **Plots[0].Brush**.\n\n**PlotBrushes** holds a collection of brushes used for the various plots in the indicator. In addition to this, there are several other collections that serve similar purposes, which can be used in the same way. Some examples of these collections are below:\n\n{% table %}\n\n* Collection\n\n* Description\n\n---\n\n* [BackBrushes](backbrushes)\n\n* A collection of Brushes used for chart background color at specific bar indexes\n\n---\n\n* [BarBrushes](barbrushes)\n\n* A collection of Brushes used to paint bars at specific indexes\n\n---\n\n* [CandleOutlineBrushes](candleoutlinebrushes)\n\n* A collection of Brushes used to paint candle outlines at specific indexes\n\n---\n\n{% /table %}\n\nNow that everything is in place, your class code should look as below. You are now ready to [compile the indicator](compiling6) and configure it on a chart.\n\n```csharp\n\npublic class MyCCI : Indicator\n{\n   private SMA sma;\n\n   protected override void OnStateChange()\n   {\n       if (State == State.SetDefaults)\n       {\n           Description = @\"NinjaScript Custom Drawing Indicator Tutorial\";\n           Name = \"MyCCI\";\n           Calculate = Calculate.OnBarClose;\n           IsOverlay = false;\n           DisplayInDataBox = true;\n           DrawOnPricePanel = true;\n           DrawHorizontalGridLines = true;\n           DrawVerticalGridLines = true;\n           PaintPriceMarkers = true;\n           ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;\n           IsSuspendedWhileInactive = true;\n           Period = 14;\n           AddPlot(Brushes.Orange, \"MyPlot\");\n           AddLine(Brushes.DimGray, 200, \"Level 2\");\n           AddLine(Brushes.DimGray, 100, \"Level 1\");\n           AddLine(new Stroke(Brushes.Black, DashStyleHelper.Dash, 2), 0, \"Zero Line\");\n           AddLine(Brushes.DimGray, -100, \"Level -1\");\n           AddLine(Brushes.DimGray, -200, \"Level -2\");\n       }\n       else if (State == State.DataLoaded)\n       {\n           sma = SMA(Typical, Period);\n       }\n   }\n\n   protected override void OnBarUpdate()\n   {\n       if (CurrentBar == 0)\n           Value[0] = 0;\n       else\n       {\n           double mean = 0;\n           double sma0 = sma[0];\n\n           for (int idx = Math.Min(CurrentBar, Period - 1); idx >= 0; idx--)\n               mean += Math.Abs(Typical[idx] - sma0);\n\n           Value[0] = (Typical[0] - sma0) / (mean.ApproxCompare(0) == 0 ? 1 : (0.015 * (mean / Math.Min(Period, CurrentBar + 1))));\n       }\n\n       if (Value[0] > 100)\n           PlotBrushes[0][0] = Brushes.Green;\n\n       if (Value[0] < -100)\n           PlotBrushes[0][0] = Brushes.Red;\n\n       if (Value[0] >= -100 && Value[0] <= 100)\n           PlotBrushes[0][0] = Brushes.Orange;\n   }\n\n   #region Properties\n   [NinjaScriptProperty]\n   [Range(1, int.MaxValue)]\n   [Display(Name=\"Period\", Description=\"The CCI Period\", Order=1, GroupName=\"Parameters\")]\n   public int Period\n   { get; set; }\n\n   [Browsable(false)]\n   [XmlIgnore]\n   public Series<double> MyPlot\n   {\n       get { return Values[0]; }\n   }\n   #endregion\n}\n```"
  },
  {
    "_id": "8c84f9e699cb0bc8fe3867009e0a187dfd19929ade75bba2f2541da71c284df6",
    "_type": "desktopSdkDoc",
    "title": "Set Up",
    "pathName": "set_up9",
    "parent": "advanced_custom_drawing",
    "order": 0,
    "section": "guides",
    "markdown": "The first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required **NinjaScript** code that will serve as the foundation for your custom indicator.\n\n1. Within the **NinjaTrader** [Control Center](control_center), select the New menu, then select the **NinjaScript Editor** menu item.\n\n2. Right mouse click the \"Indicators\" folder in the **NinjaScript Explorer** section, then select the New Indicator menu item to open the New Indicator Wizard.\n\n## Defining Indicator Properties and Name  \n\nFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.\n\n![NSTuts1](nstuts1.png)\n\n3. Enter the information as shown above.\n\n4. Click the Next > button.\n\n## Setting Default Properties\n\nThe next page will allow you to set defaults for basic properties related to your indicator, including its **Calculate** and **Overlay** settings. Click the More Properties button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below:\n\n![NSTutorialSetUpNoOverlayOnPrice](https://cdn.sanity.io/images/1hlwceal/production/1e993316eb5a0832cf5e6c12f15dcdb9734b34e6-615x550.png)\n\n## Adding Additional Data\n\nThe next page will allow you to configure one or more additional **Bars** objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.\n\n![NSTutAdditionalDataBlank](https://cdn.sanity.io/images/1hlwceal/production/f38e15eb56590f779e9d6fb7538004dc41f8327e-615x550.png)\n\n## Adding Event Methods\n\nThe next page will allow you to pre-populate certain event methods into the **NinjaScript** code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.\n\n![NSTutAdditionalEventMethodsBlank](https://cdn.sanity.io/images/1hlwceal/production/0912948f7f3cb5158d298a14feb8607b0e8a4bb3-615x550.png)\n\n## Defining Input Parameters\n\nThe next page will allow us to configure user input parameters for the indicator. For our custom **CCI** indicator, we will create a single input parameter which can be changed by users in the Indicators window when applying or editing the indicator. This input parameter will determine the **CCI**'s period. We will select **int** as the Type, since integers are the most efficient native data types to be used for positive whole numbers, like those used to specify a number of bars to look back (a period). We will enter a \"Default\" value of \"14\" for the period, and a \"Min\" value of 1, to ensure that users do not enter zero or lower.\n\n![NSTuts5](https://cdn.sanity.io/images/1hlwceal/production/feacf0a3fc33941e938f45a35f899513088b6614-726x468.png)\n\n1. Clicking the add button on the \"Input Parameters\" page brings up the Input Parameters dialogue.\n\n2. The Input Parameters dialogue can be used to define user inputs.\n\n## Defining Plots and Lines\n\nThe next page will allow us to define plots and static lines for the indicator. For the **CCI**, we will define a single plot, called \"CCI,\" and define five lines to draw in the indicator panel. For each item, first click the add button, then use the Plots and Lines dialogue to configure each item as seen below.\n\n![NSTuts6](https://cdn.sanity.io/images/1hlwceal/production/2c86a08f78f0fb6846506a9aa8077d5af6b79ccf-621x454.png)\n\n1. The add button will allow you to configure plots and lines for the indicator.\n\nAfter this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to [entering calculation logic](entering_calculation_logic6)."
  },
  {
    "_id": "3a488d7807c3586e002f8f88d4b42340c112b5ad1a66e0a1eaec2b421b55e2dd",
    "_type": "desktopSdkDoc",
    "title": "Set Up",
    "pathName": "set_up8",
    "parent": "advanced_custom_plot_colors",
    "order": 0,
    "section": "guides",
    "markdown": "The first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required **NinjaScript** code that will serve as the foundation for your custom indicator.\n\n1. Within the **NinjaTrader** [Control Center](control_center), select the New menu, then select the **NinjaScript Editor** menu item.\n\n2. Right mouse click the \"Indicators\" folder in the **NinjaScript Explorer** section, then select the New Indicator menu item to open the New Indicator Wizard.\n\n## Defining Indicator Properties and Name  \n\nFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.\n\n![CustomROCSetUp1](https://cdn.sanity.io/images/1hlwceal/production/9f6e84a0f31bc0b3e7261a25afd008cbfe99f3c1-615x550.png)\n\n3. Enter the information as shown above.\n\n4. Click the Next > button.\n\n## Setting Default Properties\n\nThe next page will allow you to set defaults for basic properties related to your indicator, including its Calculate and Overlay settings. Click the More Properties button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below and move forward by clicking the Next > button.\n\n![NSTutorialSetUpNoOverlayOnPrice](https://cdn.sanity.io/images/1hlwceal/production/1e993316eb5a0832cf5e6c12f15dcdb9734b34e6-615x550.png)\n\n## Adding Additional Data\n\nThe next page will allow you to configure one or more additional [Bars](bars) objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.\n\n![NSTutAdditionalDataBlank](https://cdn.sanity.io/images/1hlwceal/production/f38e15eb56590f779e9d6fb7538004dc41f8327e-615x550.png)\n\n## Adding Event Methods\n\nThe next page will allow you to pre-populate certain event methods into the **NinjaScript** code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.\n\n![NSTutAdditionalDataBlank](https://cdn.sanity.io/images/1hlwceal/production/0912948f7f3cb5158d298a14feb8607b0e8a4bb3-615x550.png)\n\n## Defining Input Parameters\n\nThe next page will allow us to configure user input parameters for the indicator. For our custom indicator, our eventual goal will be to create a simple plot that follows either above or below the bars based upon the Close price of a specified bar compared to the preceding bar. To allow for the variable selection of a number of bars ago, we will create one input parameter and call it \"Periods.\" This variable will then be used to determine the number of bars used in the plot calculation.\n\n![CustomROCSetUp5](https://cdn.sanity.io/images/1hlwceal/production/d95b3affc590fd9841d453bca89106fed6ca3f26-981x550.png)\n\n1. Clicking the add button on the \"Input Parameters\" page brings up the Input Parameters dialogue.\n\n2. The Input Parameters dialogue can be used to define user inputs.\n\n3. Click the add button again on the \"Input Parameters\" page and enter the information detailed in the Input Parameters dialogue marked 3.\n\nWe specify a default value of 10, which will refer to 10 bars in the calculation. We also specify a minimum value of 1 to ensure that we cannot enter a 0 or negative number for **Periods**.\n\n## Defining Plots and Lines\n\nThe next page will allow us to define plots and static lines for the indicator. For this indicator, we will define 1 line and 2 plots and a line, called \"Zero.\"\n\n![CustomROCSetUp6](https://cdn.sanity.io/images/1hlwceal/production/1191822e8b5f0c82e97138c8b8b474968241b699-934x699.png)\n\n1. Clicking the add button on the \"Plots and Lines\" page brings up the Plots and Lines dialogue.\n\n2. The Plots and Lines dialogue can be used to define the **ZeroLine**.\n\n3. Click the add button again on the \"Plots and Lines\" page and enter the information detailed in the Plots and Lines window marked 3 to add the **AboveZero** plot.\n\n4. Click the add button once more on the \"Plots and Lines\" page and enter the information detailed in the Plots and Lines window marked 4 to add the **BelowZero** plot.\n\nAfter this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to [entering calculation logic](entering_calculation_logic5)."
  },
  {
    "_id": "0543a92182d535db8be6674a2826217c591b3dd93e6b2fd05a8f8b00ffd1d554",
    "_type": "desktopSdkDoc",
    "title": "Compiling",
    "pathName": "compiling2",
    "parent": "beginner_indicator_on_indicator",
    "order": 0,
    "section": "guides",
    "markdown": "## Compiling\n\nThe indicator code is now complete and needs to be compiled. You can compile this indicator from within the **NinjaScript Editor** right mouse button menu \"Compile\" menu or simply press the **F5** key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within **NinjaTrader** directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the **NinjaScript Editor**."
  },
  {
    "_id": "276e3cf497149a9d7ecdad7a7d40ef52268b73809e31f6c5f76e82977f502349",
    "_type": "desktopSdkDoc",
    "title": "Set Up",
    "pathName": "set_up5",
    "parent": "beginner_indicator_on_indicator",
    "order": 0,
    "section": "guides",
    "markdown": "The first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required **NinjaScript** code that will serve as the foundation for your custom indicator.\n\n1. Within the **NinjaTrader** [Control Center](control_center), select the New menu, then select the **NinjaScript Editor** menu item.\n\n2. Right mouse click the \"Indicators\" folder in the **NinjaScript Explorer** section, then select the New Indicator menu item to open the New Indicator Wizard.\n\n## Defining Indicator Properties and Name  \n\nFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.\n\n![IndicatorOnIndicatorSetUp1](https://cdn.sanity.io/images/1hlwceal/production/46719b08d97081144fc7826b2e471ee6bb50d903-615x550.png)\n\n3. Enter the information as shown above.\n\n4. Click the Next > button.\n\n## Setting Default Properties\n\nThe next page will allow you to set defaults for basic properties related to your indicator, including its **Calculate** and **Overlay** settings. Click the More Properties button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below and move forward by clicking the Next > button.\n\n![NSTutorialSetUpNoOverlayOnPrice](https://cdn.sanity.io/images/1hlwceal/production/1e993316eb5a0832cf5e6c12f15dcdb9734b34e6-615x550.png)\n\n## Adding Additional Data\n\nThe next page will allow you to configure one or more additional [Bars](bars) objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.\n\n![NSTutAdditionalDataBlank](https://cdn.sanity.io/images/1hlwceal/production/f38e15eb56590f779e9d6fb7538004dc41f8327e-615x550.png)\n\n## Adding Event Methods\n\nThe next page will allow you to pre-populate certain event methods into the **NinjaScript** code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.\n\n![NSTutAdditionalEventMethodsBlank](https://cdn.sanity.io/images/1hlwceal/production/0912948f7f3cb5158d298a14feb8607b0e8a4bb3-615x550.png)\n\n## Defining Input Parameters\n\nThe next page will allow us to configure user input parameters for the indicator. For our custom indicator, our eventual goal will be to create a simple plot that follows either above or below the bars based upon the **Close** price of a specified bar compared to the preceding bar. To allow for the variable selection of a number of bars ago, we will create one input parameter and call it \"Periods.\" This variable will then be used to determine the number of bars used in the plot calculation.\n\n![IndicatorOnIndicator2](https://cdn.sanity.io/images/1hlwceal/production/2d9740a077b3b5a7333675c3bdd021f183034282-824x550.png)\n\n1. Clicking the add button on the \"Input Parameters\" page brings up the Input Parameters dialogue.\n\n2. The Input Parameters dialogue can be used to define user inputs.\n\nWe specify a default value of 10, which will refer to 10 bars in the calculation. We also specify a minimum value of 1 to ensure that we cannot enter a 0 or negative number for **Periods**.\n\n## Defining Plots and Lines\n\nThe next page will allow us to define plots and static lines for the indicator. For this indicator, we will define a single plot, called \"MyPlot.\"\n\n![NSTutAddPlotMyPlot](https://cdn.sanity.io/images/1hlwceal/production/db66f5150095029d38aff9ac601e91d2865d2b03-783x550.png)\n\n1. Clicking the add button on the \"Plots and Lines\" page brings up the Plots and Lines dialogue.\n\n2. The Plots and Lines dialogue can be used to define the plot.\n\nAfter this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to [entering calculation logic](entering_calculation_logic2)."
  },
  {
    "_id": "4eaa5d1550886541d21889d6245e64479dc647ce2a46eb007575c14b8011f05e",
    "_type": "desktopSdkDoc",
    "title": "Set Up",
    "pathName": "set_up4",
    "parent": "beginner_using_price_variables",
    "order": 0,
    "section": "guides",
    "markdown": "The first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required **NinjaScript** code that will serve as the foundation for your custom indicator.\n\n1. Within the **NinjaTrader** [Control Center](control_center), select the New menu, then select the **NinjaScript Editor** menu item.\n\n2. Right mouse click the \"Indicators\" folder in the **NinjaScript Explorer** section, then select the New Indicator menu item to open the New Indicator Wizard.\n\n## Defining Indicator Properties and Name  \n\nFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.\n\n![PriceVariableTutorialSetUp1](https://cdn.sanity.io/images/1hlwceal/production/3c41ff76c1c2cd8559bf2bbcd799737fffe03dee-615x550.png)\n\n3. Enter the information as shown above.\n\n4. Click the Next > button.\n\n## Setting Default Properties\n\nThe next page will allow you to set defaults for basic properties related to your indicator, including its Calculate and Overlay settings. Click the More Properties button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below and move forward by clicking the Next > button.\n\n![NSTutorialSetUpNoOverlayOnPrice](https://cdn.sanity.io/images/1hlwceal/production/1e993316eb5a0832cf5e6c12f15dcdb9734b34e6-615x550.png)\n\n## Adding Additional Data\n\nThe next page will allow you to configure one or more additional [Bars](bars) objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.\n\n![NSTutAdditionalDataBlank](https://cdn.sanity.io/images/1hlwceal/production/f38e15eb56590f779e9d6fb7538004dc41f8327e-615x550.png)\n\n## Adding Event Methods\n\nThe next page will allow you to pre-populate certain event methods into the **NinjaScript** code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.\n\n![NSTutAdditionalEventMethodsBlank](https://cdn.sanity.io/images/1hlwceal/production/0912948f7f3cb5158d298a14feb8607b0e8a4bb3-615x550.png)\n\n## Defining Input Parameters\n\nThe next page will allow us to configure user input parameters for the indicator. For our custom indicator, our eventual goal will be to create a simple plot that follows either above or below the bars based upon the Close price of a specified bar compared to the preceding bar. To allow for the variable selection of a number of bars ago, we will create one input parameter and call it \"BarsAgo.\" This variable will then be used in place of a number when specifying which bar's Close price to use for the indicator's condition.\n\n![PriceVariableTutorialSetUp4](https://cdn.sanity.io/images/1hlwceal/production/3d1e4f3f9941b010d03e83a4231c6e89e445c253-837x550.png)\n\n1. Clicking the add button on the \"Input Parameters\" page brings up the Input Parameters dialogue.\n\n2. The Input Parameters dialogue can be used to define user inputs.\n\nWe specify a default value of 0, which will refer to \"zero bars ago,\" or the current bar. We also specify a minimum value of 0 to ensure that we cannot enter a negative number for **BarsAgo**.\n\n## Defining Plots and Lines\n\nThe next page will allow us to define plots and static lines for the indicator. For this indicator, we will define a single plot, called \"MyPlot.\"\n\n![NSTutAddPlotMyPlot](https://cdn.sanity.io/images/1hlwceal/production/db66f5150095029d38aff9ac601e91d2865d2b03-783x550.png)\n\n1. Clicking the add button on the \"Plots and Lines\" page brings up the Plots and Lines dialogue.\n\n2. The Plots and Lines dialogue can be used to define the plot.\n\nAfter this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to [entering calculation logic](entering_calculation_logic)."
  },
  {
    "_id": "d02c8d4a9adcf30c2f447bcc3fc5255585cdfc18a8698fd57c316a6a03d76206",
    "_type": "desktopSdkDoc",
    "title": "Compiling",
    "pathName": "compiling3",
    "parent": "intermediate_your_own_sma",
    "order": 0,
    "section": "guides",
    "markdown": "The indicator code is now complete and needs to be compiled. You can compile this indicator from within the **NinjaScript Editor** right mouse button menu \"Compile\" menu or simply press the **F5** key. It is important to understand that this process makes the indicator ready for real-time use and will run natively within **NinjaTrader** directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the **NinjaScript Editor**."
  },
  {
    "_id": "53da07c14d71fb63c2005a282a9830dd30890ebd0de3a84619acfa4dee752946",
    "_type": "desktopSdkDoc",
    "title": "Set Up",
    "pathName": "set_up6",
    "parent": "intermediate_your_own_sma",
    "order": 0,
    "section": "guides",
    "markdown": "The first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required **NinjaScript** code that will serve as the foundation for your custom indicator.\n\n1. Within the **NinjaTrader** [Control Center](control_center), select the New menu, then select the **NinjaScript Editor** menu item.\n\n2. Right mouse click the \"Indicators\" folder in the **NinjaScript Explorer** section, then select the New Indicator menu item to open the New Indicator Wizard.\n\n## Defining Indicator Properties and Name  \n\nFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.\n\n![YourOwnSMASetUp1](https://cdn.sanity.io/images/1hlwceal/production/74d76e6d6a5ce0345464802b8246925b6b4d7fe1-615x550.png)\n\n3. Enter the information as shown above.\n\n4. Click the Next > button.\n\n## Setting Default Properties\n\nThe next page will allow you to set defaults for basic properties related to your indicator, including its **Calculate** and **Overlay** settings. Click the More Properties button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below and move forward by clicking the Next > button.\n\n![NSTutSetUpOverlayOnPrice](https://cdn.sanity.io/images/1hlwceal/production/82d8e65c10ad9c43b81bd5be71a7f3ab7dc684e4-615x550.png)\n\n## Adding Additional Data\n\nThe next page will allow you to configure one or more additional [Bars](bars) objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.\n\n![NSTutAdditionalDataBlank](https://cdn.sanity.io/images/1hlwceal/production/f38e15eb56590f779e9d6fb7538004dc41f8327e-615x550.png)\n\n## Adding Event Methods\n\nThe next page will allow you to pre-populate certain event methods into the **NinjaScript** code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.\n\n![NSTutAdditionalEventMethodsBlank](https://cdn.sanity.io/images/1hlwceal/production/0912948f7f3cb5158d298a14feb8607b0e8a4bb3-615x550.png)\n\n## Defining Input Parameters\n\nThe next page will allow us to configure user input parameters for the indicator. For our custom indicator, our eventual goal will be to create a simple plot that follows either above or below the bars based upon the **Close** price of a specified bar compared to the preceding bar. To allow for the variable selection of a number of bars ago, we will create one input parameter and call it \"Periods.\" This variable will then be used to determine the number of bars used in the plot calculation.\n\n![YourOwnSMASetUp3](https://cdn.sanity.io/images/1hlwceal/production/35d59c61709ee4fa7ce6171711133c4319f995a7-828x550.png)\n\n1. Clicking the add button on the \"Input Parameters\" page brings up the Input Parameters dialogue.\n\n2. The Input Parameters dialogue can be used to define user inputs.\n\nWe specify a default value of 10, which will refer to 10 bars in the calculation. We also specify a minimum value of 1 to ensure that we cannot enter a 0 or negative number for **Periods**.\n\n## Defining Plots and Lines\n\nThe next page will allow us to define plots and static lines for the indicator. For this indicator, we will define a single plot, called \"MyPlot.\"\n\n![NSTutAddPlotMyPlot](https://cdn.sanity.io/images/1hlwceal/production/db66f5150095029d38aff9ac601e91d2865d2b03-783x550.png)\n\n1. Clicking the add button on the \"Plots and Lines\" page brings up the Plots and Lines dialogue.\n\n2. The Plots and Lines dialogue can be used to define the plot.\n\nAfter this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to [entering calculation logic](entering_calculation_logic3)."
  },
  {
    "_id": "6588c8757b2138b2fb27f5d43f5fcb4f015bbd2116ec50d9a8397212081ea9a3",
    "_type": "desktopSdkDoc",
    "title": "Set Up",
    "pathName": "set_up7",
    "parent": "intermediate_historical_custom_series",
    "order": 0,
    "section": "guides",
    "markdown": "The first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required **NinjaScript** code that will serve as the foundation for your custom indicator.\n\n1. Within the **NinjaTrader** [Control Center](control_center), select the New menu, then select the **NinjaScript Editor** menu item.\n\n2. Right mouse click the \"Indicators\" folder in the **NinjaScript Explorer** section, then select the **New Indicator** menu item to open the New Indicator Wizard.\n\n## Defining Indicator Properties and Name  \n\nFirst you will define your indicator's name and several indicator properties. Begin by clicking the Next > button on the first page of the wizard to view the page shown below.\n\n![CustomSeriesSetUp1](https://cdn.sanity.io/images/1hlwceal/production/6aebc07c31b7a22bcd384ec458273f9eeb0f9c3d-615x550.png)\n\n3. Enter the information as shown above.\n\n4. Click the Next > button.\n\n## Setting Default Properties\n\nThe next page will allow you to set defaults for basic properties related to your indicator, including its **Calculate** and **Overlay** settings. Click the **More Properties** button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below and move forward by clicking the Next > button.\n\n![NSTutorialSetUpNoOverlayOnPrice](https://cdn.sanity.io/images/1hlwceal/production/1e993316eb5a0832cf5e6c12f15dcdb9734b34e6-615x550.png)\n\n## Adding Additional Data\n\nThe next page will allow you to configure one or more additional [Bars](bars) objects for use by the indicator. For our purposes, we will leave this page blank and move forward by clicking the Next > button.\n\n![https://cdn.sanity.io/images/1hlwceal/production/f7eb211825f13b2fb72f4d2858047d78142582b5-773x550.png](https://cdn.sanity.io/images/1hlwceal/production/f7eb211825f13b2fb72f4d2858047d78142582b5-773x550.png)\n\n1. Here we will click the arrow or the bold **Custom Series** text to be able to use the wizard to add our custom **Series`<t>`** object.\n\n2. Once the menu is expanded, we can click the add button to add a **Series`<t>`**.\n\n3. We will then enter the information above, and select **Double** as the variable type for the **Series`<t>`**.\n\n## Adding Event Methods\n\nThe next page will allow you to pre-populate certain event methods into the **NinjaScript** code generated by the wizard. For our purposes, we will leave all of the checkboxes corresponding to different event methods unchecked, and will move on by clicking the Next > button.\n\n![NSTutAdditionalDataBlank](https://cdn.sanity.io/images/1hlwceal/production/f38e15eb56590f779e9d6fb7538004dc41f8327e-615x550.png)\n\n## Defining Input Parameters\n\nThe next page will allow us to configure user input parameters for the indicator. For our custom indicator, our eventual goal will be to create a simple plot that follows either above or below the bars based upon the **Close** price of a specified bar compared to the preceding bar. To allow for the variable selection of a number of bars ago, we will create one input parameter and call it \"Periods.\" This variable will then be used to determine the number of bars used in the plot calculation.\n\n![CustomSeriesSetUp4](https://cdn.sanity.io/images/1hlwceal/production/6fd68f77222ef876e784c8f717666924aa61388f-814x550.png)\n\n1. Clicking the add button on the \"Input Parameters\" page brings up the **Input Parameters** dialogue.\n\n2. The **Input Parameters** dialogue can be used to define user inputs.\n\nWe specify a default value of 10, which will refer to 10 bars in the calculation. We also specify a minimum value of 1 to ensure that we cannot enter a 0 or negative number for **Periods**.\n\n## Defining Plots and Lines\n\nThe next page will allow us to define plots and static lines for the indicator. For this indicator, we will define a single plot, called \"MyPlot.\"\n\n![NSTutAddPlotMyPlot](https://cdn.sanity.io/images/1hlwceal/production/db66f5150095029d38aff9ac601e91d2865d2b03-783x550.png)\n\n1. Clicking the add button on the \"Plots and Lines\" page brings up the **Plots and Lines** dialogue.\n\n2. The **Plots and Lines** dialogue can be used to define the plot.\n\nAfter this, click the Finish button, and the Indicator Wizard will generate a basic code structure implementing the parameters that you have set. You are now ready to move on to [entering calculation logic](entering_calculation_logic4)."
  },
  {
    "_id": "0244c14acd94b610c8f735027b63d17b1d306f023bd3c49a251bab9dcff7e5ae",
    "_type": "desktopSdkDoc",
    "title": "Intermediate - Your own SMA",
    "pathName": "intermediate_your_own_sma",
    "parent": "developing_indicators",
    "order": 0,
    "section": "guides",
    "markdown": "## Your Own SMA Overview\n\nIn this intermediate level tutorial we are going to build a simple moving average indicator. This indicator will show you how to use the **for** loop and a single case **if** statement.\n\n* [Set Up](set_up6)\n* [Entering Calculation Logic](entering_calculation_logic3)\n* [Compiling](compiling3)\n* [Using](using3)"
  },
  {
    "_id": "46318fe56f4f1234d3382faec49ce1786f4572cc60021dab83e70f680f1ba792",
    "_type": "desktopSdkDoc",
    "title": "Compiling",
    "pathName": "compiling7",
    "parent": "developing_strategies",
    "order": 0,
    "section": "guides",
    "markdown": "## Compiling\n\nThe strategy code is now complete and needs to be compiled.\n\n* If you completed this tutorial via the **Strategy Wizard**, simply follow the wizard instructions to the end at which time the strategy will compile.\n\n* If you self coded this tutorial you can compile this strategy from within the **NinjaScript Editor** right mouse button menu \"**Compile**\" menu or simply press the **F5** key.\n\nIt is important to understand that this process makes the strategy ready for real-time use and will run natively within **NinjaTrader** directly. It does not run interpreted as many other applications do. This provides you with the highest performance possible. If there are any errors reported during compiling, the error messages will be displayed at the bottom of the **NinjaScript Editor**."
  },
  {
    "_id": "39d9a9b71d73ae30db5ecf35a879635d8271e76f94b6cee94e83001cffbb99cd",
    "_type": "desktopSdkDoc",
    "title": "Set Up",
    "pathName": "set_up10",
    "parent": "developing_strategies",
    "order": 0,
    "section": "guides",
    "markdown": "The first step in creating a custom strategy is to use the custom **Strategy Builder**. The builder provides two options:\n\n* Allow you to create a functional strategy without any programming\n* Generate the required **NinjaScript** code that will serve as the foundation for your custom strategy for further coding\n\n1. Within the **NinjaTrader Control Center** window select the  **New Strategy Builder...** menu\n2. Press the \"Next\" button\n\n![SimpleMACrossoverSetUp1](https://cdn.sanity.io/images/1hlwceal/production/dce1c1b17cc7352e039c73eaa19a5c43d7e65929-825x550.png)\n\n3. Enter the information as shown above\n4. Press the \"Next\" button\n\n## Setting Default Properties\n\nThe next page will allow you to set defaults for basic properties related to your strategy, including its **Calculate** and **EntryHandling** settings. Click the **More Properties** button to expose additional properties. For this tutorial, we will not change any basic properties' defaults, and instead will leave them all set to the values shown below:\n\n![SimpleMACrossoverSetUp2](https://cdn.sanity.io/images/1hlwceal/production/20868680bc0fc7897fdd3019d7e099ea94456167-825x550.png)\n\n## Adding Additional Data\n\nThe next page will allow you to configure one or more additional **Bars** objects for use by the strategy. For our purposes, we will leave this page blank and move forward by clicking the \"Next\" button.\n\n![SimpleMACrossoverSetUp3](https://cdn.sanity.io/images/1hlwceal/production/e2ea156b62d5d9eeb7fba476d6c9315546a29aed-825x550.png)\n\n## Defining Input Parameters\n\nBelow you will define your strategy's input parameters. These are any input parameters that can be changed by the user when running or backtesting a strategy. If your strategy does not require any parameters leave the \"Name\" fields blank.\n\n![SimpleMACrossoverSetUp4](https://cdn.sanity.io/images/1hlwceal/production/d14fbb30c09eac83b955a90f2ccf4f0e258cda4a-825x550.png)\n\n1. Click the add button to add a property\n2. Add input parameters into the newly created **Input Parameters** window and click Ok once the input parameter is set up\n\n![SimpleMACrossoverSetUp5](https://cdn.sanity.io/images/1hlwceal/production/c3a9a38bf7d2275497c3cc4e2407e8281b4f42f3-825x550.png)\n\n5. Add the inputs as per the image above\n6. Press the \"Next\" button\n\n## Defining Conditions and Actions\n\nBelow you can define conditions that trigger user-defined actions such as placing orders, drawing on a chart, or creating an alert.\n\nNotice how there are two buttons on the screen below:\n\n* **View Code...** - Pressing this button loads the strategy code in the **NinjaScript Editor** for viewing purposes only. This is a great approach if you are new to programming or you want to see how the strategy wizard dynamically generates the correct script code on the fly.\n* **Unlock Code** - Pressing this button loads the strategy code in the **NinjaScript** editor for further manual editing. Once this button is pressed, you can NOT go back to the Wizard for strategy construction and editing.\n\n![SimpleMACrossoverSetUp6](https://cdn.sanity.io/images/1hlwceal/production/4ff4dc0cdd7a6e799b628e165c31443e7e3adc63-825x550.png)\n\nIf you want to proceed with this tutorial through **self programming** continue here after pressing the \"Unlock Code\" button.\n\nIf you want to proceed with this tutorial through **using the Strategy Builder** please click here."
  },
  {
    "_id": "2a7057188c4534a7a0766ea040ec6e6e6b3e48fbc6dddad0e8af7b34d7af0bdc",
    "_type": "desktopSdkDoc",
    "title": "Set Up",
    "pathName": "set_up11",
    "parent": "developing_strategies",
    "order": 0,
    "section": "guides",
    "markdown": "Our first tutorial covered using the [Strategy Builder](strategy_builder) to create simple NinjaScript strategies or to build the framework needed for a more complex strategy.\n\nThis tutorial will cover another approach, using the NinjaScript [Editor](editor) and [New Strategy Wizard](ninjascript_wizard.md).\n\n1. Within the NinjaTrader Control Center window select the New NinjaScript  Editor... menu item\n\n![NSTutControlCenter](https://cdn.sanity.io/images/1hlwceal/production/8150193e4ec71f9a2bb38478c05a043e422718b4-789x233.png)\n\n![NSTutControlCenter2](https://cdn.sanity.io/images/1hlwceal/production/48fc2ba8b3e79c7858048f1243b6795a5258f4e6-201x203.png)\n\n2. Click the \"+\" tab in the lower left, and select New Strategy to open a New Strategy Wizard\n\n![RSIwithStopAndTargetSetUp1](https://cdn.sanity.io/images/1hlwceal/production/cbebb0736cd4d31e6494e82e7590e7361c94d5f1-713x524.png)\n\n3. Enter the information as shown below\n\n4. Press the \"Next >\" button until we are at the Inputs and Parameters page\n\n![RSIwithStopAndTargetSetUp2](https://cdn.sanity.io/images/1hlwceal/production/c4fdbaafd8ef6a12778a6d998832a01f1f2b59de-755x550.png)\n\n## Defining Input Parameters\n\nBelow you will define your strategy's input parameters. These are any input parameters that can be changed by the user when running or backtesting a strategy. If your strategy does not require any parameters leave the \"Name\" fields blank.\n\n5. Click the add button to create a User Input Parameter (See item 1 in the screenshot below)\n\n6. Fill out the Input Parameters window and click OK to create the input parameter (See item 2 in the screenshot below)\n\n![RSIwithStopAndTargetSetUp3](https://cdn.sanity.io/images/1hlwceal/production/5a3dc07a01f873fab1cb1a96376bb8d0b5d55dc6-756x550.png)\n\n7. Add the inputs as per the image below\n\n![RSIwithStopAndTargetSetUp4](https://cdn.sanity.io/images/1hlwceal/production/3b1ab9dcf45980dbe31d394741b8341c375e1515-755x550.png)\n\n8. Press the \"Generate\" button to generate the code in the NinjaScript Editor.\n\nYou are now ready to continue to the [Entering Strategy Logic](entering_strategy_logic) page of this tutorial."
  },
  {
    "_id": "fef3e6c716dd0c8b595877b84cfca557a1c9229c52baf72d6b12639a4080edef",
    "_type": "desktopSdkDoc",
    "title": "Developing Indicators",
    "pathName": "developing_indicators",
    "parent": "educational_resources",
    "order": 0,
    "section": "guides",
    "markdown": "Indicators are the building blocks of any automated trading system. NinjaScript allows you to develop custom indicators quickly. A few key points are:\n\n* Custom indicators are compiled and run natively within the NinjaTrader application, providing the highest performance possible\n* Indicator values are calculated at the current bar, which ensures that you do not accidentally include future data in your calculations\n* You can retain calculations between bar updates\n* You can retain and share calculation values between bar updates and across indicators\n\nCustom indicator development follows a logical progression.\n\n## Wizard\n\nThe wizard allows you to define your overall indicator parameters which include name, properties, inputs, plots and oscillator lines. The wizard will then generate the necessary NinjaScript code and open up the NinjaScript [Editor](ninjascript_editor_overview).\n\n## OnStateChange() Method\n\nThe [OnStateChange()](onstatechange) method is called once before any initial calculation triggered by an update bar event. This method is used to configure the indicators plots, lines and properties. The wizard will generate the required NinjaScript code for this method for most cases.\n\n## OnBarUpdate() Method\n\nThe [OnBarUpdate()](onbarupdate) method is called with either with each incoming tick or on the close of each bar, depending on how you deploy the indicator at run time. Your core indicator calculation logic is contained within this method.\n\n## Debug\n\nThe NinjaScript Editor will perform both syntax and semantic checks and list any errors at the bottom of the window. If there are logic problems with your indicator, they will be listed in the [Log tab](log_tab2) of the NinjaScript [Control Center](control_center) during run time. You can use the **Print()** method within your script to help debug your code. Output will be sent to the NinjaScript Output window.\n\n## Compilation\n\nOnce the coding effort is completed, you must then compile the indicator (several second process) directly from the NinjaScript Editor.\n\n## Usage\n\nThe completed indicator is now available through any window that can use an indicator, such as a [Chart](charts).\n\n## Tutorial Descriptions\n\nAll internal NinjaTrader indicators come with full source code and can be viewed within the NinjaScript Editor. Please review the tutorials within this section for detailed walk throughs of custom indicator development.\n\n{% table %}\n\n* Level\n\n* Description\n\n---\n\n* [Level 1](beginner_using_price_variables.md) - Demonstrating the use of price variables\n\n---\n\n* [Level 2](beginner_indicator_on_indicator.md) - Demonstrating the use of indicator on indicator\n\n---\n\n* [Level 3](intermediate_your_own_sma.md) - Demonstrating the use of a \"for\" loop to build a simple moving average indicator\n\n---\n\n* [Level 4](intermediate_historical_custom_series.md) - Demonstrating the use of Indicator Series objects to retain historical custom calculations data series\n\n---\n\n* [Level 5](advanced_custom_plot_colors.md) - Demonstrating the use of custom plot coloring based on threshold values\n\n---\n\n* [Level 6](docs/guides/Educational%20Resources/Developing%20Indicators/advanced_custom_drawing) - Demonstrating the use of custom of drawing using bar color, back color and line colors\n\n---\n\n{% /table %}"
  },
  {
    "_id": "c1b56f31607ac240bd667acdf579042923eed4ec17fd80b5f5c08a4dd6ec3ef3",
    "_type": "desktopSdkDoc",
    "title": "TraceOrders",
    "pathName": "traceorders2",
    "parent": "tips",
    "order": 0,
    "section": "guides",
    "markdown": "[TraceOrders](traceorders) is a useful property when debugging the behavior of your orders. With the use of this property, you can track orders placed, amended, and canceled. The traces displayed in the NinjaScript Output window or if used, in the **OnOrderTrace** Override in the script where this was set. This will provide meaningful information for diagnosis when NinjaTrader ignores, changes or cancels orders when various strategy order methods are called.\n\nTo enable **TraceOrders**, add this line into the **OnStateChange()** method in the state SetDefaults of your NinjaScript strategy:\n\n```csharp\nprotected override void OnStateChange()\n{\n     if (State == State.SetDefaults)\n     {\n         TraceOrders = true;\n     }\n}\n```\n\nTrace output examples:\n\n{% callout type=\"note\" %}\n\nThis trace is outputted when we place an entry order. It tells us all the pertaining properties of our order as well as the time it was submitted.\n\n{% /callout %}\n\n```plaintext\nEntered internal **SubmitOrderManaged()** method at 6/2/2015 8:42:00 AM: BarsInProgress=0 Action=Buy OrderType=Market Quantity=1 LimitPrice=0 StopPrice=0 SignalName='market order' FromEntrySignal=''\n```\n\n{% callout type=\"note\" %}\n\nThis trace tells us that a previously submitted order was modified instead of submitting a completely new order.\n\n{% /callout %}\n\n```plaintext\nAmended open order at 6/2/2015 11:39:00 AM: BarsInProgress=0 Action=Buy OrderType=Limit Quantity=1 LimitPrice=130.41 StopPrice=0 SignalName='long order to be resubmitted' FromEntrySignal=''\n```\n\n{% callout type=\"note\" %}\n\nThis trace provides the reason why our Limit order was ignored.\n\n{% /callout %}\n\n```plaintext\nIgnored **SubmitOrderManaged()** method at 6/2/2015 12:55:00 PM: BarsInProgress=0 Action=Buy OrderType=Limit Quantity=1 LimitPrice=129.92 StopPrice=0 SignalName='long order to be resubmitted' FromEntrySignal='' Reason='Exceeded entry signals limit based on EntryHandling and EntriesPerDirection properties'\n```\n\n{% callout type=\"note\" %}\n\nThis trace tells us that our Limit order was canceled because it had expired.\n\n{% /callout %}\n\n```plaintext\nCancelled expired order: BarsInProgress=0, orderId='NT-00123-118' account='Sim101' name='long order to be resubmitted' orderState=Working instrument='AAPL' orderAction=Buy orderType='Limit' limitPrice=130.3 stopPrice=0 quantity=1 tif=Gtc oco='' filled=0 averageFillPrice=0 id=-1 gtd='2099-12-01'\n```\n\nA new concept in NinjaTrader 8 is the [OnOrderTrace](onordertrace) override method.\n\nThis method prevents **TraceOrders** from printing the traces directly to the output window but instead sends this information to the **OnOrderTrace** override where you can do logic or format the trace how you would like and then print only what you need to see.\n\n```csharp\nprotected override void OnOrderTrace(DateTime timestamp, string message)\n{\n     Print(string.Format(\"{0} {1}\", timestamp, message));\n}\n```\n\nThese examples illustrate the most common traces you will run across. They are mostly useful in determining the reason your orders are not submitted or cancelled. **TraceOrders** will only show you what is happening under the hood when you submit orders, but it will not tell you what happens after the order is submitted. To determine the behavior of your orders after submission you will need to look into your NinjaTrader trace logs. You can view those either through the \"Log\" tab on the \"Control Center\" or from the trace folder in My Documents\\NinjaTrader 8\\trace\\.\n\nFor more information on how to debug your NinjaScript please review the [Debugging](debugging_your_ninjascript_cod) tip."
  },
  {
    "_id": "0611995407b28f708e05ae1516c431ad4c2bd02b9b32fa9196eaf87b613d0dd5",
    "_type": "desktopSdkDoc",
    "title": "AtmStrategyCreate()",
    "pathName": "atmstrategycreate",
    "parent": "atm_strategy_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nSubmits an entry order that will execute a specified ATM Strategy.\n\n{% callout type=\"note\" %}\n\nPlease review the section on using [ATM Strategies](using_atm_strategies). This method is NOT backtestable and will NOT execute on historical data. See the [AtmStrategyCancelEntryOrder()](atmstrategycancelentryorder) to cancel an entry order. See the [AtmStrategyChangeEntryOrder()](atmstrategychangeentryorder) to change the price of the entry order. The ATM Strategy will be created asyncronous on the hosting NinjaScripts UI Thread, a callback is provided solely to check when the ATM Strategy is started on that thread - accessing for example price data in that outside OnBarUpdate() context is not possible. Please see the SampleATMStrategy build into NinjaTrader for example usage.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value\n\n## Syntax\n\n**AtmStrategyCreate(OrderAction action, OrderType orderType, double limitPrice, double stopPrice, TimeInForce timeInForce, string orderId, string strategyTemplateName, string atmStrategyId, Action<ErrorCode, string> callback)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* action\n\n* Sets if the entry order is a buy or sell order. Possible values are: OrderAction.Buy, OrderAction.Sell\n\n---\n\n* orderType\n\n* Sets the order type of the entry order. Possible values are: OrderType.Limit, OrderType.Market, OrderType.MIT, OrderType.StopMarket, OrderType.StopLimit\n\n---\n\n* limitPrice\n\n* The limit price of the order\n\n---\n\n* stopPrice\n\n* The stop price of the order\n\n---\n\n* timeInForce\n\n* Sets the time in force of the entry order. Possible values are: TimeInForce.Day, TimeInForce.Gtc\n\n---\n\n* orderId\n\n* The unique identifier for the entry order\n\n---\n\n* strategyTemplateName\n\n* Specifies which strategy template will be used\n\n---\n\n* atmStrategyId\n\n* The unique identifier for the ATM strategy\n\n---\n\n* callback\n\n* The callback action is used to check that the ATM Strategy is successfully started\n\n---\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTip: Unlike NinjaScript Strategy orders (both [managed](managed_approach) and [unmanaged](unmanaged_approach)), ATM strategies generated by the AtmStrategyCreate() method can then be managed manually by any order entry window such as the SuperDOM or within your NinjaScript strategy.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprivate string atmStrategyId;\nprivate string atmStrategyOrderId;\nprivate bool   isAtmStrategyCreated = false;\n\nprotected override void OnBarUpdate()\n{\n   if (State < State.Realtime)\n       return;\n\n   if (Close[0] > SMA(20)[0])\n   {\n       atmStrategyId = GetAtmStrategyUniqueId();\n       atmStrategyOrderId = GetAtmStrategyUniqueId();\n\n       AtmStrategyCreate(OrderAction.Buy, OrderType.Market, 0, 0, TimeInForce.Day,\n           atmStrategyOrderId, \"MyTemplate\", atmStrategyId, (atmCallbackErrorCode, atmCallbackId) => {\n\n           // checks that the call back is returned for the current atmStrategyId stored\n           if (atmCallbackId == atmStrategyId)\n           {\n               // check the atm call back for any error codes\n               if (atmCallbackErrorCode == ErrorCode.NoError)\n               {\n                   // if no error, set private bool to true to indicate the atm strategy is created\n                   isAtmStrategyCreated = true;\n               }\n           }\n       });\n   }\n\n   if(isAtmStrategyCreated)\n   {\n       // atm logic\n   }\n\n   else if(!isAtmStrategyCreated)\n   {\n       // custom handling for a failed atm Strategy\n   }\n}\n```"
  },
  {
    "_id": "5dd81f4378860509b8d15276116b0ba02ac55bc39af965b69c507cdc6ff0b66d",
    "_type": "desktopSdkDoc",
    "title": "OnExecutionUpdate()",
    "pathName": "onexecutionupdate",
    "parent": "strategy",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nAn event driven method which is called on an incoming execution of an order managed by a strategy. An execution is another name for a fill of an order.\n\n* An order can generate multiple executions (partial fills)\n* **OnExecutionUpdate** is typically called after [**OnOrderUpdate()**](onorderupdate)\n* Only orders which have been submitted and managed by the strategy will call **OnExecutionUpdate()**\n* Executions drive the strategy [**Position**](position) object, which is updated when this method is called\n\n{% callout type=\"note\" %}\n\n* Programming in this environment is reserved for the more [advanced user](advanced_order_handling). If you are for example looking to protect a strategy managed position with a basic stop and target, then the [**Set() methods**](managed_approach) would be more convenient.\n* When connected to the Playback connection, it is possible for **OnExecutionUpdate()** to trigger in the middle of a call to **OnBarUpdate()**. The Sim101 account adds a simulated random delay for processing execution events, but the Playback connection triggers executions immediately, for the sake of consistency in backtesting. Because of this, **OnExecutionUpdate()** can appear to be triggered earlier than it would in live trading, or when simulation trading on a live connection.\n* Please also review [**Multi-Thread Considerations for NinjaScript**](multi_threading_consideration_for_ninjascript).\n* Its best practice to only work with the passed by value parameters and not reference parameters. This insures that you process each change of the underlying state.\n* Rithmic and Interactive Brokers Users: When using a NinjaScript strategy it is best practice to only work with passed by value data from **OnExecutionUpdate()**. Instances of multiple fills at the same time for the same instrument might result in an incorrect **OnPositionUpdate**, as sequence of events are not guaranteed due to provider API design.\n{% /table %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax\n\nYou must override the method in your strategy with the following syntax:\n\n**protected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity, MarketPosition marketPosition, string orderId, DateTime time)**\n\n## Parameters\n\n{% table %}\n\n---\n\n* **execution**\n* An [**Execution**](execution) object passed by reference representing the execution\n\n---\n\n* **executionId**\n* A **string** value representing the execution id\n\n---\n\n* **price**\n* A **double** value representing the execution price\n\n---\n\n* **quantity**\n* An **int** value representing the execution quantity\n\n---\n\n* **marketPosition**\n* A [**MarketPosition**](position_marketposition) object representing the position of the execution. Possible values are:\n  * **MarketPosition.Long**\n  * **MarketPosition.Short**\n\n---\n\n* **orderId**\n* A string representing the order id\n\n---\n\n* **time**\n* A [**DateTime**](http://msdn.microsoft.com/en-us/library/system.datetime.aspx) value representing the time of the execution\n\n{% /table %}\n\n## Examples\n\n{% callout type=\"note\" %}\n\n**OnExecutionUpdate** Example (See [**SampleOnOrderUpdate**](using_onorderupdate_and_onexec) for complete example)\n{% /callout %}\n\n```csharp\nprivate Order entryOrder = null; // This variable holds an object representing our entry order\nprivate Order stopOrder = null; // This variable holds an object representing our stop loss order\nprivate Order targetOrder = null; // This variable holds an object representing our profit target order\nprivate int sumFilled = 0; // This variable tracks the quantities of each execution making up the entry order\n\nprotected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity, MarketPosition marketPosition, string orderId, DateTime time)\n{\n    /* We advise monitoring OnExecutionUpdate() to trigger submission of stop/target orders instead of OnOrderUpdate() since OnExecution() is called after OnOrderUpdate()\n    which ensures your strategy has received the execution which is used for internal signal tracking. */\n    if (entryOrder != null && entryOrder == execution.Order)\n    {\n        if (execution.Order.OrderState == OrderState.Filled || execution.Order.OrderState == OrderState.PartFilled || (execution.Order.OrderState == OrderState.Cancelled && execution.Order.Filled > 0))\n        {\n            // We sum the quantities of each execution making up the entry order\n            sumFilled += execution.Quantity;\n\n            // Submit exit orders for partial fills\n            if (execution.Order.OrderState == OrderState.PartFilled)\n            {\n                stopOrder = ExitLongStopMarket(0, true, execution.Order.Filled, execution.Order.AverageFillPrice - 4 * TickSize, \"MyStop\", \"MyEntry\");\n                targetOrder = ExitLongLimit(0, true, execution.Order.Filled, execution.Order.AverageFillPrice + 8 * TickSize, \"MyTarget\", \"MyEntry\");\n            }\n            // Update our exit order quantities once orderstate turns to filled and we have seen execution quantities match order quantities\n            else if (execution.Order.OrderState == OrderState.Filled && sumFilled == execution.Order.Filled)\n            {\n                // Stop-Loss order for OrderState.Filled\n                stopOrder = ExitLongStopMarket(0, true, execution.Order.Filled, execution.Order.AverageFillPrice - 4 * TickSize, \"MyStop\", \"MyEntry\");\n                targetOrder = ExitLongLimit(0, true, execution.Order.Filled, execution.Order.AverageFillPrice + 8 * TickSize, \"MyTarget\", \"MyEntry\");\n            }\n\n            // Resets the entryOrder object and the sumFilled counter to null / 0 after the order has been filled\n            if (execution.Order.OrderState != OrderState.PartFilled && sumFilled == execution.Order.Filled)\n            {\n                entryOrder = null;\n                sumFilled = 0;\n            }\n        }\n    }\n\n    // Reset our stop order and target orders' Order objects after our position is closed. (1st Entry)\n    if ((stopOrder != null && stopOrder == execution.Order) || (targetOrder != null && targetOrder == execution.Order))\n    {\n        if (execution.Order.OrderState == OrderState.Filled || execution.Order.OrderState == OrderState.PartFilled)\n        {\n            stopOrder = null;\n            targetOrder = null;\n        }\n    }\n}\n```\n\n## Additional Reference Samples\n\nAdditional reference code samples are available in the NinjaScript Educational Resources section of our support forum."
  },
  {
    "_id": "15531df6faad272f6f42911ad532ead5a1f38c661583908404b2eee553a9a21d",
    "_type": "desktopSdkDoc",
    "title": "ExitLong()",
    "pathName": "exitlong",
    "parent": "managed_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGenerates a sell market order to exit a long position.\n\n## Method Return Value\n\nAn **Order** read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the [Advanced Order Handling](advanced_order_handling) section.\n\n## Syntax  \n\n**ExitLong()**\n\n**ExitLong(int quantity)**\n\n**ExitLong(string fromEntrySignal)**\n\n**ExitLong(string signalName, string fromEntrySignal)**\n\n**ExitLong(int quantity, string signalName, string fromEntrySignal)**\n\nThe following method variation is for experienced programmers who fully understand [Advanced Order Handling](advanced_order_handling) concepts:\n\n**ExitLong(int barsInProgressIndex, int quantity, string signalName, string fromEntrySignal)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* signalName\n\n* User defined signal name identifying the order generated. Max 50 characters.\n\n---\n\n* fromEntrySignal\n\n* The entry signal name. This ties the exit to the entry and exits the position quantity represented by the actual entry. Note: Using an empty string will attach the exit order to all entries.\n\n---\n\n* quantity\n\n* Entry order quantity.\n\n---\n\n* barsInProgressIndex\n\n* The index of the Bars object the order is to be submitted against. Used to determine what instrument the order is submitted for. See the [BarsInProgress](barsinprogress) property.\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n{\n     if (CurrentBar < 20)\n         return;\n\n     // Only enter if at least 10 bars has passed since our last entry\n     if ((BarsSinceEntryExecution() > 10 || BarsSinceEntryExecution() == -1) && CrossAbove(SMA(10), SMA(20), 1))\n         EnterLong(\"SMA Cross Entry\");\n\n     // Exits position\n     if (CrossBelow(SMA(10), SMA(20), 1))\n         ExitLong();\n}\n```\n\n## Tips (also see [Overview](managed_approach))\n\n* This method is ignored if a long position does not exist.\n* It is helpful to provide a signal name if your strategy has multiple exit points to help identify your exits on a chart.\n* You can tie an exit to an entry by providing the entry signal name in the parameter \"fromEntrySignal\".\n* If you do not specify a quantity the entire position is exited rendering your strategy flat.\n* If you do not specify a \"fromEntrySignal\" parameter the entire position is exited rendering your strategy flat."
  },
  {
    "_id": "0e09f03516d12701cccaf585eb2503e7d379097641ea871c90289b7de1fb77ec",
    "_type": "desktopSdkDoc",
    "title": "ExitShortMIT()",
    "pathName": "exitshortmit",
    "parent": "managed_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGenerates a buy to cover MIT order to exit a short position.\n\n## Method Return Value\n\nAn **Order** read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the [Advanced Order Handling](advanced_order_handling) section.\n\n## Syntax  \n\n**ExitShortMIT(double stopPrice)**\n\n**ExitShortMIT(int quantity, double stopPrice)**\n\n**ExitShortMIT(double stopPrice, string fromEntrySignal)**\n\n**ExitShortMIT(double stopPrice, string signalName, string fromEntrySignal)**\n\n**ExitShortMIT(int quantity, double stopPrice, string signalName, string fromEntrySignal)**\n\nThe following method variation is for experienced programmers who fully understand [Advanced Order Handling](advanced_order_handling) concepts:\n\n**ExitShortMIT(int barsInProgressIndex, bool isLiveUntilCancelled, int quantity, double stopPrice, string signalName, string fromEntrySignal)**\n\n## Parameters\n\n{% table %}\n\n* signalName\n* User defined signal name identifying the order generated. Max 50 characters.\n\n---\n\n* fromEntrySignal\n* The entry signal name. This ties the exit to the entry and exits the position quantity represented by the actual entry. Note: Using an empty string will attach the exit order to all entries.\n\n---\n\n* stopPrice\n* The stop price of the order.\n\n---\n\n* quantity\n* Entry order quantity.\n\n---\n\n* isLiveUntilCancelled\n* The order will NOT expire at the end of a bar but instead remain live until the **CancelOrder()** method is called or its time in force is reached.\n\n---\n\n* barsInProgressIndex\n* The index of the Bars object the order is to be submitted against. Used to determine what instrument the order is submitted for. See the **BarsInProgress** property.\n{% /table %}\n\n## Examples\n\n```csharp\nprivate double stopPrice = 0;\n\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 20)\n        return;\n\n    // Only enter if at least 10 bars has passed since our last entry\n    if ((BarsSinceEntryExecution() > 10 || BarsSinceEntryExecution() == -1) && CrossBelow(SMA(10), SMA(20), 1))\n    {\n        EnterShort(\"SMA Cross Entry\");\n        stopPrice = Low[0];\n    }\n\n    // Exits position\n    ExitShortMIT(stopPrice);\n}\n```\n\n## Tips (also see [Overview](managed_approach))\n\n* This method is ignored if a short position does not exist.\n* It is helpful to provide a signal name if your strategy has multiple exit points to help identify your exits on a chart.\n* You can tie an exit to an entry by providing the entry signal name in the parameter \"fromEntrySignal\".\n* If you do not specify a quantity the entire position is exited rendering your strategy flat.\n* If you do not specify a \"fromEntrySignal\" parameter the entire position is exited rendering your strategy flat."
  },
  {
    "_id": "26703207491dcaae46516dd695ca2270ec917193e2daf7d0bba620d1b8342124",
    "_type": "desktopSdkDoc",
    "title": "ExitShortStopLimit()",
    "pathName": "exitshortstoplimit",
    "parent": "managed_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGenerates a buy to cover stop limit order to exit a short position.\n\n## Method Return Value\n\nAn **Order** read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the [Advanced Order Handling](advanced_order_handling) section.\n\n## Syntax  \n\n**ExitShortStopLimit(double limitPrice, double stopPrice)**  \n**ExitShortStopLimit(int quantity, double limitPrice, double stopPrice)**  \n**ExitShortStopLimit(double limitPrice, double stopPrice, string fromEntrySignal)**  \n**ExitShortStopLimit(double limitPrice, double stopPrice, string signalName, string fromEntrySignal)**  \n**ExitShortStopLimit(int quantity, double limitPrice, double stopPrice, string signalName, string fromEntrySignal)**  \n\nThe following method variation is for experienced programmers who fully understand [Advanced Order Handling](advanced_order_handling) concepts:\n\n**ExitShortStopLimit**(int barsInProgressIndex, bool isLiveUntilCancelled, int quantity, double limitPrice, double stopPrice, string signalName, string fromEntrySignal)\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* signalName\n\n* User defined signal name identifying the order generated. Max 50 characters.\n\n---\n\n* fromEntrySignal\n\n* The entry signal name. This ties the exit to the entry and exits the position quantity represented by the actual entry. Note: Using an empty string will attach the exit order to all entries.\n\n---\n\n* limitPrice\n\n* The limit price of the order\n\n---\n\n* stopPrice\n\n* The stop price of the order.\n\n---\n\n* quantity\n\n* Entry order quantity.\n\n---\n\n* isLiveUntilCancelled\n\n* The order will NOT expire at the end of a bar but instead remain live until the **CancelOrder()** method is called or its time in force is reached.\n\n---\n\n* barsInProgressIndex\n\n* The index of the Bars object the order is to be submitted against. Used to determine what instrument the order is submitted for. See the [BarsInProgress](barsinprogress) property.\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\nprivate double stopPrice = 0;\n\nprotected override void OnBarUpdate()\n{\n    if (CurrentBar < 20)\n        return;\n\n    // Only enter if at least 10 bars has passed since our last entry\n    if ((BarsSinceEntryExecution() > 10 || BarsSinceEntryExecution() == -1) && CrossBelow(SMA(10), SMA(20), 1))\n    {\n        EnterShort(\"SMA Cross Entry\");\n        stopPrice = Low[0] + 5 * TickSize;\n    }\n\n    // Exits position\n    ExitShortStopLimit(stopPrice + (10 * TickSize), stopPrice);\n}\n```\n\n## Tips (also see [Overview](managed_approach))\n\n* This method is ignored if a short position does not exist.\n* It is helpful to provide a signal name if your strategy has multiple exit points to help identify your exits on a chart.\n* You can tie an exit to an entry by providing the entry signal name in the parameter \"fromEntrySignal\".\n* If you do not specify a quantity the entire position is exited rendering your strategy flat.\n* If you do not specify a \"fromEntrySignal\" parameter the entire position is exited rendering your strategy flat."
  },
  {
    "_id": "dd4d0b10f71ae127e40e4b669b6622d439d3dd3916057d338de13951eabd6eaf",
    "_type": "desktopSdkDoc",
    "title": "SetParabolicStop()",
    "pathName": "setparabolicstop",
    "parent": "managed_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGenerates a parabolic type trail stop order with the signal name **Parabolic stop** to exit a position. Parabolic stops are amended on a bar update basis, so dependent upon the [Calculate](calculate) setting of the parent strategy. Parabolic stop orders are real working orders (unless simulated is specified in which case the stop order is locally simulated and submitted as market once triggered) submitted immediately to the market upon receiving an execution from an entry order.\n\nAlthough logic wise very similar, this technique works different from the [ParablicSAR](parabolic_sar) indicator. The indicator will provide trailing stop levels 'always in the market' assuming a constant market position switch, either long or short (reversing). The **SetParabolicStop()** method in contrast will apply the same parabolic trailing technique sensitive to price acceleration to the custom strategy entry signal / position it is associated with.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* The **SetParabolicStop()** method can NOT be used concurrently with the [SetStopLoss()](setstoploss) or [SetTrailStop()](settrailstop) method for the same position, if any of methods are called for the same position (fromEntrySignal) the [SetStopLoss()](setstoploss) will always take precedence. You can however, use all three methods in the same strategy if they reference different signal names.\n* Parabolic stop orders are submitted in real-time on incoming executions from entry orders.\n* Since they are submitted upon receiving an execution, the **Set** method should be called prior to submitting the associated entry order to ensure an initial level is set.\n* A strategy will either generate a trail stop order for each partial fill of an entry order or one order for all fills. See additional information under the [Strategies](options_strategies) tab of the Options dialog window.\n* If a [profit target](setprofittarget) order is generated in addition to a trail stop order, they are submitted as OCO (one cancels other).\n* Parabolic stop orders are submitted as stop-market orders.\n* A parabolic stop order is automatically canceled if the managing position is closed by another strategy generated exit order.\n* Should you have multiple Bars objects of the same instrument while using **SetParabolicStop()** in your strategy, you should only submit orders for this instrument to the first Bars context of that instrument. This is to ensure your order logic is processed correctly and any necessary order amendments are done properly.\n* Parabolic stop orders are modified based on the strategies 'Calculate' settings. In the case of 'Calculate' on bar close, when the bar closes the parabolic stop order modification will occur using the closing price of the bar as the reference price to apply the trail offset. Subsequently if the open price of the next bar is significantly higher or lower than the current close price then there is a possibility that the calculated parabolic stop price is now an invalid stop price. This is a risk with modifying any stop order closer to the current market price since any modification above/below the current price would be rejected.\n{% /callout %}\n\n## Syntax\n\n**SetParabolicStop(CalculationMode mode, double value)**\n\n**SetParabolicStop(string fromEntrySignal, CalculationMode mode, double value, bool isSimulatedStop, double acceleration, double accelerationMax, double accelerationStep)**\n\n{% callout type=\"warning\" %}\n\n* This method CANNOT be called from the [OnStateChange()](onstatechange) method during State.SetDefaults.\n* CalculationMode.Price is irrelevant for trail stops. Attempting to use this mode will log a message and the stop order be ignored. Please use [SetStopLoss()](setstoploss) for this mode instead.\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **mode**\n* Determines the manner in which the value parameter is calculated. Possible values are:\n  * **CalculationMode.Currency**: Initial PnL away from average entry. Calculated by the dollar per tick value for the order quantity used. When this mode is used, [StopTargetHandling](stoptargethandling) will automatically be set to ByStrategyPosition. The Stop loss will then continue to update following each parabolic step.\n  * **CalculationMode.Percent**: Percentage away from the average entry, based on the average entry price.\n  * **CalculationMode.Pips**: Pips away from average entry.\n  * **CalculationMode.Ticks**: Ticks away from entry average entry.\n  * Please note in percentage calculation mode a value of 1 is equal to 100%, a value of 0.1 is equal to 10%, and a value of 0.01 will be 1%.\n\n---\n\n* **isSimulatedStop**\n* If true, will simulate the stop order and submit as market once triggered.\n\n---\n\n* **value**\n* The value the trail stop order is offset from the position entry price.\n\n---\n\n* **fromEntrySignal**\n* The entry signal name. This ties the trail stop exit to the entry and exits the position quantity represented by the actual entry. Using an empty string will attach the exit order to all entries.\n\n---\n\n* **acceleration**\n* Sets the acceleration value.\n\n---\n\n* **accelerationMax**\n* Sets the maximum acceleration value.\n\n---\n\n* **accelerationStep**\n* Sets the step value used to increment acceleration value.\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips (also see [Overview](managed_approach)):\n\n* It is suggested to call this method from within the strategy [OnStateChange()](onstatechange) method if your stop loss price/offset is static.\n* You may call this method from within the strategy [OnBarUpdate()](onbarupdate) method should you wish to dynamically change the stop loss price while in an open position.\n* Should you call this method to dynamically change the stop loss price in the strategy [OnBarUpdate()](onbarupdate) method, you should always reset the stop loss price / offset value when your strategy is flat otherwise, the last price/offset value set will be used to generate your stop loss order on your next open position.\n* The signal name generated internally by this method is **Parabolic stop** which can be used with various methods such as [BarsSinceExitExecution()](barssinceexitexecution), or other order concepts which rely on identifying a signal name.\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n     if (State == State.Configure)\n     {\n         // Sets a parabolic stop using default acceleration (0.02), accelerationMax (0.2), accelerationStep (0.02) settings and a floor value of 12 ticks\n         SetParabolicStop(CalculationMode.Ticks, 12);\n\n         // Sets a parabolic stop of with a currency floor of 500 \n         SetParabolicStop(\"MyLongEntry\", CalculationMode.Currency, 500, false, 0.03, 0.3, 0.01);\n     }\n}\n```"
  },
  {
    "_id": "85681d2cc4f92a7660f5a2fecbc54aad5d220757849ee9162db3e6fe5492ba92",
    "_type": "desktopSdkDoc",
    "title": "SetProfitTarget()",
    "pathName": "setprofittarget",
    "parent": "managed_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGenerates a profit target order with the signal name **Profit target** to exit a position. Profit target orders are real working orders submitted immediately to the market upon receiving an execution from an entry order.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* Profit target orders are submitted in real-time on incoming executions from entry orders.\n* Since they are submitted upon receiving an execution, the Set method should be called prior to submitting the associated entry order to ensure an initial level is set.\n* A strategy will either generate a target order for each partial fill of an entry order or one order for all fills. See additional information under the [Strategies](options_strategies) tab of the Options dialog window.\n* If a **stop loss** or **trail stop** order is generated in addition to a profit target order, they are submitted as OCO (one cancels other).\n* A profit target order is automatically cancelled if the managing position is closed by another strategy generated exit order.\n* Should you have multiple Bars objects of the same instrument while using **SetProfitTarget()** in your strategy, you should only submit orders for this instrument to the first Bars context of that instrument. This is to ensure your order logic is processed correctly and any necessary order amendments are done properly.\n{% /callout %}\n\n## Syntax\n\n**SetProfitTarget(CalculationMode mode, double value)**\n\n**SetProfitTarget(CalculationMode mode, double value, bool isMIT)**\n\n**SetProfitTarget(string fromEntrySignal, CalculationMode mode, double value)**\n\n**SetProfitTarget(string fromEntrySignal, CalculationMode mode, double value, bool isMIT)**\n\n{% callout type=\"warning\" %}\n\nThis method CANNOT be called from the **OnStateChange()** method during State.SetDefaults.\n\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **currency**\n* Sets the profit target amount in currency ($500 profit for example)\n\n---\n\n* **isMIT**\n* Sets the profit target as a market-if-touched order\n\n---\n\n* **mode**\n* Determines the manner in which the value parameter is calculated. Possible values are:\n  * **CalculationMode.Currency**: PnL away from average entry. Calculated by the dollar per tick value for the order quantity used. When this mode is used, **StopTargetHandling** will automatically be set to ByStrategyPosition.\n  * **CalculationMode.Percent**: Percentage away from the average entry, based on the average entry price.\n  * **CalculationMode.Pips**: Pips away from average entry.\n  * **CalculationMode.Price**: The absolute price point specified.\n  * **CalculationMode.Ticks**: Ticks away from entry average entry.\n\n---\n\n* **value**\n* The value the profit target order is offset from the position entry price (exception is using .Price mode where 'value' will represent the actual price).\n\n---\n\n* **fromEntrySignal**\n* The entry signal name. This ties the profit target exit to the entry and exits the position quantity represented by the actual entry. Using an empty string will attach the exit order to all entries.\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips (also see [Overview](managed_approach)):\n\n* It is suggested to call this method from within the strategy **OnStateChange()** method if your profit target price/offset is static.\n* You may call this method from within the strategy **OnBarUpdate()** method should you wish to dynamically change the target price while in an open position.\n* Should you call this method to dynamically change the target price in the strategy **OnBarUpdate()** method, you should always reset the target price / offset value when your strategy is flat otherwise, the last price/offset value set will be used to generate your profit target order on your next open position.\n* The signal name generated internally by this method is **Profit target** which can be used with various methods such as **BarsSinceExitExecution()**, or other order concepts which rely on identifying a signal name.\n{% /callout %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        // Submits a profit target order 10 ticks away from the avg entry price\n        SetProfitTarget(CalculationMode.Ticks, 10);\n    }\n}\n```"
  },
  {
    "_id": "ef764a1e1ef44636983d73ac82037da94905a474cf1dc8cf6a0d494112a83bb3",
    "_type": "desktopSdkDoc",
    "title": "SetTrailStop()",
    "pathName": "settrailstop",
    "parent": "managed_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nGenerates a trail stop order with the signal name **Trail stop** to exit a position. Trail stops are amended on a bar update basis, so dependent upon the [Calculate](calculate) setting of the parent strategy. Trail stop orders are real working orders (unless simulated is specified in which case the stop order is locally simulated and submitted as market once triggered) submitted immediately to the market upon receiving an execution from an entry order.\n\n{% callout type=\"note\" %}\n\nNotes:\n\n* The **SetTrailStop()** method can NOT be used concurrently with the [SetStopLoss()](setstoploss) or [SetParabolicStop()](setparabolicstop) method for the same position. If any of these methods are called for the same position (**fromEntrySignal**), the [SetStopLoss()](setstoploss) will always take precedence. You can, however, use all three methods in the same strategy if they reference different signal names.\n* Trail stop orders are submitted in real-time on incoming executions from entry orders.\n* Since they are submitted upon receiving an execution, the **Set** method should be called prior to submitting the associated entry order to ensure an initial level is set.\n* A strategy will either generate a trail stop order for each partial fill of an entry order or one order for all fills. See additional information under the [Strategies](options_strategies) tab of the Options dialog window.\n* If a [profit target](setprofittarget) order is generated in addition to a trail stop order, they are submitted as OCO (one cancels other).\n* Trail stop orders are submitted as stop-market orders.\n* A trail stop order is automatically canceled if the managing position is closed by another strategy-generated exit order.\n* Should you have multiple **Bars** objects of the same instrument while using **SetTrailStop()** in your strategy, you should only submit orders for this instrument to the first **Bars** context of that instrument. This is to ensure your order logic is processed correctly and any necessary order amendments are done properly.\n* Trail stop orders are modified based on the strategy's **Calculate** settings. In the case of **Calculate** on bar close, when the bar closes the trail stop order modification will occur using the lowest/highest price of the bar as the reference price to apply the trail offset. Subsequently, if the open price of the next bar is significantly higher or lower than this price, then there is a possibility that the calculated trail stop price is now an invalid stop price. This is a risk with modifying any stop order closer to the current market price since any modification above/below the current price would be rejected.\n{% /callout %}\n\n## Syntax\n\n**SetTrailStop(CalculationMode mode, double value)**\n\n**SetTrailStop(string fromEntrySignal, CalculationMode mode, double value, bool isSimulatedStop)**\n\n{% callout type=\"warning\" %}\n\nWarnings:\n\n* This method CANNOT be called from the [OnStateChange()](onstatechange) method during **State.SetDefaults**.\n* **CalculationMode.Price** and **CalculationMode.Currency** are irrelevant for trail stops. Attempting to use one of these modes will log a message and the stop order will be ignored. Please use [SetStopLoss()](setstoploss) for these modes instead.\n{% /callout %}\n\n## Parameters\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* **mode**\n* Determines the manner in which the value parameter is calculated. Possible values are:\n  * **CalculationMode.Percent**: Percentage away from the average entry, based on the average entry price.\n  * **CalculationMode.Pips**: Pips away from average entry.\n  * **CalculationMode.Ticks**: Ticks away from entry average entry.\n  * Please note in percentage calculation mode a value of 1 is equal to 100%, a value of 0.1 is equal to 10%, and a value of 0.01 will be 1%.\n\n---\n\n* **isSimulatedStop**\n* If true, will simulate the stop order and submit as market once triggered.\n\n---\n\n* **value**\n* The value the trail stop order is offset from the position entry price (exception is using **.Price** mode where 'value' will represent the actual price).\n\n---\n\n* **fromEntrySignal**\n* The entry signal name. This ties the trail stop exit to the entry and exits the position quantity represented by the actual entry. Using an empty string will attach the exit order to all entries.\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.Configure)\n    {\n        // Sets a trail stop of 12 ticks\n        SetTrailStop(CalculationMode.Ticks, 12);\n    }\n}\n```\n\n{% callout type=\"note\" %}\n\nTips (also see [Overview](managed_approach)):\n\n* It is suggested to call this method from within the strategy [OnStateChange()](onstatechange) method if your trail stop price/offset is static.\n* You may call this method from within the strategy [OnBarUpdate()](onbarupdate) method should you wish to dynamically change the trail stop price while in an open position.\n* Should you call this method to dynamically change the trail stop price in the strategy [OnBarUpdate()](onbarupdate) method, you should always reset the trail stop price/offset value when your strategy is flat; otherwise, the last price/offset value set will be used to generate your trail stop order on your next open position.\n* The signal name generated internally by this method is **Trail stop**, which can be used with various methods such as [BarsSinceExitExecution()](barssinceexitexecution), or other order concepts which rely on identifying a signal name.\n{% /callout %}"
  },
  {
    "_id": "f3f6c9613be761406cab32f2b69073f970df602c0e46a62f88e34b29fa36a09c",
    "_type": "desktopSdkDoc",
    "title": "IgnoreOverfill",
    "pathName": "ignoreoverfill",
    "parent": "unmanaged_approach",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nAn **unmanaged order property** which defines the behavior of a strategy when an overfill is detected. An overfill is categorized as when an order returns a \"Filled\" or \"PartFilled\" state after the order was already marked for cancellation. The cancel request could have been induced by an explicit **CancelOrder()** call, from more implicit cancellations like those that occur when another order sharing the same OCO ID is filled, or from things like order expiration.\n\n{% callout type=\"critical\" %}\n\n* Setting this property value to true can have serious adverse effects on a running strategy unless you have programmed your own overfill handling.\n* User defined overfill handling is advanced and should ONLY be addressed by experienced programmers. Additional information can be found on overfills in the [Unmanaged approach](unmanaged_approach).\n{% /callout %}\n\n## Property Value\n\nThis property returns true if the strategy will ignore overfills; otherwise, false. Default is set to false.\n\n{% callout type=\"warning\" %}\n\nThis property should ONLY be set from the **OnStateChange()** method during State.SetDefaults or State.Configure.\n\n{% /callout %}\n\n## Syntax\n\n**IgnoreOverfill**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()\n{\n    if (State == State.SetDefaults)\n    {\n        // Allows for custom overfill handling\n        IgnoreOverfill = true;\n    }\n}\n```"
  },
  {
    "_id": "3eeb7e96e59ce40f9cb1a089daba079fd699f6867a30f6634af8570967b2375a",
    "_type": "desktopSdkDoc",
    "title": "Order",
    "pathName": "order",
    "parent": "strategy",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents a read only interface that exposes information regarding an order.\n\n* An Order object returned from calling an order method is dynamic in that its properties will always reflect the current state of an order.\n* The property **<`order`>.OrderId** is NOT a unique value, since it can change throughout an order's lifetime. Please see the [Advance Order Handling](advanced_order_handling) section on \"Transitioning order references from historical to live\" for details on how to handle.\n* The property **<`order`>.Oco** WILL be appended with a suffix when the strategy transitions from historical to real-time to ensure the OCO id is unique across multiple strategies for live orders.\n* To check for equality you can compare Order objects directly.\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n* Description\n\n---\n\n* Account\n* The [Account](account_class) the order resides\n\n---\n\n* AverageFillPrice\n* A double value representing the average fill price of an order\n\n---\n\n* Filled\n* An int value representing the filled amount of an order\n\n---\n\n* FromEntrySignal\n* A string representing the user defined fromEntrySignal parameter on an order\n\n---\n\n* Gtd\n* A [DateTime](http://msdn2.microsoft.com/en-us/library/system.datetime.aspx) structure representing when the order will be canceled\n\n---\n\n* HasOverfill\n* A bool value representing if the order is an overfill. For use when using [Unmanaged orders](unmanaged_approach) and [IgnoreOverFill](ignoreoverfill)\n\n---\n\n* Instrument\n* An [Instrument](instrument) value representing the instrument of an order\n\n---\n\n* IsBacktestOrder\n* A bool that indicates if the order was generated while processing historical data. For use with [GetRealtimeOrder()](getrealtimeorder) when transitioning historical order objects to live order objects when strategies transition to from State.Historical to State.Realtime.\n\n---\n\n* IsLiveUntilCancelled\n* A bool that when true, indicates the order will be canceled by [managed order handling](managed_approach) at expiration\n\n---\n\n* IsTerminalState()\n* A static method used to determine if the an order's OrderState is in considered terminal and no longer active\n\n---\n\n* LimitPrice\n* A double value representing the limit price of an order\n\n---\n\n* LimitPriceChanged\n* A double value representing the new limit price of an order. Used with [Account.Change()](change)\n\n---\n\n* Name\n* A string representing the name of an order which can be provided by the entry or exit signal name\n\n---\n\n* Oco\n* A string representing the OCO (one cancels other) id of an order\n\n---\n\n* OrderAction\n* Represents the action of the order. Possible values are:\n  * OrderAction.Buy\n  * OrderAction.BuyToCover\n  * OrderAction.Sell\n  * OrderAction.SellShort\n\n---\n\n* OrderId\n* A string representing the broker issued order id value (this value can change)\n\n---\n\n* OrderState\n* The current state of the order. See the order state values table below\n\n---\n\n* OrderType\n* The type of order submitted. Possible values are:\n  * OrderType.Limit\n  * OrderType.Market\n  * OrderType.MIT\n  * OrderType.StopMarket\n  * OrderType.StopLimit\n\n---\n\n* Quantity\n* An int value representing the quantity of an order\n\n---\n\n* QuantityChanged\n* An int value representing the new quantity of an order. Used with [Account.Change()](change)\n\n---\n\n* StopPrice\n* A double value representing the stop price of an order\n\n---\n\n* StopPriceChanged\n* A double value representing the new stop price of an order. Used with [Account.Change()](change)\n\n---\n\n* Time\n* A [DateTime](http://msdn2.microsoft.com/en-us/library/system.datetime.aspx) structure representing the last time the order changed state\n\n---\n\n* TimeInForce\n* Determines the life of the order. Possible values are:\n  * TimeInForce.Day\n  * TimeInForce.Gtc\n\n---\n\n* ToString()\n* A string representation of an order\n\n---\n\n{% /table %}\n\n## OrderState Values\n\n{% table %}\n\n* Order State\n* Description\n\n---\n\n* OrderState.Initialized\n* Order is initialized in NinjaTrader\n\n---\n\n* OrderState.Submitted\n* Order is submitted to the broker\n\n---\n\n* OrderState.Accepted\n* Order is accepted by the broker or exchange\n\n---\n\n* OrderState.TriggerPending\n* Order is pending submission\n\n---\n\n* OrderState.Working\n* Order is working in the exchange queue\n\n---\n\n* OrderState.ChangePending\n* Order change is pending in NinjaTrader\n\n---\n\n* OrderState.ChangeSubmitted\n* Order change is submitted to the broker\n\n---\n\n* OrderState.CancelPending\n* Order cancellation is pending in NinjaTrader\n\n---\n\n* OrderState.CancelSubmitted\n* Order cancellation is submitted to the broker\n\n---\n\n* OrderState.Cancelled\n* Order cancellation is confirmed by the exchange\n\n---\n\n* OrderState.Rejected\n* Order is rejected\n\n---\n\n* OrderState.PartFilled\n* Order is partially filled\n\n---\n\n* OrderState.Filled\n* Order is completely filled\n\n---\n\n* OrderState.Unknown\n* An unknown order state. Default if broker does not report current order state.\n\n---\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nCritical: In a historical backtest, orders will always reach a \"Working\" state. In real-time, some stop orders may only reach \"Accepted\" state if they are simulated/held on a brokers server.\n\n{% /callout %}\n\n## Examples\n\n```csharp\nprivate Order entryOrder = null;\n  \nprotected override void OnBarUpdate()\n{\n   if (entryOrder == null && Close[0] > Open[0])\n       EnterLong(\"myEntryOrder\");\n}\n  \nprotected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string nativeError)\n{\n   // Assign entryOrder in OnOrderUpdate() to ensure the assignment occurs when expected.\n   // This is more reliable than assigning Order objects in OnBarUpdate, as the assignment is not guaranteed to be complete if it is referenced immediately after submitting\n   if (order.Name == \"myEntryOrder\")\n      entryOrder = order;\n  \n   if (entryOrder != null && entryOrder == order)\n   {\n       Print(order.ToString());\n       if (order.OrderState == OrderState.Filled)\n           entryOrder = null;\n   }\n}\n```"
  },
  {
    "_id": "100fff0d6332bc143eeca8e28bee9b05ef640080952bd101a3d0bed25992ffad",
    "_type": "desktopSdkDoc",
    "title": "Properties",
    "pathName": "chartbars_properties",
    "parent": "chartbars",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents various **ChartBar** properties configured from the Chart's **Data Series** menu.\n\n{% callout type=\"note\" %}\n\nThe properties on this page indicate what have been configured by the user, and is NOT necessarily representative of what is actually contained on the chart. For example, a user may have requested 120 days of chart data; however, only 60 days of bar data are actually returned from their provider.\n\n{% /callout %}\n\n![ChartBars_DataSeries](chartbars_dataseries.png)\n\n{% callout type=\"warning\" %}\n\nThese are UI properties which are designed to be set by a user. Attempting to modify these values through a custom script is NOT guaranteed to take effect.\n\n{% /callout %}\n\n## Properties\n\n{% table %}\n\n* Property\n* Description\n\n---\n\n* AutoScale\n* A bool indicating if the Chart Data Series participates in the chart's auto scaling methods\n\n---\n\n* BarsBack\n* An int representing the Chart's Data Series configured \"Bars to load\" when the RangeType.Bars is selected\n\n---\n\n* BarsPeriod\n* The **BarsPeriod** object configured for Chart's Data Series\n\n---\n\n* CenterPriceOnScale\n* A bool indicating if the Chart's Data Series should center the last traded price on the chart scale\n\n---\n\n* ChartStyle\n* The **ChartStyle** object configured for the Chart's Data Series\n\n---\n\n* ChartStyleType\n* A **ChartStyleType** enum indicating the type of chart style configured. System defaults include:\n  * **ChartStyleType.Box**\n  * **ChartStyleType.CandleStick**\n  * **ChartStyleType.LineOnClose**\n  * **ChartStyleType.OHLC**\n  * **ChartStyleType.PointAndFigure**\n  * **ChartStyleType.KagiLine**\n  * **ChartStyleType.OpenClose**\n  * **ChartStyleType.Mountain**\n\n---\n\n* DaysBack\n* An int representing the Chart's Data Series configured \"Days to load\" when the RangeType.Days is selected\n\n---\n\n* DisplayInDataBox\n* A bool indicating if the Chart's Data Series value should display in the Chart's **Data Box**\n\n---\n\n* DisplayName\n* A string representing the Chart's Data Series instrument and period\n\n---\n\n* From\n* A DateTime representing the Chart's Data Series configured \"Start Date\" when the RangeType.CustomRange is configured.\n\n---\n\n* Instrument\n* A string representing the Chart's Data Series instrument\n\n---\n\n* IsStableSession\n* A bool indicating the Chart's Data Series **Break EOD** option is configured\n\n---\n\n* IsTickReplay\n* A bool indicating the Chart's Data Series **Tick Replay** option is configured\n\n---\n\n* Label\n* A string representing the configured Chart's Data Series \"Label\"\n\n---\n\n* LongExecutionBrush\n* A **Brush** object representing the Chart's Data Series \"Color for execution - buy\" brush configured\n\n---\n\n* PaintPriceMarker\n* A bool indicating the Chart's Data Series Price Marker \"Visible\" option is configured\n\n---\n\n* Panel\n* An int indicating which Chart's Data Series \"Panel\" the **ChartBars** are configured\n\n---\n\n* PlotExecutions\n* A **ChartExecutionStyle** enum representing \"Plot executions\" option. Possible values include:\n  * **ChartExecutionStyle.DoNotPlot**\n  * **ChartExecutionStyle.MarkersOnly**\n  * **ChartExecutionStyle.TextAndMarker**\n\n---\n\n* PositionPenLoser\n* A **Stroke** object representing the Chart's Data Series \"NinjaScript strategy unprofitable trade line\"\n\n---\n\n* PositionPenWinner\n* A **Stroke** object representing the Chart's Data Series \"NinjaScript strategy profitable trade line\"\n\n---\n\n* PriceMarker\n* A **PriceMarker** object representing various brushes used to paint the Chart's Data Series \"Price marker\"\n\n---\n\n* RangeType\n* A **RangeType** enum indicating the \"Load data based on\" value configured on the Data Series. Possible values include:\n  * **RangeType.Bars**\n  * **RangeType.Days**\n  * **RangeType.CustomRange**\n\n---\n\n* ScaleJustification\n* A **ScaleJustification** enum indicating the \"Scale justification\" option configured on the Chart's Data Series. Possible values include:\n  * **ScaleJustification.Right**\n  * **ScaleJustification.Left**\n  * **ScaleJustification.Overlay**\n\n---\n\n* ShortExecutionBrush\n* A **Brush** object representing the Chart's Data Series \"Color for execution - sell\" brush configured\n\n---\n\n* ShowGlobalDrawObjects\n* A bool indicating the Chart's Data Series \"Show global draw object\" option is configured\n\n---\n\n* To\n* A DateTime representing the configured \"End Date\" used with any RangeType\n\n---\n\n* TradingHoursBreakLine\n* A **TradingHoursBreakLine** object representing the **stroke** used and **TradingHoursBreakLineVisible** enum used for the Chart's Data Series \"Trading hours break line\". Possible **TradingHoursBreakLine.TradingHoursBreakLineVisible** values include:\n  * **TradingHoursBreakLineVisible.AllSessions**\n  * **TradingHoursBreakLineVisible.EodOnly**\n  * **TradingHoursBreakLineVisible.Off**\n\n---\n\n* TradingHoursData\n* A string representing the Chart's Data Series configured \"Trading hours\" option\n{% /table %}"
  },
  {
    "_id": "65499c3c9fa583449c80883835dda8779a62b3ef5d0d8239e9f6766c32c06868",
    "_type": "desktopSdkDoc",
    "title": "BarsPeriod",
    "pathName": "chartcontrol_barsperiod",
    "parent": "chartcontrol",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nProvides the period (interval) used for the primary **Bars** object on the chart.\n\n## Property Value\n\nA **NinjaTrader.Data.BarsPeriod** object containing information on the period used by the **Bars** object on the chart.\n\n## Syntax\n\n**<`chartcontrol`>.BarsPeriod**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale) \n{\n   BarsPeriod period = chartControl.BarsPeriod;\n \n   // Print the period (interval) of the Bars object on the chart\n   Print(period);\n}\n```\n\nBased on the image below, **BarsPeriod** confirms that the primary **Bars** object on the chart is configured to a 5-minute interval.\n\n![ChartControl_BarsPeriod](chartcontrol_barsperiod.png)"
  },
  {
    "_id": "a80b4caf467e5bf2a814f89938377979eaef399a128dbf8266781969348806a6",
    "_type": "desktopSdkDoc",
    "title": "IsYAxisDisplayedRight",
    "pathName": "chartcontrol_isyaxisdisplayedright",
    "parent": "chartcontrol",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the y-axis displays (in any chart panel) to the right side of the chart.\n\n## Property Value\n\nA boolean value. When **True**, indicates that the y-axis displays to the right of the chart canvas; otherwise **False**.\n\n## Syntax\n\n**<`chartcontrol`>.IsYAxisDisplayedRight**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the value of IsYAxisDisplayedRight\n   Print(\"Y-Axis visible to the right of the chart canvas? \" + chartControl.IsYAxisDisplayedRight);\n}\n```\n\nBased on the image below, **IsYAxisDisplayedRight** confirms that the y-axis is not displayed to the right of the chart canvas.\n\n![ChartControl_IsYAxisDisplayedRight](https://cdn.sanity.io/images/1hlwceal/production/dcbfbe76e74b6dae7aca3c477875e914d04a5dfa-575x429.png)"
  },
  {
    "_id": "998f4f59dfe1ae22d7f57bb8dc4cdca0fbe6f52b641c113ac862547645242276",
    "_type": "desktopSdkDoc",
    "title": "Properties",
    "pathName": "chartcontrol_properties",
    "parent": "chartcontrol",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA collection of properties related to the configuration of the Chart\n\n![Chart_Properites](chart_properites.png)\n\n{% callout type=\"note\" %}\n\nWarning: These are UI properties which are designed to be set by a user. Attempting to modify these values through a custom script is NOT guaranteed to take effect.\n\n{% /callout %}\n\n## Property Value\n\nA ChartControlProperties object containing values for all properties configured on the specified ChartBars object.\n\n{% table %}\n\n* Property\n* Return Type and Description\n\n---\n\n* **AllowSelectionDragging**\n* A bool indicating selected chart objects can be moved within a chart panel or dragged to a new chart panel\n\n---\n\n* **AlwaysOnTop**\n* A bool indicating \"Always on Top\" is enabled for the chart window\n\n---\n\n* **AreHGridLinesVisible**\n* A bool indicating the horizontal grid lines are visible on the chart\n\n---\n\n* **AreTabsVisible**\n* A bool indicating tabs are visible in the chart window\n\n---\n\n* **AreVGridLinesVisible**\n* A bool indicating the vertical grid lines are visible on the chart\n\n---\n\n* **AxisPen**\n* A Stroke object used in painting the x- and y-axis\n\n---\n\n* **BarDistance**\n* A float measuring the distance (in pixels) between the left or right edge of one bar and the corresponding edge of the previous or subsequent bar\n\n---\n\n* **BarMarginRight**\n* An int representing the \"Right Margin\" property value configured on the chart\n\n---\n\n* **ChartBackground**\n* A Brush object used to paint the chart background\n\n---\n\n* **ChartText**\n* A Brush object used to paint text on the chart\n\n---\n\n* **ChartTraderVisibility**\n* An enum indicating the visibility status of Chart Trader. Possible values are Collapsed, Visible, and VisibleCollapsed\n\n---\n\n* **CrosshairCrosshairType**\n* An enum indicating the type of Cross Hair enabled on the chart. Possible values are Off, Local, Global, and GlobalNoTimeScroll\n\n---\n\n* **CrosshairIsLocked**\n* A bool indicating the Cross Hair's vertical line is locked in place\n\n---\n\n* **CrosshairLabelBackground**\n* A Brush object used to paint the Cross Hair's price and time markers in the x- and y-axis\n\n---\n\n* **CrosshairLabelForeground**\n* A Brush object used to paint the text in the Cross Hair's price and time markers\n\n---\n\n* **CrosshairPen**\n* A string representing the Pen used within the Stroke that is used to draw the Cross Hair\n\n---\n\n* **CrosshairStroke**\n* A CrosshairStroke object containing information on the Cross Hair's Stroke, CrosshairType, and isLocked property\n\n---\n\n* **GridLineHPen**\n* A GridLine object containing information on the horizontal grid lines' Stroke and isVisible property\n\n---\n\n* **GridLineVPen**\n* A GridLine object containing information on the vertical grid lines' Stroke and isVisible property\n\n---\n\n* **InactivePriceMarkersBackground**\n* A Brush object used to paint the background of inactive price markers on the chart\n\n---\n\n* **InactivePriceMarkersForeground**\n* A Brush object used to paint the display text of inactive price markers on the chart\n\n---\n\n* **LabelFont**\n* A NinjaTrader.Gui.Tools.SimpleFont object containing information on the font used in text labels throughout the chart\n\n---\n\n* **PanelSplitterPen**\n* A Stroke object used to paint the lines between chart panels\n\n---\n\n* **ShowDateRange**\n* A bool indicating the date range of the bars painted on the visible chart canvas will be displayed within the chart\n\n---\n\n* **ShowScrollBar**\n* A bool indicating the horizontal scroll bar is visible beneath the x-axis\n\n---\n\n* **SnapMode**\n* An enum indicating the currently enabled Snap Mode. Possible values are None, Bar, Price, and BarAndPrice\n\n---\n\n* **TabName**\n* A string representing the name of the current tab\n{% /table %}\n\n## Syntax\n\n**<`chartcontrol`>.Properties**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Instantiate a ChartControlProperties object to hold a reference to chartControl.Properties\n   ChartControlProperties myProperties = chartControl.Properties;\n \n   // Set the AllowSelectionDragging property to false\n   myProperties.AllowSelectionDragging = false;\n}\n```"
  },
  {
    "_id": "a0f93ed5fb7ef03f5d8a225b5c9c1171ba7039c1c915d5c0e5e82687335d9a01",
    "_type": "desktopSdkDoc",
    "title": "IsYAxisDisplayedOverlay",
    "pathName": "isyaxisdisplayedoverlay",
    "parent": "chartcontrol",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates an object on the chart is using the Overlay scale justification.\n\n## Property Value\n\nA boolean value. When **True**, indicates that one or more objects on the chart are using the Overlay scale justification; otherwise **False**.\n\n## Syntax\n\n**<`chartcontrol`>.IsYAxisDisplayedOverlay**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n   // Print the value of IsYAxisDisplayedOverlay\n   Print(\"Is Overlay used? \" + chartControl.IsYAxisDisplayedOverlay);\n}\n\n```\n\nBased on the image below, **IsYAxisDisplayedOverlay** confirms that an object on the chart, in this case an SMA indicator, is using the Overlay scale justification.\n\n![ChartControl_IsXAxisDisplayedOverlay](chartcontrol_isxaxisdisplayedoverlay.png)"
  },
  {
    "_id": "9859de2725d32f019fc96f154e6e66b3eaebfd831b4591014ebccc001781387f",
    "_type": "desktopSdkDoc",
    "title": "PanelIndex",
    "pathName": "panelindex_chartpanel",
    "parent": "chartpanel",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the index of the chart panel in the collection of configured panels.\n\n{% callout type=\"note\" %}\n\nThis property comes from a zero-based index, which is not the same as the panel number displayed in the Indicators window opened from within the chart. The panel number displayed in the Indicators window will equate to **ChartPanel.PanelIndex** + 1.\n\n{% /callout %}\n\n## Property Value\n\nA **int** representing the zero-based index of the panel.\n\n## Syntax\n\n**ChartPanel.PanelIndex**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    base.OnRender(chartControl, chartScale);\n\n    // Print the panel's zero-based index\n    Print(String.Format(\"This panel sits at index {0}\", ChartPanel.PanelIndex));\n}\n```\n\nNotice three things in the image below:\n\n* An indicator containing the example code above is configured on the second chart panel.\n* In the Indicators window, the \"Panel\" property is set to 2.\n* The output of the example code displays the zero-based index of Panel #2, which is at index 1.\n\n![ChartPanel_PanelIndex](chartpanel_panelindex.png)"
  },
  {
    "_id": "f6e8d90718ae0865cd093b76fde6e5a5b9d7d2071a7050358ca88c668ed02a89",
    "_type": "desktopSdkDoc",
    "title": "Properties",
    "pathName": "chartscale_properties",
    "parent": "chartscale",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents a number of properties available to the Chart Scale which can be configured to change the appearance of the scale.\n\n![ChartPanel_Properites](chartpanel_properites.png)\n\n{% callout type=\"warning\" %}\n\nThese are UI properties which are designed to be set by a user. Attempting to modify these values through a custom script is NOT guaranteed to take effect.\n\n{% /callout %}\n\n## Property Values\n\n{% table %}\n\n* Property\n* Description\n\n---\n\n* **YAxisRangeType**\n* An **YAxisRangeType** enum, possible values are:\n  * Automatic\n  * Fixed\n\n---\n\n* **AutoScaleDateRangeType**\n* An **AutoScaleDateRangeType** enum, possible values are:\n  * ScreenDateRange\n  * EntireDateRangeSeriesOnly\n\n---\n\n* **HorizontalGridlinesCalculation**\n* An **YAxisRangeType** enum, possible values are:\n  * Automatic\n  * Fixed\n\n---\n\n* **HorizontalGridlinesIntervalType**\n* A **HorizontalGridlinesIntervalType** enum, possible values are:\n  * Ticks\n  * Points\n  * Pips\n\n---\n\n* **HorizontalGridlinesInterval**\n* A **double** value representing the vertical interval of the horizontal axis\n\n---\n\n* **AutoScaleMarginType**\n* An **AutoScaleMarginType** enum, possible values are:\n  * Percent\n  * Price\n\n---\n\n* **AutoScaleMarginLower**\n* A **double** value representing the lowest margin used for the chart scale\n\n---\n\n* **AutoScaleMarginUpper**\n* A **double** value representing the highest margin used for the chart scale\n\n---\n\n* **YAxisScalingType**\n* An **YAxisScalingType** enum, possible values are:\n  * Linear\n  * Logarithmic\n\n---\n\n* **FixedScaleMax**\n* A double representing the highest series value used for the chart scale when the scale is fixed\n\n---\n\n* **FixedScaleMin**\n* A double representing the lowest series value used for the chart scale when the scale is fixed\n{% /table %}\n\n## Syntax\n\n**<`chartscale`>.Properties**\n\n## Examples\n\n```csharp\n\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)\n{\n    if (chartScale.Properties.YAxisScalingType == AxisScalingTypeLinear)\n    {\n        // do something\n    }\n}\n```"
  },
  {
    "_id": "85615d4d8066ad25a40fabccaa2e4567df87036892ec37a00028a8de185cf33c",
    "_type": "desktopSdkDoc",
    "title": "SharpDX",
    "pathName": "sharpdx",
    "parent": "ninjascript",
    "order": 7,
    "section": "references",
    "markdown": "{% callout type=\"warning\" %}\n\nDisclaimer: The [SharpDX SDK Reference](sharpdx) section was compiled from the official [SharpDX Documentation](http://sharpdx.org/) and was NOT authored by NinjaTrader. The contents of this section are provided as-is and only cover a fraction of what is available from the SharpDX SDK. This page was intended only as a reference guide to help you get started with some of the 2D Graphics concepts used in the NinjaTrader.Custom assembly. Please refer to the official SharpDX Documentation for additional members not covered in this reference. For more seasoned graphic developers, the original MSDN [Direct2D1](https://msdn.microsoft.com/en-us/library/windows/desktop/dd370990.aspx) and [DirectWrite](https://msdn.microsoft.com/en-us/library/windows/desktop/dd368038.aspx) unmanaged API documentation can also be helpful for understanding the DirectX/Direct2D run-time environment. For NinjaScript development purposes, we document only essential members in the structure of this page.\n\n{% /callout %}\n\nThe SharpDX namespace contains fundamental classes used by SharpDX.\n\n## In this section\n\n{% table %}\n\n* Type\n* Description\n\n---\n\n* [Color](sharpdx_color)\n* Represents a 32-bit color (4 bytes) in the form of RGBA (in byte order: R, G, B, A).\n\n---\n\n* [Color3](sharpdx_color3)\n* Represents a color in the form of rgb.\n\n---\n\n* [Color4](sharpdx_color4)\n* Represents a color in the form of rgba.\n\n---\n\n* [DisposeBase](sharpdx_disposebase)\n* Base class for a **System.IDisposable** class.\n\n---\n\n* [Matrix3x2](sharpdx_matrix3x2)\n* Represents a 3x2 mathematical matrix.\n\n---\n\n* [RectangleF](sharpdx_rectanglef)\n* Structure using similar layout as **System.Drawing.RectangleF**.\n\n---\n\n* [Size2F](sharpdx_size2f)\n* Structure using the same layout as **System.Drawing.SizeF**.\n\n---\n\n* [Vector2](sharpdx_vector2)\n* Represents a two dimensional mathematical vector.\n{% /table %}"
  },
  {
    "_id": "6088204531b7510ebcec1ee1f2650e4dba88d73a7dd4b356be0e7b3eaec10e20",
    "_type": "desktopSdkDoc",
    "title": "GetValueAt()",
    "pathName": "getvalueat",
    "parent": "iseriest",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the underlying input value at a specified bar index value.\n\n## Method Return Value\n\nA **double** value representing the value at a specified bar.\n\n## Syntax\n\n**GetValueAt(int barIndex)**\n\n**ISeries<`T`>.GetValueAt(int barIndex)**\n\n{% callout type=\"note\" %}\n\nTip:  If called directly from the instance of the NinjaScript object, the value which is returned corresponds to the input series the object is running. (e.g., Close, High, Low, SMA, etc.).  If you're attempting to obtain another indicator value, you will need to pull this from the calculated indicator Value or Plot.\n\n{% /callout }\n\n```csharp\nSMA(20).GetValueAt(123); // bar value  \nSMA(20).Values[0].GetValueAt(123); // indicator value\n\n(Input as Indicator).Values[0].GetValueAt(123) // passed in indicator value\n```\n\n##  Parameters\n\n{% table %}\n\n---\n\n* barIndex \n* An int representing an absolute bar index value\n\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)  \n{  \n  // make sure there are bars displayed on the chart and the chart control is ready before running  \n  if (Bars == null | chartControl == null)  \n    return;        \n   \n  // loop through all the visable bars on the chart  \n  for (int i = ChartBars.FromIndex - 1; i >= BarsRequiredToPlot; i--)  \n  {  \n    double value = GetValueAt(i);  \n    Print(string.Format(\"The value at bar {0} is {1}\", i, value));        \n  }  \n}\n```"
  },
  {
    "_id": "f1c3a49600e1a0a96167008b82c07086baf6d488851ff9cda87fd96de869ea79",
    "_type": "desktopSdkDoc",
    "title": "Name",
    "pathName": "tradinghours_name",
    "parent": "tradinghours",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the name of the trading hours template applied to the Bars series object.  \n \n\n## Property Value\n\nA **string** representing the name of the trading hours template.\n\n## Syntax  \n\n**Bars.TradingHours.Name**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()  \n{                    \n  Print(TradingHours.Name);  \n  //Output if applied to the ES with 'use instrument settings':  CME US Index Futures ETH  \n}\n```"
  },
  {
    "_id": "ae9f6664b78f417eb6cb0c61420e647ec48184888b8849f82b5b29a77afe5ffb",
    "_type": "desktopSdkDoc",
    "title": "Sessions",
    "pathName": "tradinghours_sessions",
    "parent": "tradinghours",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA collection of session definitions of the configured Trading Hours template.  \n\n## Available Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* BeginDay\n\n* A [DayOfWeek](https://msdn.microsoft.com/en-us/library/system.dayofweek(v=vs.90).aspx) value representing the begin day\n\n---\n\n* BeginTime\n\n* An int value representing the begin time\n\n---\n\n* EndDay\n\n* A [DayOfWeek](https://msdn.microsoft.com/en-us/library/system.dayofweek(v=vs.90).aspx) value representing the end day\n\n---\n\n* EndTime\n\n* An int value representing the end time\n\n---\n\n* TradingDay\n\n* A [DayOfWeek](https://msdn.microsoft.com/en-us/library/system.dayofweek(v=vs.90).aspx) value representing the trading day this session belongs to\n\n---\n\n{% /table %}\n\n## Syntax  \n\n**Bars.TradingHours.Sessions[int idx]**\n\n{% callout type=\"note\" %}\n\n**Tip**:  Each index value will represent a new defined session for the Trading Hours template. For example, accessing Bars.TradingHours.Sessions[0] would provide you with information for the first trading session configured in the Trading Hours template:\n\n- `Bars.TradingHours.Sessions[0].TradingDay = DayOfWeek.Monday`,  \n- `Bars.TradingHours.Sessions[1].TradingDay = DayOfWeek.Tuesday`,  \n- `Bars.TradingHours.Sessions[2].TradingDay = DayOfWeek.Wednesday`, etc.\n\n{% /callout % }\n\n## Examples\n\n```csharp\n// Print details for all sessions in the Trading Hours template  \nfor (int i = 0; i < TradingHours.Sessions.Count; i++)  \n{  \n  Print(String.Format(\"Session {0}: {1} at {2} to {3} at {4}\", i, TradingHours.Sessions[i].BeginDay, TradingHours.Sessions[i].BeginTime,  \n    TradingHours.Sessions[i].EndDay, TradingHours.Sessions[i].EndTime));  \n}\n```"
  },
  {
    "_id": "104d86dff54a98f617def7321fb852d3455ae087730beb809ddbce7aa1c93f01",
    "_type": "desktopSdkDoc",
    "title": "TransformBrush()",
    "pathName": "transformbrush",
    "parent": "chart_style",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nScales a non-solid color brush used for rendering the chart style to properly display in NinjaTrader.\n\n{% callout type=\"note\" %}\n\nThis method has no impact on solid color brushes.  You would only need to pass in either a linear or radial gradient brush.\n\n{% /callout %}\n\n## Method Return Value\n\nThis method does not return a value.\n\n## Syntax  \n\n**TransformBrush(SharpDX.Direct2D1.Brush brush, RectangleF rect)**\n\n## Method Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* brush\n\n* A [SharpDX.Direct2D1.Brush](sharpdx_direct2d1_brush) object representing the brush used to render\n\n---\n\n* rect\n\n* A [RectangleF](https://msdn.microsoft.com/en-us/library/system.drawing.rectanglef%28v=vs.110%29.aspx) structure representing the rectangle to be rendered\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale, ChartBars chartBars)\n\n{\n\n  TransformBrush(brush, rect);\n\n}\n```"
  },
  {
    "_id": "babe52552a3994861abd3849c0dba3e92ae16c471ed76f24d937411f6ba6ff73",
    "_type": "desktopSdkDoc",
    "title": "TrendChannel",
    "pathName": "trendchannel",
    "parent": "draw_trendchannel",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Trend Channel [IDrawingTool](idrawingtool).\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* TrendStartAnchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the starting point of the drawing object\n\n---\n\n* TrendEndAnchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the end point of the drawing object\n\n---\n\n* ParallelStartAnchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the starting point of the second line used in the trend channel\n\n---\n\n* [PriceLevels](pricelevels)\n\n* A collection of prices calculated by the drawing object\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Instantiate a TrendChannel object  \nTrendChannel myTC = Draw.TrendChannel(this, \"tag1\", true, 10, Low[10], 0, High[0], 10, High[10] + 5 * TickSize);            \n   \n// Increase the y-axis position of the object's TrendEndAnchor  \nmyTC.TrendEndAnchor.Price += 15;\n```"
  },
  {
    "_id": "0a3f13c673af2389ecb9576de99764a56b808071862d4ba81083519d9fdba28f",
    "_type": "desktopSdkDoc",
    "title": "Triangle",
    "pathName": "triangle",
    "parent": "draw_triangle",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Triangle [IDrawingTool](idrawingtool).\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the starting point of the drawing object\n\n---\n\n* MiddleAnchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the middle point of the drawing object\n\n---\n\n* EndAnchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the end point of the drawing object\n\n---\n\n* AreaBrush\n\n* A [Brush](http://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) class representing the fill color of the draw object\n\n---\n\n* AreaOpacity\n\n* An int value representing the opacity of the area color\n\n---\n\n* OutlineStroke\n\n* The [Stroke](stroke_class) object used to draw the object's outline\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Instantiate a Triangle object  \nTriangle myTri = Draw.Triangle(this, \"tag1\", 4, Low[4], 3, High[3], 1, Low[1], Brushes.Blue);              \n   \n// Change the object's AreaOpacity  \nmyTri.AreaOpacity = 100;\n```"
  },
  {
    "_id": "0ed740388e890da85bc17d82bd2efc3d7f7ae7578ff6639d18c8ffa2c07f7e6e",
    "_type": "desktopSdkDoc",
    "title": "TriangleDown",
    "pathName": "triangledown",
    "parent": "draw_triangledown",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Triangle Down [IDrawingTool](idrawingtool).\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* Anchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the point of the drawing object\n\n---\n\n* AreaBrush\n\n* A [Brush](http://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) class representing the fill color of the draw object\n\n---\n\n* OutlineBrush\n\n* A [Brush](http://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) class representing the outline color of the draw object\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Instantiate a TriangleDown object  \nTriangleDown myTri = Draw.TriangleDown(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);              \n   \n// Change the object's AreaBrush  \nmyTri.AreaBrush = Brushes.Beige;\n```"
  },
  {
    "_id": "efad569a0b54d0e1b83093e6dc60f97958f580bb8f449b9c145238c6877aaccf",
    "_type": "desktopSdkDoc",
    "title": "TriangleUp",
    "pathName": "triangleup",
    "parent": "draw_triangleup",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Triangle Up [IDrawingTool](idrawingtool).\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* Anchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the point of the drawing object\n\n---\n\n* AreaBrush\n\n* A [Brush](http://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) class representing the fill color of the draw object\n\n---\n\n* OutlineBrush\n\n* A [Brush](http://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) class representing the outline color of the draw object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a TriangleUp object  \nTriangleUp myTri = Draw.TriangleUp(this, \"tag1\", true, 0, Low[0] - TickSize, Brushes.Red);              \n   \n// Change the object's AreaBrush  \nmyTri.AreaBrush = Brushes.Beige;\n```"
  },
  {
    "_id": "82b9e27e2d9ff126856c9f2f7aba2e7e931c80f00b04d3c5d116dc6ea2d3be5c",
    "_type": "desktopSdkDoc",
    "title": "TriggerCustomEvent()",
    "pathName": "triggercustomevent",
    "parent": "common",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nProvides a way to use your own custom events (such as a Timer object) so that internal NinjaScript indexes and pointers are correctly set prior to processing user code triggered by your custom event. When calling this event, NinjaTrader will synchronize all internal pointers and then call your custom event handler where your user code is located.\n\n{% callout type=\"note\" %}\n\nThe TriggerCustomEvent() method does NOT execute before State.DataLoaded or during or after State.Terminated.  In effect, attempting to trigger custom events may be unavailable in some circumstances (e.g., while an indicator is terminating, or viewing the [Strategy Analyzer](strategy_analyzer) chart display after backtest has completed, etc.)\n\n{% /callout }\n\n## Method Return Value\n\nThis method does not have a return value.\n\n## Syntax\n\n**TriggerCustomEvent(Action<`object`> customEvent, object state)**\n\n**TriggerCustomEvent(Action<`object`> customEvent, int barsSeriesIndex, object state)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* barsIndex\n\n* Index of the [bar series](barsinprogress) you want to synchronize to\n\n---\n\n* customEvent\n\n* [Delegate](http://msdn.microsoft.com/en-us/library/018hxwa8%28v=vs.110%29.aspx) of your custom event method\n\n---\n\n* state\n\n* Any object you want passed into your custom event method\n\n---\n\n{% /table %}\n\n{% callout type=\"note\" %}\n\nTips:  \n\n- There may be scenarios in which you need to set a [Series<`T`>](seriest) value outside of one of the core data event methods.  In these cases, you can use TriggerCustomEvent() to reliably synchronize the barAgo indexer to the recent.  current bar being updated.  Please see the example below.\n- Usually the correct approach is to use the WPF Dispatcher timer, however in cases where you need the timer to update a WinForms window it opened - please use the [WinForms timer](https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.timer?view=netframework-4.7.2).\n\n{% /callout %}\n\n## Examples\n\n### Using TriggerCustomEvent() in simple timer event\n\n```csharp\nprotected override void OnBarUpdate()  \n{  \n// OnBarUpdate() only runs as bars are processed, which is not guaranteed to occur at a specific interval  \n// e.g., even on a 5 second bar series, there may be time periods where there are no updates due to low trading activity  \n// or could be buffered due to running Calculate.OnBarClose. Instead of trying to obtain the Close[0] value  \n// at some interval here, we are going to do it in our custom TimerEventProcessor  \n}  \n   \n// This is the method to run when the timer is raised.  \nprivate void TimerEventProcessor(Object myObject, EventArgs myEventArgs)  \n{  \n// Do not process your code here but instead call the TriggerCustomEvent() method  \n// and process your code in the custom handler method e.g., our custom PrintThePrice()  \n// Doing so ensures all internal indexers are up-to-date  \nif (CurrentBar > 0)  \n{  \n  TriggerCustomEvent(PrintThePrice, Close[0]);  \n}  \n}  \n   \n// Print the latest closing price with the current time  \nprivate void PrintThePrice(object price)  \n{  \nPrint(\"The Last Bar's Closing Value as of \" + NinjaTrader.Core.Globals.Now + \" was \" + price);  \n}  \n   \n// Declare the WPF dispatcher timer  \nprivate System.Timers.Timer myTimer;  \n   \nprotected override void OnStateChange()  \n{  \nif (State == State.SetDefaults)  \n{  \n  Name = \"SampleTriggerCustomEventTimer\";  \n}  \nelse if (State == State.DataLoaded)  \n{  \n    // Instantiates the timer and sets the interval to 5 seconds.  \n    myTimer = new System.Timers.Timer(5000);  \n    // Adds the event handler for the method that will  \n    // process the timer event to the timer.  \n    myTimer.Elapsed += TimerEventProcessor;  \n    // Starts the timer  \n    myTimer.Enabled = true;  \n}  \nelse if (State == State.Terminated)  \n{  \n    // Stops the timer and removes the timer event handler  \n    if (myTimer != null)  \n    {  \n        myTimer.Enabled = false;  \n        myTimer.Elapsed -= TimerEventProcessor;  \n        myTimer = null;  \n    }  \n}  \n}\n```\n\n### Using TriggerCustomEvent to update a previously set custom Series<`T`> value\n\n```csharp\n// using the virtual on render method for demonstration  \n// but concept could apply to any custom event that does not rely on bars data  \n// e.g., from a custom mouse event or other 3rd party dependency  \nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)  \n{  \n  // we want to reset a custom series values 20 barsAgo during some condition  \n  if (conditionWhichRequiredUpdate)  \n  {  \n    // First, synchronize the index value used in via Series[barsAgo]  \n    // to the NinjaScriptBase.CurrentBar being currently being processed in OnBarUpdate  \n    TriggerCustomEvent(o =>  \n    {  \n        // For debugging, check the previous value  \n        Print(\"Before value which was set in OnBarUpdate(): \" + SomeVolumeData[20]);  \n   \n        SomeVolumeData[20] = 5; // set to our new custom value  \n   \n        // For debugging, check the updated value  \n        Print(\"After value which was updated later in OnRender(): \" + SomeVolumeData[20]);  \n    }, null);  \n   \n    // reset our flag until we need to update a value again  \n    conditionWhichRequiredUpdate = false;  \n  }  \n  //Output:  \n  //Before value which was set in OnBarUpdate(): 1165  \n  //After value which was updated later in OnRender(): 5  \n}  \n   \nprivate Series<double> SomeVolumeData; // custom Series for tracking volume which will be modified through its lifetime  \nprivate bool conditionWhichRequiredUpdate = true;  \n   \nprotected override void OnStateChange()  \n{  \n  protected override void OnStateChange()  \n  {  \n    if (State == State.SetDefaults)  \n    {  \n        Name = \"SampleUpdateCustomSeries\";  \n    }  \n   \n    else if (State == State.Historical)  \n    {  \n        SomeVolumeData = new Series<double>(this);  \n    }  \n  }  \n}  \n   \nprotected override void OnBarUpdate()  \n{  \n  SomeVolumeData[0] = Volume[0]; // set the custom series to the CurrentBar volume  \n}\n```"
  },
  {
    "_id": "b72910d0e172fe3e7da1e3bea335958dfa5425ba923e890b24d30f5ca9fe8adb",
    "_type": "desktopSdkDoc",
    "title": "True Strength Index (TSI)",
    "pathName": "true_strength_index_tsi",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe True Strength Index (TSI) is a momentum-based indicator, developed by William Blau. Designed to determine both trend and overbought/oversold conditions, the TSI is applicable to intraday time frames as well as long term trading.\n\n## Syntax\n\n**TSI(int fast, int slow)**  \n**TSI(ISeries<`double`> input, int fast, int slow)**\n\n### Returns default value  \n\n**TSI[int fast, int slow](int barsAgo)**  \n**TSI[ISeries<`double`> input, int fast, int slow](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* fast\n\n* Period of the fast smoothing factor\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* slow\n\n* Period of the slow smoothing factor\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period TSI using default price type  \ndouble value = TSI(20, 10)[0];  \nPrint(\"The current TSI value is \" + value.ToString());  \n   \n// Prints the current value of a 20 period TSI using high price type  \ndouble value = TSI(High, 20, 10)[0];  \nPrint(\"The current TSI value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "85719be272f82fa1a32e8e8af5aa0e3b9bcb33c1eb3a2bc68b1bfc0009e30acf",
    "_type": "desktopSdkDoc",
    "title": "Turnaround",
    "pathName": "turnaround",
    "parent": "tradesperformancevalues",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the amount of turnaround.  \n\n## Property Value\n\nA **double** value that represents the amount of turnaround.\n\n## Syntax  \n\n<`TradeCollection`>.TradesPerformance.<`TradesPerformanceValues`>.**Turnaround**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()  \n{  \n    // Print out the turnaround of all trades  \n    Print(\"Turnaround of all trades is: \" + SystemPerformance.AllTrades.TradesPerformance.Currency.Turnaround);  \n}\n```"
  },
  {
    "_id": "6b612e0319bded40ab95a6731150450b5bc5ea1872b7199d4100cdf941ae51b7",
    "_type": "desktopSdkDoc",
    "title": "TypeConverterAttribute()",
    "pathName": "typeconverterattribute",
    "parent": "attributes",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nBinds an object or property to a specific TypeConverter implementation.  This is commonly used to customize property descriptors on the NinjaTrader property grid.\n\n{% callout type=\"note\" %}\n\n* If you are looking to extend behavior of an Indicator or Strategy (e.g., values of one property influence another), you must implement either an [IndicatorBaseTypeConverter](indicatorbaseconverter) or [StrategyBaseTypeConveter](strategybaseconverter).  This is to ensure default property descriptor behavior works as intended.\n\n* For converting types of a specific property, implementing a standard TypeConverter is sufficient\n\n* A working NinjaScript demo can be found through the reference sample on \"Using a TypeConverter to Customize Property Grid Behavior\"\n\n* The TypeConverterAttribute object is a general purpose attribute made available from the .NET Framework. The information on this page is written to demonstrate how you may use this object within NinjaScript conventions used with the NinjaTrader UI's property grid (e.g., an indicator dialog).  There are more methods and properties that you can learn about from MSDN's [TypeConverterAttribute Class](https://msdn.microsoft.com/en-us/library/system.componentmodel.typeconverterattribute(v=vs.110).aspx) which are NOT covered in this topic; as such there is NO guarantee they will work with the NinjaTrader UI's property grids.\n\n{% /callout %}\n\n## Syntax\n\n**TypeConverterAttribute(string)**  \n\n**TypeConverterAttribute(type)**\n\n## Examples\n\n```csharp\n// Only applied to this property: can just implement a general TypeConveter  \n[TypeConverter(typeof(MyCustomBoolConveter))]  \npublic bool CustomBool\n\n// Applied to the entire indicator: must implement an IndicatorBaseTypeConveter  \n[TypeConverter(\"NinjaTrader.NinjaScript.Indicators.MyConverter\")]  \npublic class MyCustomIndicator : Indicator  \n{  \n   \n}  \n   \n// Applied to the entire strategy: must implement a StrategyBaseTypeConveter  \n[TypeConverter(\"NinjaTrader.NinjaScript.Strategies.MyCustomConveter\")]  \npublic class MyCustomStrategy : Strategy  \n{  \n   \n}\n```"
  },
  {
    "_id": "9bfac98c5b6579fbb4b8d692c608d0aac4d9bf74ddda202976b2f29330ada888",
    "_type": "desktopSdkDoc",
    "title": "Typical",
    "pathName": "typical",
    "parent": "priceseries",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical bar typical prices. Typical price = (High + Low + Close) / 3.\n\n## Property Value\n\nAn ISeries<`double`> type object. Accessing this property via an index value [int barsAgo] returns a double value representing the price of the referenced bar.\n\n## Syntax\n\n**Typical**  \n\n**Typical[int barsAgo]**\n\n## Examples\n\n```csharp\n// Current bar typical price  \ndouble barTypicalPrice = Typical[0];  \n   \n// Typical price of 10 bars ago  \ndouble barTypicalPrice = Typical[10];  \n   \n// Current bar value of a 20 period exponential moving average of typical prices  \ndouble value = EMA(Typical, 20)[0];\n```"
  },
  {
    "_id": "dbbea19a272f464215a42135b98111f6594b0c37fd598095b7f80bd080f0a0c4",
    "_type": "desktopSdkDoc",
    "title": "Typicals",
    "pathName": "typicals",
    "parent": "priceseries",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries<`double`>** objects holding historical bar typical prices. An ISeries<`double`> object is added to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the typical prices of all Bars objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of ISeries<`double`> objects.\n\n## Syntax  \n\n**Typicals[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()  \n{  \n    if (State == State.Configure)  \n    {  \n        // Adds a 5 minute Bars object to the strategy and is automatically assigned  \n        // a Bars object index of 1 since the primary data the strategy is run against  \n        // set by the UI takes the index of 0.  \n        AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);  \n    }  \n}  \n   \nprotected override void OnBarUpdate()  \n{  \n    // Compares the primary bar's typical price to the 5-minute bar's typical price  \n    if (Typicals[0][0] > Typicals[1][0])  \n        Print(\"The primary bar's typical price is greater\");  \n}\n```"
  },
  {
    "_id": "f5398876eb2cebb8704ca29b26aa6056ecc4f01024ca3c245c4fab01a1e593ff",
    "_type": "desktopSdkDoc",
    "title": "Ulcer`",
    "pathName": "ulcer",
    "parent": "tradesperformancevalues",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nReturns the Ulcer.  \n\n## Property Value\n\nA **double** value that represents the Ulcer.\n\n## Syntax  \n\n<`TradeCollection`>.TradesPerformance.<`TradesPerformanceValues`>.**Ulcer**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()  \n{  \n    // Print out the Ulcer index of all trades  \n    Print(\"Turnaround of all trades is: \" + SystemPerformance.AllTrades.TradesPerformance.Currency.Ulcer);  \n}\n```"
  },
  {
    "_id": "1a89251fc7d0b54af3c22deebe6d14a893f13c7d3fe3eb071592bc9f2c6c4ff0",
    "_type": "desktopSdkDoc",
    "title": "Ultimate Oscillator",
    "pathName": "ultimate_oscillator",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by Larry Williams and introduced in his article in the April, 1985 issue of Technical Analysis of Stocks and Commodities magazine, this indicator is the weighted sum of three oscillators of different time periods. The there time periods represent short, intermediate and long term market cycles. Typical periods are 7, 14 and 28. The values of the Ultimate Oscillator range from zero to 100. Values over 70 indicate overbought conditions, and values under 30 indicate oversold conditions.\n\n## Syntax\n\n**UltimateOscillator(int fast, int intermediate, int slow)**  \n\n**UltimateOscillator(ISeries<`double`> input, int fast, int intermediate, int slow)**\n\n### Returns default value  \n\n**UltimateOscillator[int fast, int intermediate, int slow](int barsAgo)**  \n\n**UltimateOscillator[ISeries<`double`> input, int fast, int intermediate, int slow](int barsAgo)**\n\n## Return Value\n\ndouble; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* fast\n\n* The number of bars to include in the short term period\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* intermediate\n\n* The number of bars to include in the intermediate term period\n\n---\n\n* slow\n\n* The number of bars to include in the long term period\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value of a typical Ultimate Oscillator using default price type  \ndouble value = UltimateOscillator(7, 14, 28)[0];  \nPrint(\"The current Ultimate Oscillator value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "a425046bfe89e3677fbb925e86f191de1ed9d31e70029d49ea4d3954dae496fb",
    "_type": "desktopSdkDoc",
    "pathName": "unmanaged_cancelorder",
    "parent": "unmanaged_approach",
    "order": 0,
    "section": "references",
    "markdown": "Please see the \"[CancelOrder()](managed_cancelorder)\" section under the \"Managed Approach\"."
  },
  {
    "_id": "5075e6a8a9f59fd3046ee61b13754f5a29457350167bce265f6fbbfac7b14309",
    "_type": "desktopSdkDoc",
    "title": "ChangeOrderUnmanaged()",
    "pathName": "unmanaged_changeorder",
    "parent": "unmanaged_approach",
    "order": 0,
    "section": "references",
    "markdown": "Please see the \"[ChangeOrder()](managed_changeorder)\" section under the \"Managed Approach\"."
  },
  {
    "_id": "f43e28e9c96cdadcf6ab96a699453b529d9fbef807407b9fac01ccee4bfaa588",
    "_type": "desktopSdkDoc",
    "title": "UpBrush",
    "pathName": "upbrush",
    "parent": "chart_style",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA [Brush](https://msdn.microsoft.com/en-us/library/system.windows.media.brush(v=vs.110).aspx) object used to determine the color to paint the up bars for the ChartStyle.\n\n{% callout type =\"note\" %}\n\nThis Windows Presentation Forms (WPF) implementation of the Brush class is not directly used to paint bars on the chart. Instead it is converted to a SharpDX Brush in the [UpBrushDX](upbrushdx) property. This property is used to capture user input for changing brush colors.\n\n{% /callout }\n\n## Property  Value\n\nA [WPF](https://msdn.microsoft.com/en-us/library/ms754130(v=vs.110).aspx) Brush object used to paint the up bars\n\n## Syntax\n\n**UpBrush**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()  \n{  \n  if (State == State.Configure)  \n  {  \n      // Set a new name for the UpBrush property  \n      SetPropertyName(\"UpBrush\", \"AdvancingBrush\");  \n  }  \n}\n```"
  },
  {
    "_id": "576c1b2adb84fd97ac396d3b65dc7ffbfc41b633b22f753af03a6f411bf464ee",
    "_type": "desktopSdkDoc",
    "title": "UpBrushDX",
    "pathName": "upbrushdx",
    "parent": "chart_style",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA SharpDX [Brush](sharpdx_direct2d1_brush) object used to paint the up bars for the ChartStyle.\n\n## Property  Value\n\nA [SharpDX](sharpdx_direct2d1) Brush object used to paint the up bars\n\n## Syntax\n\n**UpBrushDX**\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale, ChartBars chartBars)  \n{  \n  for (int idx = chartBars.FromIndex; idx <= chartBars.ToIndex; idx++)  \n      {  \n          double     closeValue             = bars.GetClose(idx);  \n          double     openValue               = bars.GetOpen(idx);  \n   \n          // Set the brush of the current candle to UpBrushDX or DownBrushDX, depending on the  \n          // bar direction  \n          Brush brush = closeValue >= openValue ? UpBrushDX : DownBrushDX;  \n      }  \n}\n```"
  },
  {
    "_id": "2937013f2181810606b2a799b05bda2849f3e369a20982a4138f0e0a55984ce4",
    "_type": "desktopSdkDoc",
    "title": "Update()",
    "pathName": "update",
    "parent": "onbarupdate",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nForces the OnBarUpdate() method to be called for all data series so that indicator values are updated to the current bar index.  If the values are already up to date, the Update() method will not be run.\n\n{% callout type=\"note\" %}\n\n- This method is only relevant in specific use cases and should only used by advanced programmers\n\n- The additional overload where a bar index and [BarsInProgress](barsinprogress) are specified should only be used when an indicator needs to be updated to a bar index that is not the [CurrentBar](currentbar) index. For example, updating an indicator's secondary 1 tick data series to indicator.BarsArray[1].Count - 1, which is not the [CurrentBar](currentbar) index. This is required for the proper function of [Order Flow Cumulative Delta](order_flow_cumulative_delta.md) and [Order Flow VWAP](order_flow_vwap.md)\n\n{% /callout }\n\nWhen indicators are embedded (called) within a NinjaScript strategy, they are optimized to calculate only when they are called upon in a historical backtest. Since the NinjaTrader indicator model is very flexible, it is possible to create public properties on a custom indicator that return values of internal user defined variables. If these properties require that the OnBarUpdate() method is called before returning a value, include a call to this Update() method in the property getter.\n\n## Syntax\n\n**Update()**\n\n**Update(int idx, int bip)**\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* idx\n\n* The current bar index value to update to\n\n---\n\n* bip\n\n* The [BarsInProgress](barsinprogress) to update\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\nprivate double tripleValue = 0;  \n   \nprotected override void OnBarUpdate()  \n{  \n  if (CurrentBar < 20)  \n      return;  \n   \n  tripleValue = SMA(20)[0] * 3;  \n  Value[0] = SMA(20)[0];  \n}  \n   \npublic double TripleValue  \n{  \n    get  \n    {  \n      //call OnBarUpdate before returning tripleValue  \n      Update();  \n      return tripleValue;  \n    }  \n}\n```"
  },
  {
    "_id": "28e5ebabd9d8f6e237df63da2b503785093f0229241bc7021198f63c43b93269",
    "_type": "desktopSdkDoc",
    "title": "Url",
    "pathName": "url",
    "parent": "masterinstrument",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the Url configured for the [Master Instrument properties](editing_instruments).\n\n## Property Value\n\nA **string** value representing the Url that is configured for the current master instrument.\n\n## Syntax\n\n**Bars.Instrument.MasterInstrument.Url**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()\n\n {\n\n         // Displays the master instrument's URL at the bottom right of the chart\n\n         Draw.TextFixed(this, \"tag1\", \"Instruments URL is \" + Bars.Instrument.MasterInstrument.Url, TextPosition.BottomRight);\n\n }\n```"
  },
  {
    "_id": "44089be1da32ac4c638404cdad114c4d1df9030d1626d20eee1d97beeb5563d8",
    "_type": "desktopSdkDoc",
    "title": "Valid Input Data for Indicator Methods",
    "pathName": "indicators",
    "parent": "system_indicator_methods",
    "order": 0,
    "markdown": "System indicator methods require valid input data to function property. Indicator methods can accept the following forms of input data:\n\n## Default Input  \n\nThe default input (Inputs[[BarsInProgress](https://ninjatrader.com/support/helpguides/nt8/barsinprogress.htm)]) of the custom indicator, Market Analyzer row or strategy is used if input is not specified.\n\n```csharp\n// Printing the current value of the 10 period SMA of closing prices  \n// using the default input.  \ndouble value = SMA(10)[0];  \nPrint(\"The current SMA value is \" + value.ToString());\n```\n\n## Price Series\n\nOpen, High, Low, Close and Volume can all be used as input for an indicator method.\n\n```csharp\n// Passing in the a price series of High prices and printing out the current value of the  \n// 14 period simple moving average  \ndouble value = SMA(High, 14)[0];  \nPrint(\"The current SMA value is \" + value.ToString());\n```\n\n## Indicator  \n\nIndicators can be used as input for other indicators.\n\n```csharp\n// Printing the current value of the 20 period simple moving average of a 14 period RSI  \n// using a data series of closing prices  \ndouble value = SMA(RSI(Close, 14, 3), 20)[0];  \nPrint(\"The current SMA value is \" + value.ToString());\n```\n\n## Series<`double`>  \n\n[Series<`double`>](https://ninjatrader.com/support/helpguides/nt8/seriest.htm) can be used as input for indicators.\n\n```csharp\n// Instantiating a new Series<double> object and passing it in as input to calculate  \n// a simple moving average  \nSeries<double> myDataSeries = new Series<double>(this);  \ndouble value = SMA(myDataSeries, 20)[0];\n```\n\n## Bars Object  \n\nA Bars object (which holds a series that contains OHLC data) can be used as input for indicators.\n\n```csharp\n// Passing in the second Bars object held in a multi-instrument and timeframe strategy  \n// The default value used for the SMA calculation is the close price  \ndouble value = SMA(BarsArray[1], 20)[0];  \nPrint(\"The current SMA value is \" + value.ToString());;\n```\n\n{% callout type=\"note\" %}\n\nTip: The input series of an indicator cannot be the hosting indicator itself, as this will cause recursive loops.\n\n{% /callout %}\n\n```csharp\n// Using the hosting indicator in this way will cause errors with recursive loops  \ndouble value = SMA(this, 20)[0];|\n```"
  },
  {
    "_id": "cd42404d52ad55ccfa9aca4adc828aa5800ad9d385a0671fbcbf724118320619",
    "_type": "desktopSdkDoc",
    "title": "Value",
    "pathName": "value",
    "parent": "priceseries",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA collection of historical references to the first ISeries object Values[0] in the indicator. This is the primary indicator value (synched to the primary series in case of a [MultiSeries](multi_time_frame_instruments.md) indicator)\n\n## Property Value\n\nAn ISeries<`double`> object.\n\n## Syntax\n\n**Value**\n\n## Examples\n\n```csharp\n// OnBarUpdate method of a custom indicator  \nprotected override void OnBarUpdate()  \n{  \n    // Ensures we have enough bars loaded for our indicator  \n    if (CurrentBar < 1)  \n        return;  \n   \n    // Evaluates the indicator primary value 1 bar ago and sets the value of the indicator  \n    // for the current bar being evaluated  \n    if (Value[1] < High[0] - Low[0])  \n        Value[0] = High[0] - Low[0];  \n    else  \n        Value[0] = High[0] - Close[0];  \n}\n```"
  },
  {
    "_id": "89445ea08b55421faa49919a5fd272e9a520f701b479d6084847e161ca5b7711",
    "_type": "desktopSdkDoc",
    "title": "Values",
    "pathName": "values",
    "parent": "priceseries",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of **ISeries<`double`>** objects holding hold the indicator's underlying calculated values. ISeries<`double`> values are added to this array when calling the [AddPlot()](addplot) method. In case of a [MultiSeries](multi_time_frame_instruments.md) indicator synched to the primary series.\n\n## Property Value\n\nA collection of **ISeries<`double`>** objects.\n\n## Syntax\n\n**Values[int index]**\n\n## Examples\n\n```csharp\n// OnBarUpdate method of a custom indicator  \nprotected override void OnBarUpdate()  \n{  \n    // Ensures we have enough bars loaded for our indicator  \n    if (CurrentBar < 1)  \n        return;  \n   \n    // Evaluates the indicator's secondary value 1 bar ago and sets the value of the indicator  \n    // for the current bar being evaluated  \n    if (Values[1][1] < High[0] - Low[0])  \n        Value[0] = High[0] - Low[0];  \n    else  \n        Value[0] = High[0] - Close[0];  \n}\n```"
  },
  {
    "_id": "8aad089a4e3bd005384c3c29e198a9256cc609a092e62b746e8435d00491e6b5",
    "_type": "desktopSdkDoc",
    "title": "VerticalLine",
    "pathName": "verticalline",
    "parent": "drawing",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents an interface that exposes information regarding a Vertical Line [IDrawingTool](idrawingtool).\n\n## Methods and Properties\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* StartAnchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the starting point of the drawing object\n\n---\n\n* EndAnchor\n\n* An [IDrawingTool's ChartAnchor](idrawingtool#chartanchor) representing the end point of the drawing object\n\n---\n\n* Stroke\n\n* A [Stroke](stroke_class) object used to draw the object\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Instantiate a VerticalLine object  \nVerticalLine myLine = Draw.VerticalLine(this, \"tag1\", 10, Brushes.Black);  \n   \n// Change the object's Stroke  \nmyLine.Stroke = new Stroke(Brushes.BlanchedAlmond, DashStyleHelper.Dot, 5);\n```"
  },
  {
    "_id": "62d7a6b1211d627650e2bf0c869b69b564e2cd74290ae1dd78ae4b5e20b0cfe7",
    "_type": "desktopSdkDoc",
    "title": "Volume (VOL)",
    "pathName": "volume",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nVolume is simply the number of shares (or contracts) traded during a specified time frame (e.g., hour, day, week, month, etc). The analysis of volume is a basic yet very important element of technical analysis. Volume provides clues as to the intensity of a given price move.\n\n... Courtesy of [Market In Out](http://www.marketinout.com/technical_analysis.php?id=114)\n\n## Syntax\n\n**VOL()**  \n**VOL(ISeries<`double`> input)**\n\n### Returns default value  \n\n**VOL()[int barsAgo]**  \n**VOL(ISeries<`double`> input)[int barsAgo]**\n\n## Return Value\n\ndouble; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value VOL  \ndouble value = VOL()[0];  \nPrint(\"The current VOL value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "a42ef0959d7d82c4ce1a00c3ad472d111f751b0851e99d5019fcce3846748e2a",
    "_type": "desktopSdkDoc",
    "title": "VolumeSeries<double>",
    "pathName": "volumeseries",
    "parent": "iseriest",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nRepresents historical volume data as ISeries<`double`> interface which can be used for custom NinjaScript object calculations\n\n{% callout type=\"note\" %}\n\nIn most cases, you will access the historical volume series using a core event handler such as OnBarUpdate.  For more advance developers, you may find situations where you wish to access historical volume series outside of the core event methods, such as your own custom mouse click.  In these advanced scenarios, you may run into situations where the barsAgo pointer is not in sync with the current bar, which may cause errors when trying to obtain this information.  In those cases, use the Bars.Get...() methods with the absolute bar index, e.g., [Bars.GetVolume()](getvolume).\n\n{ /callout }\n\n## Single ISeries<`double`>\n\n{% table %}\n\n* Property\n\n* Description\n\n---\n\n* [Volume](iseries_volume)\n\n* A collection of historical bar volume values.\n\n---\n\n{% /table %}\n\n## Multi-Time Frame ISeries<`double`>\n\n{% table %}\n\n* Property\n\n* Description\n\n---\n\n* [Volumes](iseries_volumes)\n\n* Holds an array of ISeries<`double`> objects holding historical bar volume.\n\n---\n\n{% /table %}"
  },
  {
    "_id": "b52d79c45c85b36d3ae0e794b27e9c78e9c36e196fb9539ca3a5e7171a9ccaa4",
    "_type": "desktopSdkDoc",
    "title": "Volume Moving Average (VOLMA)",
    "pathName": "volume_moving_average_volma",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Volume Moving Average indicator is an indicator on indicator implementation. It calculates and returns the value of an [exponential moving average](moving_average_-_exponential_e) of [volume](volume).\n\n## Syntax\n\n**VOLMA(int period)**  \n**VOLMA(ISeries<`double`> input, int period)**\n\n### Returns default value  \n\n**VOLMA[int period](int barsAgo)**  \n**VOLMA[ISeries<`double`> input, int period](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Evaluates if the current volume is greater than the 20 period EMA of volume  \nif (Volume[0] > VOLMA(20)[0])  \n  Print(\"Volume has risen above its 20 period average\");\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "2bdc957e0b185c1587014af8d75b6f1f24fb5ce77ef183280679549235b060b8",
    "_type": "desktopSdkDoc",
    "title": "Volume Oscillator",
    "pathName": "volume_oscillator",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe Volume Oscillator uses the difference between two [moving averages](moving_average_-_simple_sma) of [volume](volume) to determine if the trend is increasing or decreasing. A value above zero indicates that the shorter term volume moving average has risen above the longer term volume moving average. This indicates that the shorter term trend is higher than the longer term trend. Rising prices with with increased short term volume is bullish as is falling prices with decreased volume. Falling prices with increased volume or rising prices with decreased volume indicate market weakness.\n\n## Syntax\n\n**VolumeOscillator(int fast, int slow)**  \n**VolumeOscillator(ISeries<`double`> input, int fast, int slow)**\n\n### Returns default value  \n\n**VolumeOscillator(int fast, int slow)[int barsAgo]**  \n\n**VolumeOscillator(ISeries<`double`> input, int fast, int slow)\n[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n*  fast\n\n* The number of bars to include in the short term moving average\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n\n* Number of bars used in the calculation\n\n---\n* slow\n* The number of bars to include in the long term moving average\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value of a Volume Oscillator  \ndouble value = VolumeOscillator(12, 26)[0];  \nPrint(\"The current Volume Oscillator value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "5c23baf588ba9f5b6fb6f36f2e16fff9e8dabbd4d9d60ca86efde9235ba41de7",
    "_type": "desktopSdkDoc",
    "title": "Volume Rate of Change (VROC)",
    "pathName": "volume_rate_of_change_vroc",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nVolume Rate of Change is identical to [Price Rate Of Change (ROC)](rate_of_change_roc) indicator except that it uses volume instead of price.\n\n## Syntax\n\n**VROC(int period, int smooth)**  \n\n**VROC(ISeries<`double`> input, int period, int smooth)**\n\n### Returns default value  \n\n**VROC[int period, int smooth](int barsAgo)**  \n\n**VROC[ISeries<`double`> input, int period, int smooth](int barsAgo)**\n\n## Return Value\n\ndouble; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n\n* Number of bars used in the calculation\n\n---\n\n* smooth\n\n* The number of bars for smoothing the signal\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value of VROC  \ndouble value = VROC(13, 3)[0];  \nPrint(\"The current VROC value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "4ffec4ed45efaa6fc0a8a18a2b854c2344f5a4f12403ccec0ee2da061e43f9a6",
    "_type": "desktopSdkDoc",
    "title": "Volume Up Down",
    "pathName": "volume_up_down",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nVariation of the [VOL](volume) (Volume) indicator that colors the volume histogram different color depending if the current bar is up or down bar.\n\n## Syntax\n\n**VolumeUpDown()**  \n**VolumeUpDown(ISeries<`double`> input)**\n\n### Returns default value  \n\n**VolumeUpDown()[int barsAgo]**  \n**VolumeUpDown[ISeries<`double`> input](int barsAgo)**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value VolumeUpDown  \ndouble value = VolumeUpDown()[0];  \nPrint(\"The current Volume value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "b0a1715b62bcb820919cc2c6da7bcac36c2c6c59d78add1e0a27e4f151338a7d",
    "_type": "desktopSdkDoc",
    "title": "Weighteds",
    "pathName": "weighteds",
    "parent": "priceseries",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of ISeries<`double`> objects holding historical bar weighted prices. An ISeries<`double`> object is added to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the weighted prices of all Bars objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of **ISeries<`double`>** objects.\n\n## Syntax  \n\n**Weighteds[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()  \n{  \n    if (State == State.Configure)  \n    {  \n        // Adds a 5-minute Bars object to the strategy and is automatically assigned  \n        // a Bars object index of 1 since the primary data the strategy is run against  \n        // set by the UI takes the index of 0.  \n        AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);  \n    }  \n}  \n   \nprotected override void OnBarUpdate()  \n{  \n    // Compares the primary bar's weighted price to the 5-minute bar's weighted price  \n    if (Weighteds[0][0] > Weighteds[1][0])  \n        Print(\"The primary bar's weighted price is greater\");  \n}\n```"
  },
  {
    "_id": "b0a1715b62bcb820919cc2c6da7bcac36c2c6c59d78add1e0a27e4f151338a7d",
    "_type": "desktopSdkDoc",
    "title": "Weighteds",
    "pathName": "weighteds",
    "parent": "priceseries",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nHolds an array of ISeries<`double`> objects holding historical bar weighted prices. An ISeries<`double`> object is added to this array when calling the [AddDataSeries()](adddataseries) method. Its purpose is to provide access to the weighted prices of all Bars objects in a multi-instrument or multi-time frame script.\n\n## Property Value\n\nAn array of ISeries<`double`> objects.\n\n## Syntax  \n\n**Weighteds[int barSeriesIndex][int barsAgo]**\n\n## Examples\n\n```csharp\nprotected override void OnStateChange()  \n{  \n    if (State == State.Configure)  \n    {  \n        // Adds a 5-minute Bars object to the strategy and is automatically assigned  \n        // a Bars object index of 1 since the primary data the strategy is run against  \n        // set by the UI takes the index of 0.  \n        AddDataSeries(\"AAPL\", BarsPeriodType.Minute, 5);  \n    }  \n}  \n   \nprotected override void OnBarUpdate()  \n{  \n    // Compares the primary bar's weighted price to the 5-minute bar's weighted price  \n    if (Weighteds[0][0] > Weighteds[1][0])  \n        Print(\"The primary bar's weighted price is greater\");  \n}\n```"
  },
  {
    "_id": "dec0f004eaa07c2a283ea326df8f00c2c3c60b002c9bb8d452b1dcff5ba795cb",
    "_type": "desktopSdkDoc",
    "title": "Width",
    "pathName": "width",
    "parent": "chartscale",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the overall distance (from left to right) of the chart scale.\n\n{% callout type=\"note\" %}\n\nWidth does not return its value in terms of device pixels. However, using Width.ConvertToVerticalPixels or Width.ConvertToHorizontalPixels will convert the Width value to device pixels. Alternatively, RenderTarget.PixelSize.Width or ChartPanel.W will also provide the width in terms of device pixels.\n\n{% /callout %}\n\n## Property Value\n\nA double value representing the width of the chart scale.\n\n## Syntax\n\n<`chartScale`>.Width\n\n## Examples\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)  \n{  \n  // the width of the entire chart scale  \n  double   width       = chartScale.Width;  \n  Print(\"the width of the chart scale is: \" + Width);    \n}\n```\n\nIn the image below, the entire of width of the chart scale is represented by the blue line which is calculated at 450 pixels.\n\n![Width](https://cdn.sanity.io/images/1hlwceal/production/6f2dd3610b9b325c2775878a32954655b7cacff9-535x433.png)"
  },
  {
    "_id": "4eb0d87e16a28b3dc8a7e5096d97ebcc1f6983c1692cc4e003925614ad4fbf6d",
    "_type": "desktopSdkDoc",
    "title": "Williams %R",
    "pathName": "williams_r",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nDeveloped by Larry Williams, Williams %R is a momentum indicator that works much like the [Stochastic Oscillator](stochastics). It is especially popular for measuring overbought and oversold levels. The scale ranges from 0 to -100 with readings from 0 to -20 considered overbought, and readings from -80 to -100 considered oversold.\n\n... Courtesy of [StockCharts](https://school.stockcharts.com/doku.php?id=technical_indicators:williams_r)\n\n## Syntax\n\n**WilliamsR(int period)**  \n\n**WilliamsR(ISeries<`double`> input, int period)**\n\n### Returns default value  \n\n**WilliamsR(int period)[int barsAgo]**  \n\n**WilliamsR(ISeries<`double`> input, int period)[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* period\n\n* Number of bars used in the calculation\n\n---\n\n{% /table %}\n\n## Examples\n\n```csharp\n// Prints the current value of a 20 period WilliamsR using default price type  \ndouble value = WilliamsR(20)[0];  \nPrint(\"The current WilliamsR value is \" + value.ToString());  \n   \n// Prints the current value of a 20 period WilliamsR using high price type  \ndouble value = WilliamsR(High, 20)[0];  \nPrint(\"The current WilliamsR value is \" + value.ToString());\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  },
  {
    "_id": "853dabb1dffc45135f594fbc5d2d2bce09c44493178751752806dd8b93d07102",
    "_type": "desktopSdkDoc",
    "title": "WinningTrades",
    "pathName": "winningtrades",
    "parent": "tradecollection",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nA subcollection of [Trade](trade) objects consisting of only the winning trades in a [TradeCollection](tradecollection). You can access a trade object by providing an index value. Trades are indexed sequentially meaning the oldest trade taken in a strategy will be at an index value of zero. The most recent trade taken will be at an index value of the total trades in the collection minus 1.\n\n## Methods and Properties\n\n{% table %}\n\n* Method/Property\n\n* Description\n\n---\n\n* [Count](tradecollection_tradescount)\n\n* An int value representing the number of trades in the collection\n\n---\n\n* [GetTrades()](gettrades)\n\n* Gets a [TradeCollection](tradecollection) object representing a specified position\n\n---\n\n* [TradesPerformance](tradesperformance)\n\n* Gets a [TradesPerformance](tradesperformance) object\n\n---\n\n{% /table %}\n\n## Syntax  \n\n<`TradeCollection`>.**WinningTrades**\n\n## Examples\n\n```csharp\nprotected override void OnBarUpdate()  \n{  \n    // Accesses the first/last winning trade in the strategy (oldest trade is at index 0)  \n    // and prints out the profit as a percentage to the output window  \n    if (SystemPerformance.AllTrades.WinningTrades.Count > 1)  \n    {  \n        Trade lastTrade = SystemPerformance.AllTrades.WinningTrades[SystemPerformance.AllTrades.Count - 1];  \n        Trade firstTrade = SystemPerformance.AllTrades.WinningTrades[0];  \n   \n        Print(\"The last winning trade's profit was \" + lastTrade.ProfitPercent);  \n        Print(\"The first winning trade's profit was \" + firstTrade.ProfitPercent);  \n    }  \n}\n```"
  },
  {
    "_id": "af3e75bcdf9e92efeca7e21346dcd777a28cc2c3ff2e428754ef670cb0ffc5e1",
    "_type": "desktopSdkDoc",
    "title": "Woodies CCI",
    "pathName": "woodies_cci",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nNinjaTrader provides the **Woodies CCI** indicator. It's implemented as specified by Woodie.\n\n## Syntax\n\n**WoodiesCCI()**  \n**WoodiesCCI(ISeries<`double`> input)**\n\n### Returns default value  \n\n**WoodiesCCI()[int barsAgo]**  \n**WoodiesCCI(ISeries<`double`> input)[int barsAgo]**\n\n### Returns turbo value  \n\n**WoodiesCCI().Turbo[int barsAgo]**  \n\n**WoodiesCCI(ISeries<`double`> input).Turbo[int barsAgo]**\n\n### Returns histogram bar color  \n\n**WoodiesCCI().ZoneBars[int barsAgo]**  \n\n**WoodiesCCI(ISeries<`double`> input).ZoneBars[int barsAgo]**\n\nReturn values representing the chopzone plot color are as follows:\n\n- 0 = Negative (default color is red)  \n- 1 = Positive (default color is blue)  \n- 2 = Neutral (default color is gray)  \n- 3 = Last neutral bar (default color is yellow)\n\n### Returns chopzone value  \n\n**WoodiesCCI().ChopZone[int barsAgo]**  \n\n**WoodiesCCI(ISeries<`double`> input).ChopZone[int barsAgo]**\n\nReturn values representing the chopzone plot color are as follows:\n\n- -4 = DarkRed  \n- -3 = LightRed  \n- -2 = DarkOrange  \n- -1 = LightOrange  \n- 0 = Yellow  \n- 1 = Lime  \n- 2 = LightGreen  \n- 3 = DarkGreen  \n- 4 = Cyan  \n \n\n### Returns sidewinder value  \n\n**WoodiesCCI().Sidewinder[int barsAgo]**  \n\n**WoodiesCCI(ISeries<`double`> input).Sidewinder[int barsAgo]**  \n   \nReturn values representing the sidewinder plot value are as follows:  \n   \n- -1 = Warning  \n- 0 = Neutral  \n- 1 = Trending\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n---\n\n* input\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current value of a 14 period WoodiesCCI using default price type  \ndouble value = WoodiesCCI(2, 5, 14, 34, 25, 6, 60, 100, 2)[0];  \nPrint(\"The current WoodiesCCI value is \" + value.ToString());\n\n// Prints the current turbo value of a 14 / 6 period WoodiesCCI using default price type  \ndouble value2 = WoodiesCCI(2, 5, 14, 34, 25, 6, 60, 100, 2).Turbo[0];  \nPrint(\"The current WoodiesCCI turbo value is \" + value2.ToString());\n```"
  },
  {
    "_id": "b12ca99879ee68d88556965784144bba1c32022fb63e95f4fe785c4766caa5b8",
    "_type": "desktopSdkDoc",
    "title": "Woodies Pivots",
    "pathName": "woodies_pivots",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nWoodies CCI Club pivots indicator.\n\n## Syntax\n\n**WoodiesPivots(HLCCalculationModeWoodie priorDayHLC, int width)**  \n**WoodiesPivots(ISeries<`double`> input, HLCCalculationModeWoodie priorDayHLC, int width)**  \n\nReturns pivot point value  \n\n**WoodiesPivots(HLCCalculationModeWoodie priorDayHLC, int width).PP[int barsAgo]**  \n\n**WoodiesPivotsISeries<`double`> input, HLCCalculationModeWoodie priorDayHLC, int width).PP[int barsAgo]**  \n\nReturns R1 value  \n**WoodiesPivots(HLCCalculationModeWoodie priorDayHLC, int width).R1[int barsAgo]**  \n\n**WoodiesPivots(ISeries<`double`> input, HLCCalculationModeWoodie priorDayHLC, int width).R1[int barsAgo]**  \n\nReturns R2 value  \n**WoodiesPivots(HLCCalculationModeWoodie priorDayHLC, int width).R2[int barsAgo]**  \n\n**WoodiesPivots(ISeries<`double`> input, HLCCalculationModeWoodie priorDayHLC, int width).R2[int barsAgo]**  \n\nReturns S1 value  \n**WoodiesPivots(HLCCalculationModeWoodie priorDayHLC, int width).S1[int barsAgo]**  \n\n**WoodiesPivots(ISeries<`double`> input, HLCCalculationModeWoodie priorDayHLC, int width).S1[int barsAgo]**  \n\nReturns S2 value  \n**WoodiesPivots(HLCCalculationModeWoodie priorDayHLC, int width).S2[int barsAgo]**  \n\n**WoodiesPivots(ISeries<`double`> input, HLCCalculationModeWoodie priorDayHLC, int width).S2[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* priorDayHLC\n\n* Sets how the prior range High, Low, Close values are calculated. Possible values are:\n\n  * HLCCalculationModeWoodie.CalcFromIntradayData\n\n  * HLCCalculationModeWoodie.DailyBars\n\n  * HLCCalculationModeWoodie.UserDefinedValues\n\n---\n\n* width\n\n* An int determining the width of the pivot values plotted\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the current pivot point value  \ndouble ppValue = WoodiesPivots(HLCCalculationModeWoodie.CalcFromIntradayData, 20).PP[0];  \nPrint(\"The current Woodies Pivots' pivot value is \" + ppValue);  \n   \n// Prints the current S2 pivot value  \ndouble s2Value = WoodiesPivots(HLCCalculationModeWoodie.CalcFromIntradayData, 20).S2[0];  \nPrint(\"The current Woodies Pivots' S2 pivot value is \" + s2Value);\n```\n\n{% callout type=\"note\" %}\n\nTip: When using HLCCalculationMode.**DailyBars** it can be expected that a value of 0 is returned when the daily bars have not been loaded yet. Due to the asynchronous nature of this indicator calling daily bars you should only access the pivot values when the indicator has loaded all required Bars objects. To ensure you are accessing accurate values you can use [.IsValidDataPoint()](isvaliddatapoint)as a check.\n\n{% /callout %}\n\n```csharp\n// Evaluates that this is a valid Woodies Pivots value  \nif (WoodiesPivots(HLCCalculationModeWoodie.DailyBars, 20).PP.IsValidDataPoint(0))  \n{  \n    // Prints the current pivot point value  \n    double value = WoodiesPivots(HLCCalculationModeWoodie.DailyBars, 20).PP[0];  \n    Print(\"The current Woodies Pivots' pivot value is \" + value.ToString());  \n}\n```"
  },
  {
    "_id": "3d9828bcd729f78da27db20756f475764e06cd2808c8ad166574634e232c9102",
    "_type": "desktopSdkDoc",
    "title": "WorkspaceOptions",
    "pathName": "workspaceoptions",
    "parent": "iworkspacepersistence_interface",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nSets required workspace options.\n\n{% callout type=\"note\" %}\n\n- The WorkspaceOptions class includes logic for opening, closing, saving, and restoring workspaces, checking windows are off screen, and setting basic properties such as the workspace name and current status.\n\n- A WorkspaceOptions property must simply be declared within your NTWindow, as in the example below. All of its contained logic is taken care of automatically.\n{% /callout %}\n\n## Examples\n\n```csharp\n// IWorkspacePersistence member\n\npublic WorkspaceOptions WorkspaceOptions { get; set; }\n```\n\n{% callout type=\"note\" %}\n\n**Tip**: For a complete, working example of this class in use, please download the [AddOn Framework NinjaScript Basic Example](AddOn_Framework_NinjaScript_Basic.zip) to your desktop.\n\n{% /callout %}"
  },
  {
    "_id": "19815f72427be95e1678fb0db3a719349e8289cae1db8036e4c619c532d15d8a",
    "_type": "desktopSdkDoc",
    "title": "W (Width)",
    "pathName": "w_width_chartpanel",
    "parent": "chartpanel",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the width (in pixels) of the paintable area of the chart panel.\n\n{% callout type=\"note\" %}\n\nThe paintable area does not extend all the way to the right edge of the panel itself, as seen in the image below.\n\n{% /callout }\n\n## Property Value\n\nA **int** representing the width of the panel in pixels\n\n## Syntax\n\nChartPanel.**W**\n\n## Example\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)  \n{  \n  base.OnRender(chartControl, chartScale);  \n     \n  // Print the width of the panel  \n  Print(ChartPanel.W);  \n}\n```\n\nBased on the image below, W reveals that the chart panel is 451 pixels wide.\n\n![chartpanel_w](https://cdn.sanity.io/images/1hlwceal/production/272505438485c2b076f0066d6626100aea434e0b-534x433.png)"
  },
  {
    "_id": "37175ad3cc1c89f23efa90c4e2104cf14145751b4b740728c850f13f70bd9297",
    "_type": "desktopSdkDoc",
    "title": "XmlIgnoreAttribute",
    "pathName": "xmlignoreattribute",
    "parent": "attributes",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nDetermines if the following declared property participates in the XML serialization routines which are used to save NinjaScript objects to a workspace or template.  The default behavior will attempt to serialize all public properties, however there may be some types of objects which cannot be serialized, or you may not wish for this property to be saved/restored.  Should that be the case, you can optionally set the object to be ignored by defining the XmlIgnore attribute.\n\n{% callout type=\"note\" %}\n\nThe **XmlIgnoreAttribute** object is a general purpose attribute made available from the .NET Framework.  The information on this page is written to demonstrate how you may use this object within NinjaScript conventions to be used for the NinjaTrader serialization (e.g., saving an indicator property to a workspace).  There are more methods and properties that you can learn about from MSDN's [XmlIgnoreAttribute Class](https://msdn.microsoft.com/en-us/library/system.xml.serialization.xmlignoreattribute(v=vs.110).aspx) which are NOT covered in this topic; as such there is NO guarantee they will work with the NinjaTrader serialization.\n\n{% /callout %}\n\n## Syntax\n\n**[XmlIgnore]**  \n\n**[XmlIgnore(bool)]**\n\n## Parameters\n\nThis attribute does not require any parameters; default value is true and usage will ensure the property is ignored by XML routines.\n\n## Examples\n\n```csharp\n#region Properties  \n   \n[XmlIgnore] // ensures that the property will NOT be saved/recovered as part of a chart template or workspace  \npublic Brush MyBrush    \n{ get; set; }  \n   \n#endregion\n```\n\n{% callout type=\"note\" %}\n\nTip:  A complete example of the usage of **XmlIgnore** attribute and workspace serialization can be found in the tips section of our support forum on [User Definable Color Inputs](user_definable_color_inputs)\n\n{% / callout %}"
  },
  {
    "_id": "f7abc7952cfd4cf47c192e569df1d258998c163996df85a82015972721c06873",
    "_type": "desktopSdkDoc",
    "title": "X (Coordinate)",
    "pathName": "x_coordinate_chartpanel",
    "parent": "chartpanel",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the **x-coordinate** on the chart canvas at which the chart panel begins.\n\n## Property Value\n\nA **int** representing the **x-coordinate** at which the panel begins. This property will only contain a value greater than zero if the y-axis displays to the left of the paintable chart canvas area in the panel (if an object in the panel is using the \"Left\" scale justification).\n\n## Syntax\n\nChartPanel.**X**\n\n## Example\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)  \n{  \n  base.OnRender(chartControl, chartScale);  \n     \n  // Print the coordinates of the top-left corner of the panel  \n  Print(String.Format(\"The panel begins at coordinates {0},{1}\",ChartPanel.X ,ChartPanel.Y));  \n}\n```\n\nBased on the image below, X reveals that the chart panel begins at x-coordinate 52.\n\n![chartpanel_x](https://cdn.sanity.io/images/1hlwceal/production/8402fb76e4bbd193ca8526d08bea24079a23fcd6-534x433.png)"
  },
  {
    "_id": "5ed4c8d699b3f15d224b4dd120b20c4acc2b023fc05316e752bb0abebf4963a6",
    "_type": "desktopSdkDoc",
    "title": "Y (Coordinate)",
    "pathName": "y_coordinate_chartpanel",
    "parent": "chartpanel",
    "order": 0,
    "section": "references",
    "markdown": "## Definition\n\nIndicates the **y-coordinate** on the chart canvas at which the chart panel begins.\n\n## Property Value\n\nA **int** representing the **y-coordinate** at which the panel begins.\n\n## Syntax\n\nChartPanel.**Y**\n\n## Example\n\n```csharp\nprotected override void OnRender(ChartControl chartControl, ChartScale chartScale)  \n{  \n  base.OnRender(chartControl, chartScale);  \n     \n  // Print the coordinates of the top-left corner of the panel  \n  Print(String.Format(\"The panel begins at coordinates {0},{1}\",ChartPanel.X ,ChartPanel.Y));  \n}\n```\n\nBased on the image below, Y reveals that the chart panel begins at y-coordinate 232.\n\n![chartpanel_y](https://cdn.sanity.io/images/1hlwceal/production/a4f39c5505ac60533a86ccc155406dd304d0bfb9-534x433.png)"
  },
  {
    "_id": "c629f93e48d3094d892315170c66b91c6098be8cfe98845a806d416c7e604a3e",
    "_type": "desktopSdkDoc",
    "title": "ZigZag",
    "pathName": "zigzag",
    "parent": "system_indicator_methods",
    "order": 0,
    "section": "references",
    "markdown": "## Description\n\nThe ZigZag indicator highlights trends based on user defined threshold values and helps filtering the noise in price charts, it's not a classical indicator but more a reactive filter showing extreme price points. In processing it's calculations it can update it's current direction and price extreme point based on newly incoming data, the current developing leg should be thought of temporary until a new leg in opposite direction has been set.\n\nYou can access methods within this indicator to determine the number of bars ago a zigzag high or low point occurred or the current zigzag value, it is only meaningful to work with in Calculate.OnBarClose mode for the [Calculate](calculate) property.\n\n## Syntax - Bars Ago\n\n### High Bar  \n\n**ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow).HighBar(int barsAgo, int instance, int lookBackPeriod)**  \n\n**ZigZag(ISeries<`double`> input, DeviationType deviationType, double deviationValue, bool useHighLow).HighBar(int barsAgo, int instance, int lookBackPeriod)**  \n\n### Low Bar  \n\n**ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow).LowBar(int barsAgo, int instance, int lookBackPeriod)**  \n\n**ZigZag(ISeries<`double`> input, DeviationType deviationType, double deviationValue, bool useHighLow).LowBar(int barsAgo, int instance, int lookBackPeriod)**\n\n## Return Value\n\nAn int value representing the number of bars ago. Returns a value of -1 if a swing point is not found within the look back period.\n\n## Syntax - Value\n\n### High Value  \n\n**ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow).ZigZagHigh[int barsAgo]**  \n**ZigZag(ISeries<`double`> input, DeviationType deviationType, double deviationValue, bool useHighLow).ZigZagHigh[int barsAgo]**  \n\n### Low Value  \n\n**ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow).ZigZagLow[int barsAgo]**  \n\n**ZigZag(ISeries<`double`> input, DeviationType deviationType, double deviationValue, bool useHighLow).ZigZagLow[int barsAgo]**\n\n## Return Value\n\n**double**; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.\n\n* Note: A return value of 0 (zero) indicates that a zigzag high or low has not yet formed.\n\n## Parameters\n\n{% table %}\n\n* Parameter\n\n* Description\n\n---\n\n* barsAgo\n\n* The number of bars ago that serves as the starting bar and works backwards\n\n---\n\n* deviationType\n\n* Possible values are:\n\n* DeviationType.Points\n\n* DeviationType.Percent\n\n---\n\n* deviationValue\n\n* The deviation value\n\n---\n\n* input\n\n* Indicator source data ([?](valid_input_data_for_indicator))\n\n---\n\n* instance\n\n* The occurrence to check for (1 is the most recent, 2 is the 2nd most recent etc...)\n\n---\n\n* lookBackPeriod\n\n* Number of bars to look back to check for the test condition. Test is evaluated on the current bar and the bars in the look back period.\n\n---\n\n* useHighLow\n\n* When true, both High and Low price series are used. When false, the default input is used for both highs and lows.\n\n---\n\n{% /table %}\n\n## Example\n\n```csharp\n// Prints the high price of the most recent zig zag high  \nPrint(\"The high of the zigzag bar is \" + High[Math.Max(0, ZigZag(DeviationType.Points, 0.5, false).HighBar(0, 1, 100))]);\n```\n\n## Source Code\n\nYou can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window."
  }
]